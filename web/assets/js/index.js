var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);

// node_modules/editorjs-drag-drop/dist/bundle.js
var require_bundle = __commonJS((exports, module) => {
  (function(e, t) {
    typeof exports == "object" && typeof module == "object" ? module.exports = t() : typeof define == "function" && define.amd ? define([], t) : typeof exports == "object" ? exports.DragDrop = t() : e.DragDrop = t();
  })(self, () => (() => {
    var e = { 523: (e2, t2, r2) => {
      r2.d(t2, { A: () => c3 });
      var n2 = r2(601), o3 = r2.n(n2), i = r2(314), a2 = r2.n(i)()(o3());
      a2.push([e2.id, `.ce-block--drop-target .ce-block__content:before {
  content: "";
  position: absolute;
  top: 50%;
  left: -20px;
  margin-top: -1px;
  height: 8px;
  width: 8px;
  border: solid #a0a0a0;
  border-width: 1px 1px 0 0;
  -webkit-transform-origin: right;
  transform-origin: right;
  -webkit-transform: rotate(45deg);
  transform: rotate(45deg);
}

.ce-block--drop-target .ce-block__content:after {
  background: none;
}
`, ""]);
      const c3 = a2;
    }, 314: (e2) => {
      e2.exports = function(e3) {
        var t2 = [];
        return t2.toString = function() {
          return this.map(function(t3) {
            var r2 = "", n2 = t3[5] !== undefined;
            return t3[4] && (r2 += "@supports (".concat(t3[4], ") {")), t3[2] && (r2 += "@media ".concat(t3[2], " {")), n2 && (r2 += "@layer".concat(t3[5].length > 0 ? " ".concat(t3[5]) : "", " {")), r2 += e3(t3), n2 && (r2 += "}"), t3[2] && (r2 += "}"), t3[4] && (r2 += "}"), r2;
          }).join("");
        }, t2.i = function(e4, r2, n2, o3, i) {
          typeof e4 == "string" && (e4 = [[null, e4, undefined]]);
          var a2 = {};
          if (n2)
            for (var c3 = 0;c3 < this.length; c3++) {
              var s = this[c3][0];
              s != null && (a2[s] = true);
            }
          for (var l2 = 0;l2 < e4.length; l2++) {
            var u2 = [].concat(e4[l2]);
            n2 && a2[u2[0]] || (i !== undefined && (u2[5] === undefined || (u2[1] = "@layer".concat(u2[5].length > 0 ? " ".concat(u2[5]) : "", " {").concat(u2[1], "}")), u2[5] = i), r2 && (u2[2] ? (u2[1] = "@media ".concat(u2[2], " {").concat(u2[1], "}"), u2[2] = r2) : u2[2] = r2), o3 && (u2[4] ? (u2[1] = "@supports (".concat(u2[4], ") {").concat(u2[1], "}"), u2[4] = o3) : u2[4] = "".concat(o3)), t2.push(u2));
          }
        }, t2;
      };
    }, 601: (e2) => {
      e2.exports = function(e3) {
        return e3[1];
      };
    }, 72: (e2) => {
      var t2 = [];
      function r2(e3) {
        for (var r3 = -1, n3 = 0;n3 < t2.length; n3++)
          if (t2[n3].identifier === e3) {
            r3 = n3;
            break;
          }
        return r3;
      }
      function n2(e3, n3) {
        for (var i = {}, a2 = [], c3 = 0;c3 < e3.length; c3++) {
          var s = e3[c3], l2 = n3.base ? s[0] + n3.base : s[0], u2 = i[l2] || 0, d3 = "".concat(l2, " ").concat(u2);
          i[l2] = u2 + 1;
          var f2 = r2(d3), p2 = { css: s[1], media: s[2], sourceMap: s[3], supports: s[4], layer: s[5] };
          if (f2 !== -1)
            t2[f2].references++, t2[f2].updater(p2);
          else {
            var v4 = o3(p2, n3);
            n3.byIndex = c3, t2.splice(c3, 0, { identifier: d3, updater: v4, references: 1 });
          }
          a2.push(d3);
        }
        return a2;
      }
      function o3(e3, t3) {
        var r3 = t3.domAPI(t3);
        return r3.update(e3), function(t4) {
          if (t4) {
            if (t4.css === e3.css && t4.media === e3.media && t4.sourceMap === e3.sourceMap && t4.supports === e3.supports && t4.layer === e3.layer)
              return;
            r3.update(e3 = t4);
          } else
            r3.remove();
        };
      }
      e2.exports = function(e3, o4) {
        var i = n2(e3 = e3 || [], o4 = o4 || {});
        return function(e4) {
          e4 = e4 || [];
          for (var a2 = 0;a2 < i.length; a2++) {
            var c3 = r2(i[a2]);
            t2[c3].references--;
          }
          for (var s = n2(e4, o4), l2 = 0;l2 < i.length; l2++) {
            var u2 = r2(i[l2]);
            t2[u2].references === 0 && (t2[u2].updater(), t2.splice(u2, 1));
          }
          i = s;
        };
      };
    }, 659: (e2) => {
      var t2 = {};
      e2.exports = function(e3, r2) {
        var n2 = function(e4) {
          if (t2[e4] === undefined) {
            var r3 = document.querySelector(e4);
            if (window.HTMLIFrameElement && r3 instanceof window.HTMLIFrameElement)
              try {
                r3 = r3.contentDocument.head;
              } catch (e5) {
                r3 = null;
              }
            t2[e4] = r3;
          }
          return t2[e4];
        }(e3);
        if (!n2)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
        n2.appendChild(r2);
      };
    }, 540: (e2) => {
      e2.exports = function(e3) {
        var t2 = document.createElement("style");
        return e3.setAttributes(t2, e3.attributes), e3.insert(t2, e3.options), t2;
      };
    }, 56: (e2, t2, r2) => {
      e2.exports = function(e3) {
        var t3 = r2.nc;
        t3 && e3.setAttribute("nonce", t3);
      };
    }, 825: (e2) => {
      e2.exports = function(e3) {
        if (typeof document == "undefined")
          return { update: function() {
          }, remove: function() {
          } };
        var t2 = e3.insertStyleElement(e3);
        return { update: function(r2) {
          (function(e4, t3, r3) {
            var n2 = "";
            r3.supports && (n2 += "@supports (".concat(r3.supports, ") {")), r3.media && (n2 += "@media ".concat(r3.media, " {"));
            var o3 = r3.layer !== undefined;
            o3 && (n2 += "@layer".concat(r3.layer.length > 0 ? " ".concat(r3.layer) : "", " {")), n2 += r3.css, o3 && (n2 += "}"), r3.media && (n2 += "}"), r3.supports && (n2 += "}");
            var i = r3.sourceMap;
            i && typeof btoa != "undefined" && (n2 += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(i)))), " */")), t3.styleTagTransform(n2, e4, t3.options);
          })(t2, e3, r2);
        }, remove: function() {
          (function(e4) {
            if (e4.parentNode === null)
              return false;
            e4.parentNode.removeChild(e4);
          })(t2);
        } };
      };
    }, 113: (e2) => {
      e2.exports = function(e3, t2) {
        if (t2.styleSheet)
          t2.styleSheet.cssText = e3;
        else {
          for (;t2.firstChild; )
            t2.removeChild(t2.firstChild);
          t2.appendChild(document.createTextNode(e3));
        }
      };
    } }, t = {};
    function r(n2) {
      var o3 = t[n2];
      if (o3 !== undefined)
        return o3.exports;
      var i = t[n2] = { id: n2, exports: {} };
      return e[n2](i, i.exports, r), i.exports;
    }
    r.n = (e2) => {
      var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
      return r.d(t2, { a: t2 }), t2;
    }, r.d = (e2, t2) => {
      for (var n2 in t2)
        r.o(t2, n2) && !r.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: t2[n2] });
    }, r.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r.nc = undefined;
    var n = {};
    return (() => {
      r.d(n, { default: () => g3 });
      var e2 = r(72), t2 = r.n(e2), o3 = r(825), i = r.n(o3), a2 = r(659), c3 = r.n(a2), s = r(56), l2 = r.n(s), u2 = r(540), d3 = r.n(u2), f2 = r(113), p2 = r.n(f2), v4 = r(523), y4 = {};
      function h4(e3) {
        return h4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, h4(e3);
      }
      function b4(e3, t3) {
        for (var r2 = 0;r2 < t3.length; r2++) {
          var n2 = t3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, m3(n2.key), n2);
        }
      }
      function m3(e3) {
        var t3 = function(e4, t4) {
          if (h4(e4) != "object" || !e4)
            return e4;
          var r2 = e4[Symbol.toPrimitive];
          if (r2 !== undefined) {
            var n2 = r2.call(e4, "string");
            if (h4(n2) != "object")
              return n2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(e4);
        }(e3);
        return h4(t3) == "symbol" ? t3 : t3 + "";
      }
      y4.styleTagTransform = p2(), y4.setAttributes = l2(), y4.insert = c3().bind(null, "head"), y4.domAPI = i(), y4.insertStyleElement = d3(), t2()(v4.A, y4), v4.A && v4.A.locals && v4.A.locals;
      var g3 = function() {
        return e3 = function e(t4, r3) {
          var { configuration: n2, blocks: o4, toolbar: i2, save: a3 } = t4;
          (function(e4, t5) {
            if (!(e4 instanceof t5))
              throw new TypeError("Cannot call a class as a function");
          })(this, e), this.toolbar = i2, this.borderStyle = r3 || "1px dashed #aaa", this.api = o4, this.holder = typeof n2.holder == "string" ? document.getElementById(n2.holder) : n2.holder, this.readOnly = n2.readOnly, this.startBlock = null, this.endBlock = null, this.save = a3, this.setDragListener(), this.setDropListener();
        }, r2 = [{ key: "isReadOnlySupported", get: function() {
          return true;
        } }], (t3 = [{ key: "setElementCursor", value: function(e4) {
          if (e4) {
            var t4 = document.createRange(), r3 = window.getSelection();
            t4.setStart(e4.childNodes[0], 0), t4.collapse(true), r3.removeAllRanges(), r3.addRange(t4), e4.focus();
          }
        } }, { key: "setDragListener", value: function() {
          var e4 = this;
          if (!this.readOnly) {
            var t4 = this.holder.querySelector(".ce-toolbar__settings-btn");
            if (t4)
              this.initializeDragListener(t4);
            else {
              var r3 = new MutationObserver(function(t5, r4) {
                var n2 = e4.holder.querySelector(".ce-toolbar__settings-btn");
                n2 && (e4.initializeDragListener(n2), r4.disconnect());
              });
              r3.observe(this.holder, { childList: true, subtree: true });
            }
          }
        } }, { key: "initializeDragListener", value: function(e4) {
          var t4 = this;
          e4.setAttribute("draggable", "true"), e4.addEventListener("dragstart", function() {
            t4.startBlock = t4.api.getCurrentBlockIndex();
          }), e4.addEventListener("drag", function() {
            if (t4.toolbar.close(), !t4.isTheOnlyBlock()) {
              var e5 = t4.holder.querySelectorAll(".ce-block"), r3 = t4.holder.querySelector(".ce-block--drop-target");
              t4.setElementCursor(r3), t4.setBorderBlocks(e5, r3);
            }
          });
        } }, { key: "setBorderBlocks", value: function(e4, t4) {
          var r3 = this;
          Object.values(e4).forEach(function(n2) {
            var o4 = n2.querySelector(".ce-block__content");
            n2 !== t4 ? (o4.style.removeProperty("border-top"), o4.style.removeProperty("border-bottom")) : Object.keys(e4).find(function(r4) {
              return e4[r4] === t4;
            }) > r3.startBlock ? o4.style.borderBottom = r3.borderStyle : o4.style.borderTop = r3.borderStyle;
          });
        } }, { key: "setDropListener", value: function() {
          var e4 = this;
          document.addEventListener("drop", function(t4) {
            var r3 = t4.target;
            if (e4.holder.contains(r3) && e4.startBlock !== null) {
              var n2 = e4.getDropTarget(r3);
              if (n2) {
                var o4 = n2.querySelector(".ce-block__content");
                o4.style.removeProperty("border-top"), o4.style.removeProperty("border-bottom"), e4.endBlock = e4.getTargetPosition(n2), e4.moveBlocks();
              }
            }
            e4.startBlock = null;
          });
        } }, { key: "getDropTarget", value: function(e4) {
          return e4.classList.contains("ce-block") ? e4 : e4.closest(".ce-block");
        } }, { key: "getTargetPosition", value: function(e4) {
          return Array.from(e4.parentNode.children).indexOf(e4);
        } }, { key: "isTheOnlyBlock", value: function() {
          return this.api.getBlocksCount() === 1;
        } }, { key: "moveBlocks", value: function() {
          this.isTheOnlyBlock() || this.api.move(this.endBlock, this.startBlock);
        } }]) && b4(e3.prototype, t3), r2 && b4(e3, r2), Object.defineProperty(e3, "prototype", { writable: false }), e3;
        var e3, t3, r2;
      }();
    })(), n.default;
  })());
});

// node_modules/editorjs-undo/dist/bundle.js
var require_bundle2 = __commonJS((exports, module) => {
  /*! For license information please see bundle.js.LICENSE.txt */
  (function(t, e) {
    typeof exports == "object" && typeof module == "object" ? module.exports = e() : typeof define == "function" && define.amd ? define([], e) : typeof exports == "object" ? exports.Undo = e() : t.Undo = e();
  })(self, () => (() => {
    var t = { 917: function(t2, e2) {
      var n2, r2;
      n2 = function(t3) {
        var e3 = function() {
          function t4(t5, e4) {
            for (var n4 = 0;n4 < e4.length; n4++) {
              var r3 = e4[n4];
              r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t5, r3.key, r3);
            }
          }
          return function(e4, n4, r3) {
            return n4 && t4(e4.prototype, n4), r3 && t4(e4, r3), e4;
          };
        }(), n3 = function() {
          function t4(e4) {
            (function(t5, e5) {
              if (!(t5 instanceof e5))
                throw new TypeError("Cannot call a class as a function");
            })(this, t4), this.target = e4, this.isContentEditable = e4 && e4.contentEditable;
          }
          return e3(t4, [{ key: "getPos", value: function() {
            if (document.activeElement !== this.target)
              return -1;
            if (this.isContentEditable === "true") {
              this.target.focus();
              var t5 = document.getSelection().getRangeAt(0), e4 = t5.cloneRange();
              return e4.selectNodeContents(this.target), e4.setEnd(t5.endContainer, t5.endOffset), e4.toString().length;
            }
            return this.target.selectionStart;
          } }, { key: "setPos", value: function(t5) {
            if (this.isContentEditable === "true") {
              if (t5 >= 0) {
                var e4 = window.getSelection(), n4 = this.createRange(this.target, { count: t5 });
                n4 && (n4.collapse(false), e4.removeAllRanges(), e4.addRange(n4));
              }
            } else
              this.target.setSelectionRange(t5, t5);
          } }, { key: "createRange", value: function(t5, e4, n4) {
            if (n4 || ((n4 = document.createRange()).selectNode(t5), n4.setStart(t5, 0)), e4.count === 0)
              n4.setEnd(t5, e4.count);
            else if (t5 && e4.count > 0)
              if (t5.nodeType === Node.TEXT_NODE)
                t5.textContent.length < e4.count ? e4.count -= t5.textContent.length : (n4.setEnd(t5, e4.count), e4.count = 0);
              else
                for (var r3 = 0;r3 < t5.childNodes.length && (n4 = this.createRange(t5.childNodes[r3], e4, n4), e4.count !== 0); r3++)
                  ;
            return n4;
          } }]), t4;
        }();
        t3.exports = n3;
      }, (r2 = n2.apply(e2, [t2])) === undefined || (t2.exports = r2);
    }, 442: (t2, e2, n2) => {
      t2.exports = n2(917);
    }, 633: (t2, e2, n2) => {
      var r2 = n2(738).default;
      function o3() {
        t2.exports = o3 = function() {
          return n3;
        }, t2.exports.__esModule = true, t2.exports.default = t2.exports;
        var e3, n3 = {}, i = Object.prototype, a2 = i.hasOwnProperty, s = Object.defineProperty || function(t3, e4, n4) {
          t3[e4] = n4.value;
        }, c3 = typeof Symbol == "function" ? Symbol : {}, u2 = c3.iterator || "@@iterator", l2 = c3.asyncIterator || "@@asyncIterator", h4 = c3.toStringTag || "@@toStringTag";
        function f2(t3, e4, n4) {
          return Object.defineProperty(t3, e4, { value: n4, enumerable: true, configurable: true, writable: true }), t3[e4];
        }
        try {
          f2({}, "");
        } catch (e4) {
          f2 = function(t3, e5, n4) {
            return t3[e5] = n4;
          };
        }
        function d3(t3, e4, n4, r3) {
          var o4 = e4 && e4.prototype instanceof m3 ? e4 : m3, i2 = Object.create(o4.prototype), a3 = new D4(r3 || []);
          return s(i2, "_invoke", { value: T3(t3, n4, a3) }), i2;
        }
        function p2(t3, e4, n4) {
          try {
            return { type: "normal", arg: t3.call(e4, n4) };
          } catch (t4) {
            return { type: "throw", arg: t4 };
          }
        }
        n3.wrap = d3;
        var y4 = "suspendedStart", v4 = "suspendedYield", b4 = "executing", g3 = "completed", k3 = {};
        function m3() {
        }
        function x3() {
        }
        function w2() {
        }
        var O3 = {};
        f2(O3, u2, function() {
          return this;
        });
        var E4 = Object.getPrototypeOf, L4 = E4 && E4(E4(I3([])));
        L4 && L4 !== i && a2.call(L4, u2) && (O3 = L4);
        var S4 = w2.prototype = m3.prototype = Object.create(O3);
        function C3(t3) {
          ["next", "throw", "return"].forEach(function(e4) {
            f2(t3, e4, function(t4) {
              return this._invoke(e4, t4);
            });
          });
        }
        function j4(t3, e4) {
          function n4(o5, i2, s2, c4) {
            var u3 = p2(t3[o5], t3, i2);
            if (u3.type !== "throw") {
              var l3 = u3.arg, h5 = l3.value;
              return h5 && r2(h5) == "object" && a2.call(h5, "__await") ? e4.resolve(h5.__await).then(function(t4) {
                n4("next", t4, s2, c4);
              }, function(t4) {
                n4("throw", t4, s2, c4);
              }) : e4.resolve(h5).then(function(t4) {
                l3.value = t4, s2(l3);
              }, function(t4) {
                return n4("throw", t4, s2, c4);
              });
            }
            c4(u3.arg);
          }
          var o4;
          s(this, "_invoke", { value: function(t4, r3) {
            function i2() {
              return new e4(function(e5, o5) {
                n4(t4, r3, e5, o5);
              });
            }
            return o4 = o4 ? o4.then(i2, i2) : i2();
          } });
        }
        function T3(t3, n4, r3) {
          var o4 = y4;
          return function(i2, a3) {
            if (o4 === b4)
              throw Error("Generator is already running");
            if (o4 === g3) {
              if (i2 === "throw")
                throw a3;
              return { value: e3, done: true };
            }
            for (r3.method = i2, r3.arg = a3;; ) {
              var s2 = r3.delegate;
              if (s2) {
                var c4 = B3(s2, r3);
                if (c4) {
                  if (c4 === k3)
                    continue;
                  return c4;
                }
              }
              if (r3.method === "next")
                r3.sent = r3._sent = r3.arg;
              else if (r3.method === "throw") {
                if (o4 === y4)
                  throw o4 = g3, r3.arg;
                r3.dispatchException(r3.arg);
              } else
                r3.method === "return" && r3.abrupt("return", r3.arg);
              o4 = b4;
              var u3 = p2(t3, n4, r3);
              if (u3.type === "normal") {
                if (o4 = r3.done ? g3 : v4, u3.arg === k3)
                  continue;
                return { value: u3.arg, done: r3.done };
              }
              u3.type === "throw" && (o4 = g3, r3.method = "throw", r3.arg = u3.arg);
            }
          };
        }
        function B3(t3, n4) {
          var r3 = n4.method, o4 = t3.iterator[r3];
          if (o4 === e3)
            return n4.delegate = null, r3 === "throw" && t3.iterator.return && (n4.method = "return", n4.arg = e3, B3(t3, n4), n4.method === "throw") || r3 !== "return" && (n4.method = "throw", n4.arg = new TypeError("The iterator does not provide a '" + r3 + "' method")), k3;
          var i2 = p2(o4, t3.iterator, n4.arg);
          if (i2.type === "throw")
            return n4.method = "throw", n4.arg = i2.arg, n4.delegate = null, k3;
          var a3 = i2.arg;
          return a3 ? a3.done ? (n4[t3.resultName] = a3.value, n4.next = t3.nextLoc, n4.method !== "return" && (n4.method = "next", n4.arg = e3), n4.delegate = null, k3) : a3 : (n4.method = "throw", n4.arg = new TypeError("iterator result is not an object"), n4.delegate = null, k3);
        }
        function _3(t3) {
          var e4 = { tryLoc: t3[0] };
          1 in t3 && (e4.catchLoc = t3[1]), 2 in t3 && (e4.finallyLoc = t3[2], e4.afterLoc = t3[3]), this.tryEntries.push(e4);
        }
        function P4(t3) {
          var e4 = t3.completion || {};
          e4.type = "normal", delete e4.arg, t3.completion = e4;
        }
        function D4(t3) {
          this.tryEntries = [{ tryLoc: "root" }], t3.forEach(_3, this), this.reset(true);
        }
        function I3(t3) {
          if (t3 || t3 === "") {
            var n4 = t3[u2];
            if (n4)
              return n4.call(t3);
            if (typeof t3.next == "function")
              return t3;
            if (!isNaN(t3.length)) {
              var o4 = -1, i2 = function n() {
                for (;++o4 < t3.length; )
                  if (a2.call(t3, o4))
                    return n.value = t3[o4], n.done = false, n;
                return n.value = e3, n.done = true, n;
              };
              return i2.next = i2;
            }
          }
          throw new TypeError(r2(t3) + " is not iterable");
        }
        return x3.prototype = w2, s(S4, "constructor", { value: w2, configurable: true }), s(w2, "constructor", { value: x3, configurable: true }), x3.displayName = f2(w2, h4, "GeneratorFunction"), n3.isGeneratorFunction = function(t3) {
          var e4 = typeof t3 == "function" && t3.constructor;
          return !!e4 && (e4 === x3 || (e4.displayName || e4.name) === "GeneratorFunction");
        }, n3.mark = function(t3) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t3, w2) : (t3.__proto__ = w2, f2(t3, h4, "GeneratorFunction")), t3.prototype = Object.create(S4), t3;
        }, n3.awrap = function(t3) {
          return { __await: t3 };
        }, C3(j4.prototype), f2(j4.prototype, l2, function() {
          return this;
        }), n3.AsyncIterator = j4, n3.async = function(t3, e4, r3, o4, i2) {
          i2 === undefined && (i2 = Promise);
          var a3 = new j4(d3(t3, e4, r3, o4), i2);
          return n3.isGeneratorFunction(e4) ? a3 : a3.next().then(function(t4) {
            return t4.done ? t4.value : a3.next();
          });
        }, C3(S4), f2(S4, h4, "Generator"), f2(S4, u2, function() {
          return this;
        }), f2(S4, "toString", function() {
          return "[object Generator]";
        }), n3.keys = function(t3) {
          var e4 = Object(t3), n4 = [];
          for (var r3 in e4)
            n4.push(r3);
          return n4.reverse(), function t() {
            for (;n4.length; ) {
              var r4 = n4.pop();
              if (r4 in e4)
                return t.value = r4, t.done = false, t;
            }
            return t.done = true, t;
          };
        }, n3.values = I3, D4.prototype = { constructor: D4, reset: function(t3) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(P4), !t3)
            for (var n4 in this)
              n4.charAt(0) === "t" && a2.call(this, n4) && !isNaN(+n4.slice(1)) && (this[n4] = e3);
        }, stop: function() {
          this.done = true;
          var t3 = this.tryEntries[0].completion;
          if (t3.type === "throw")
            throw t3.arg;
          return this.rval;
        }, dispatchException: function(t3) {
          if (this.done)
            throw t3;
          var n4 = this;
          function r3(r4, o5) {
            return s2.type = "throw", s2.arg = t3, n4.next = r4, o5 && (n4.method = "next", n4.arg = e3), !!o5;
          }
          for (var o4 = this.tryEntries.length - 1;o4 >= 0; --o4) {
            var i2 = this.tryEntries[o4], s2 = i2.completion;
            if (i2.tryLoc === "root")
              return r3("end");
            if (i2.tryLoc <= this.prev) {
              var c4 = a2.call(i2, "catchLoc"), u3 = a2.call(i2, "finallyLoc");
              if (c4 && u3) {
                if (this.prev < i2.catchLoc)
                  return r3(i2.catchLoc, true);
                if (this.prev < i2.finallyLoc)
                  return r3(i2.finallyLoc);
              } else if (c4) {
                if (this.prev < i2.catchLoc)
                  return r3(i2.catchLoc, true);
              } else {
                if (!u3)
                  throw Error("try statement without catch or finally");
                if (this.prev < i2.finallyLoc)
                  return r3(i2.finallyLoc);
              }
            }
          }
        }, abrupt: function(t3, e4) {
          for (var n4 = this.tryEntries.length - 1;n4 >= 0; --n4) {
            var r3 = this.tryEntries[n4];
            if (r3.tryLoc <= this.prev && a2.call(r3, "finallyLoc") && this.prev < r3.finallyLoc) {
              var o4 = r3;
              break;
            }
          }
          o4 && (t3 === "break" || t3 === "continue") && o4.tryLoc <= e4 && e4 <= o4.finallyLoc && (o4 = null);
          var i2 = o4 ? o4.completion : {};
          return i2.type = t3, i2.arg = e4, o4 ? (this.method = "next", this.next = o4.finallyLoc, k3) : this.complete(i2);
        }, complete: function(t3, e4) {
          if (t3.type === "throw")
            throw t3.arg;
          return t3.type === "break" || t3.type === "continue" ? this.next = t3.arg : t3.type === "return" ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : t3.type === "normal" && e4 && (this.next = e4), k3;
        }, finish: function(t3) {
          for (var e4 = this.tryEntries.length - 1;e4 >= 0; --e4) {
            var n4 = this.tryEntries[e4];
            if (n4.finallyLoc === t3)
              return this.complete(n4.completion, n4.afterLoc), P4(n4), k3;
          }
        }, catch: function(t3) {
          for (var e4 = this.tryEntries.length - 1;e4 >= 0; --e4) {
            var n4 = this.tryEntries[e4];
            if (n4.tryLoc === t3) {
              var r3 = n4.completion;
              if (r3.type === "throw") {
                var o4 = r3.arg;
                P4(n4);
              }
              return o4;
            }
          }
          throw Error("illegal catch attempt");
        }, delegateYield: function(t3, n4, r3) {
          return this.delegate = { iterator: I3(t3), resultName: n4, nextLoc: r3 }, this.method === "next" && (this.arg = e3), k3;
        } }, n3;
      }
      t2.exports = o3, t2.exports.__esModule = true, t2.exports.default = t2.exports;
    }, 738: (t2) => {
      function e2(n2) {
        return t2.exports = e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, t2.exports.__esModule = true, t2.exports.default = t2.exports, e2(n2);
      }
      t2.exports = e2, t2.exports.__esModule = true, t2.exports.default = t2.exports;
    }, 756: (t2, e2, n2) => {
      var r2 = n2(633)();
      t2.exports = r2;
      try {
        regeneratorRuntime = r2;
      } catch (t3) {
        typeof globalThis == "object" ? globalThis.regeneratorRuntime = r2 : Function("r", "regeneratorRuntime = r")(r2);
      }
    } }, e = {};
    function n(r2) {
      var o3 = e[r2];
      if (o3 !== undefined)
        return o3.exports;
      var i = e[r2] = { exports: {} };
      return t[r2].call(i.exports, i, i.exports, n), i.exports;
    }
    n.n = (t2) => {
      var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
      return n.d(e2, { a: e2 }), e2;
    }, n.d = (t2, e2) => {
      for (var r2 in e2)
        n.o(e2, r2) && !n.o(t2, r2) && Object.defineProperty(t2, r2, { enumerable: true, get: e2[r2] });
    }, n.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2);
    var r = {};
    return (() => {
      function t2(t3, e3, n2, r2, o4, i2, a3) {
        try {
          var s2 = t3[i2](a3), c4 = s2.value;
        } catch (t4) {
          return void n2(t4);
        }
        s2.done ? e3(c4) : Promise.resolve(c4).then(r2, o4);
      }
      function e2(e3) {
        return function() {
          var n2 = this, r2 = arguments;
          return new Promise(function(o4, i2) {
            var a3 = e3.apply(n2, r2);
            function s2(e4) {
              t2(a3, o4, i2, s2, c4, "next", e4);
            }
            function c4(e4) {
              t2(a3, o4, i2, s2, c4, "throw", e4);
            }
            s2(undefined);
          });
        };
      }
      function o3(t3) {
        return o3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, o3(t3);
      }
      function i(t3) {
        var e3 = function(t4, e4) {
          if (o3(t4) != "object" || !t4)
            return t4;
          var n2 = t4[Symbol.toPrimitive];
          if (n2 !== undefined) {
            var r2 = n2.call(t4, "string");
            if (o3(r2) != "object")
              return r2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t4);
        }(t3);
        return o3(e3) == "symbol" ? e3 : e3 + "";
      }
      function a2(t3, e3) {
        if (!(t3 instanceof e3))
          throw new TypeError("Cannot call a class as a function");
      }
      function s(t3, e3) {
        for (var n2 = 0;n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t3, i(r2.key), r2);
        }
      }
      function c3(t3, e3, n2) {
        return e3 && s(t3.prototype, e3), n2 && s(t3, n2), Object.defineProperty(t3, "prototype", { writable: false }), t3;
      }
      n.d(r, { default: () => v4 });
      var u2 = n(756), l2 = n.n(u2), h4 = n(442), f2 = n.n(h4), d3 = function() {
        return c3(function t(e3, n2, r2) {
          a2(this, t), this.holder = n2, this.observer = null, this.debounceTimer = r2, this.mutationDebouncer = this.debounce(function() {
            e3();
          }, this.debounceTimer);
        }, [{ key: "setMutationObserver", value: function() {
          var t3 = this, e3 = this.holder.querySelector(".codex-editor__redactor");
          this.observer = new MutationObserver(function(e4) {
            t3.mutationHandler(e4);
          }), this.observer.observe(e3, { childList: true, attributes: true, subtree: true, characterData: true, characterDataOldValue: true });
        } }, { key: "mutationHandler", value: function(t3) {
          var e3 = this, n2 = false;
          t3.forEach(function(t4) {
            switch (t4.type) {
              case "childList":
                t4.target === e3.holder ? e3.onDestroy() : n2 = true;
                break;
              case "characterData":
                n2 = true;
                break;
              case "attributes":
                t4.target.classList.contains("ce-block") || t4.target.classList.contains("tc-toolbox") || (n2 = true);
            }
          }), n2 && this.mutationDebouncer();
        } }, { key: "debounce", value: function(t3, e3) {
          var n2, r2 = this;
          return function() {
            for (var o4 = arguments.length, i2 = new Array(o4), a3 = 0;a3 < o4; a3++)
              i2[a3] = arguments[a3];
            var s2 = r2;
            clearTimeout(n2), n2 = setTimeout(function() {
              return t3.apply(s2, i2);
            }, e3);
          };
        } }, { key: "onDestroy", value: function() {
          var t3 = new CustomEvent("destroy");
          document.dispatchEvent(t3), this.observer.disconnect();
        } }]);
      }();
      function p2(t3, e3) {
        var n2 = Object.keys(t3);
        if (Object.getOwnPropertySymbols) {
          var r2 = Object.getOwnPropertySymbols(t3);
          e3 && (r2 = r2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
          })), n2.push.apply(n2, r2);
        }
        return n2;
      }
      function y4(t3) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var n2 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? p2(Object(n2), true).forEach(function(e4) {
            var r2, o4, a3;
            r2 = t3, o4 = e4, a3 = n2[e4], (o4 = i(o4)) in r2 ? Object.defineProperty(r2, o4, { value: a3, enumerable: true, configurable: true, writable: true }) : r2[o4] = a3;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(n2)) : p2(Object(n2)).forEach(function(e4) {
            Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(n2, e4));
          });
        }
        return t3;
      }
      var v4 = function() {
        return c3(function t(e3) {
          var n3 = this, r3 = e3.editor, o5 = e3.config, i3 = o5 === undefined ? {} : o5, s2 = e3.onUpdate, c4 = e3.maxLength;
          a2(this, t);
          var u3 = { maxLength: 30, onUpdate: function() {
          }, config: { debounceTimer: 200, shortcuts: { undo: ["CMD+Z"], redo: ["CMD+Y", "CMD+SHIFT+Z"] } } }, l3 = r3.blocks, h5 = r3.caret, f3 = r3.configuration, p3 = f3.holder, v5 = f3.defaultBlock, b4 = u3.config.shortcuts, g3 = i3.shortcuts, k3 = y4(y4({}, b4), g3), m3 = Array.isArray(k3.undo) ? k3.undo : [k3.undo], x3 = Array.isArray(k3.redo) ? k3.redo : [k3.redo], w2 = u3.config.debounceTimer, O3 = i3.debounceTimer, E4 = O3 === undefined ? w2 : O3;
          this.holder = typeof p3 == "string" ? document.getElementById(p3) : p3, this.editor = r3, this.defaultBlock = v5, this.blocks = l3, this.caret = h5, this.shouldSaveHistory = true, this.readOnly = f3.readOnly, this.maxLength = c4 || u3.maxLength, this.onUpdate = s2 || u3.onUpdate, this.config = { debounceTimer: E4, shortcuts: { undo: m3, redo: x3 } }, new d3(function() {
            return n3.registerChange();
          }, this.holder, this.config.debounceTimer).setMutationObserver(), this.setEventListeners(), this.initialItem = null, this.clear();
        }, [{ key: "truncate", value: function(t4, e3) {
          for (;t4.length > e3; )
            t4.shift();
        } }, { key: "initialize", value: function(t4) {
          var e3 = "blocks" in t4 ? t4.blocks : t4, n3 = { index: e3.length - 1, state: e3 };
          this.stack[0] = n3, this.initialItem = n3;
        } }, { key: "clear", value: function() {
          this.stack = this.initialItem ? [this.initialItem] : [{ index: 0, state: [{ type: this.defaultBlock, data: {} }] }], this.position = 0, this.onUpdate();
        } }, { key: "setReadOnly", value: function() {
          var t4 = this.holder.querySelector(".ce-toolbox");
          this.readOnly = !t4;
        } }, { key: "registerChange", value: function() {
          var t4 = this;
          this.setReadOnly(), this.readOnly || (this.editor && this.editor.save && this.shouldSaveHistory && this.editor.save().then(function(e3) {
            t4.editorDidUpdate(e3.blocks) && t4.save(e3.blocks);
          }), this.shouldSaveHistory = true);
        } }, { key: "editorDidUpdate", value: function(t4) {
          var e3 = this.stack[this.position].state;
          return !!t4.length && (t4.length !== e3.length || JSON.stringify(e3) !== JSON.stringify(t4));
        } }, { key: "save", value: function(t4) {
          this.position >= this.maxLength && this.truncate(this.stack, this.maxLength), this.position = Math.min(this.position, this.stack.length - 1), this.stack = this.stack.slice(0, this.position + 1);
          var e3 = this.blocks.getCurrentBlockIndex(), n3 = this.blocks.getBlocksCount(), r3 = e3;
          t4[e3] || (r3 -= n3 - t4.length);
          var o5 = !t4[r3] || t4[r3].type !== "paragraph" && t4[r3].type !== "header" ? null : this.getCaretIndex(e3);
          this.stack.push({ index: r3, state: t4, caretIndex: o5 }), this.position += 1, this.onUpdate();
        } }, { key: "getCaretIndex", value: function(t4) {
          var e3 = this.holder.getElementsByClassName("ce-block__content");
          return new (f2())(e3[t4].firstChild).getPos();
        } }, { key: "insertDeletedBlock", value: function(t4, e3, n3) {
          for (var r3 = 0;r3 < t4.length; r3 += 1)
            if (!e3[r3] || t4[r3].id !== e3[r3].id) {
              this.blocks.insert(t4[r3].type, t4[r3].data, {}, r3, true), this.caret.setToBlock(n3, "end");
              break;
            }
        } }, { key: "blockWasDropped", value: function(t4, e3) {
          return t4.length === e3.length && t4.some(function(t5, n3) {
            return t5.id !== e3[n3].id;
          });
        } }, { key: "blockWasSkipped", value: function(t4, e3) {
          return t4.length !== e3.length;
        } }, { key: "contentChangedInNoFocusBlock", value: function(t4, e3) {
          return t4 !== e3;
        } }, { key: "blockWasDeleted", value: function(t4, e3) {
          return t4.length > e3.length;
        } }, { key: "contentWasCopied", value: function(t4, e3, n3) {
          return Object.keys(t4[n3].data).length === 0 && JSON.stringify(e3[n3 + 1]) !== JSON.stringify(t4[n3 + 1]);
        } }, { key: "undo", value: (i2 = e2(l2().mark(function t() {
          var e3, n3, r3, o5, i3, a3, s2, c4, u3, h5, f3;
          return l2().wrap(function(t4) {
            for (;; )
              switch (t4.prev = t4.next) {
                case 0:
                  if (!this.canUndo()) {
                    t4.next = 47;
                    break;
                  }
                  if (e3 = this.stack[this.position], n3 = e3.index, r3 = e3.state, this.position -= 1, this.shouldSaveHistory = false, o5 = this.stack[this.position].index, i3 = this.stack[this.position], a3 = i3.state, s2 = i3.caretIndex, this.onUpdate(), c4 = this.blocks.getBlocksCount(), a3[o5] || (o5 -= 1, this.stack[this.position].index = o5), !this.blockWasDeleted(a3, r3)) {
                    t4.next = 13;
                    break;
                  }
                  this.insertDeletedBlock(a3, r3, o5), t4.next = 42;
                  break;
                case 13:
                  if (!this.contentWasCopied(a3, r3, o5)) {
                    t4.next = 19;
                    break;
                  }
                  return t4.next = 16, this.blocks.render({ blocks: a3 });
                case 16:
                  this.caret.setToBlock(o5, "end"), t4.next = 42;
                  break;
                case 19:
                  if (!(o5 < n3 && this.blockWasSkipped(a3, r3))) {
                    t4.next = 25;
                    break;
                  }
                  return t4.next = 22, this.blocks.delete(n3);
                case 22:
                  this.caret.setToBlock(o5, "end"), t4.next = 42;
                  break;
                case 25:
                  if (!(c4 > a3.length)) {
                    t4.next = 31;
                    break;
                  }
                  return t4.next = 28, this.blocks.render({ blocks: a3 });
                case 28:
                  this.setCaretIndex(o5, s2), t4.next = 42;
                  break;
                case 31:
                  if (!this.blockWasDropped(a3, r3)) {
                    t4.next = 37;
                    break;
                  }
                  return t4.next = 34, this.blocks.render({ blocks: a3 });
                case 34:
                  this.caret.setToBlock(o5, "end"), t4.next = 42;
                  break;
                case 37:
                  if (!this.contentChangedInNoFocusBlock(o5, n3)) {
                    t4.next = 42;
                    break;
                  }
                  return u3 = this.blocks.getBlockByIndex(n3), h5 = u3.id, t4.next = 41, this.blocks.update(h5, a3[n3].data);
                case 41:
                  this.setCaretIndex(o5, s2);
                case 42:
                  if (!(f3 = this.blocks.getBlockByIndex(o5))) {
                    t4.next = 47;
                    break;
                  }
                  return t4.next = 46, this.blocks.update(f3.id, a3[o5].data);
                case 46:
                  this.setCaretIndex(o5, s2);
                case 47:
                case "end":
                  return t4.stop();
              }
          }, t, this);
        })), function() {
          return i2.apply(this, arguments);
        }) }, { key: "setCaretIndex", value: function(t4, e3) {
          if (e3 && e3 !== -1) {
            var n3 = this.holder.getElementsByClassName("ce-block__content"), r3 = new (f2())(n3[t4].firstChild);
            setTimeout(function() {
              return r3.setPos(e3);
            }, 50);
          } else
            this.caret.setToBlock(t4, "end");
        } }, { key: "insertBlock", value: (o4 = e2(l2().mark(function t(e3, n3) {
          return l2().wrap(function(t4) {
            for (;; )
              switch (t4.prev = t4.next) {
                case 0:
                  return t4.next = 2, this.blocks.insert(e3[n3].type, e3[n3].data, {}, n3, true);
                case 2:
                case "end":
                  return t4.stop();
              }
          }, t, this);
        })), function(t4, e3) {
          return o4.apply(this, arguments);
        }) }, { key: "insertSkippedBlocks", value: (r2 = e2(l2().mark(function t(e3, n3, r3) {
          var o5;
          return l2().wrap(function(t4) {
            for (;; )
              switch (t4.prev = t4.next) {
                case 0:
                  for (o5 = e3.length;o5 < n3.length; o5 += 1)
                    this.insertBlock(n3, o5);
                  if (JSON.stringify(e3[r3 - 1]) === JSON.stringify(n3[r3 - 1])) {
                    t4.next = 4;
                    break;
                  }
                  return t4.next = 4, this.updateModifiedBlock(n3, r3);
                case 4:
                case "end":
                  return t4.stop();
              }
          }, t, this);
        })), function(t4, e3, n3) {
          return r2.apply(this, arguments);
        }) }, { key: "updateModifiedBlock", value: (n2 = e2(l2().mark(function t(e3, n3) {
          var r3;
          return l2().wrap(function(t4) {
            for (;; )
              switch (t4.prev = t4.next) {
                case 0:
                  if (r3 = e3[n3 - 1], !this.editor.blocks.getById(r3.id)) {
                    t4.next = 3;
                    break;
                  }
                  return t4.abrupt("return", this.blocks.update(r3.id, r3.data));
                case 3:
                  return t4.abrupt("return", this.blocks.render({ blocks: e3 }));
                case 4:
                case "end":
                  return t4.stop();
              }
          }, t, this);
        })), function(t4, e3) {
          return n2.apply(this, arguments);
        }) }, { key: "redo", value: (t3 = e2(l2().mark(function t() {
          var e3, n3, r3, o5, i3, a3, s2;
          return l2().wrap(function(t4) {
            for (;; )
              switch (t4.prev = t4.next) {
                case 0:
                  if (!this.canRedo()) {
                    t4.next = 27;
                    break;
                  }
                  if (this.position += 1, this.shouldSaveHistory = false, e3 = this.stack[this.position], n3 = e3.index, r3 = e3.state, o5 = e3.caretIndex, (i3 = this.stack[this.position - 1]).index, a3 = i3.state, !this.blockWasDeleted(a3, r3)) {
                    t4.next = 11;
                    break;
                  }
                  return t4.next = 8, this.blocks.delete();
                case 8:
                  this.caret.setToBlock(n3, "end"), t4.next = 21;
                  break;
                case 11:
                  if (!this.blockWasSkipped(r3, a3)) {
                    t4.next = 17;
                    break;
                  }
                  return t4.next = 14, this.insertSkippedBlocks(a3, r3, n3);
                case 14:
                  this.caret.setToBlock(n3, "end"), t4.next = 21;
                  break;
                case 17:
                  if (!this.blockWasDropped(r3, a3) || this.position === 1) {
                    t4.next = 21;
                    break;
                  }
                  return t4.next = 20, this.blocks.render({ blocks: r3 });
                case 20:
                  this.caret.setToBlock(n3, "end");
                case 21:
                  if (this.onUpdate(), !(s2 = this.blocks.getBlockByIndex(n3))) {
                    t4.next = 27;
                    break;
                  }
                  return t4.next = 26, this.blocks.update(s2.id, r3[n3].data);
                case 26:
                  this.setCaretIndex(n3, o5);
                case 27:
                case "end":
                  return t4.stop();
              }
          }, t, this);
        })), function() {
          return t3.apply(this, arguments);
        }) }, { key: "canUndo", value: function() {
          return !this.readOnly && this.position > 0;
        } }, { key: "canRedo", value: function() {
          return !this.readOnly && this.position < this.count();
        } }, { key: "count", value: function() {
          return this.stack.length - 1;
        } }, { key: "parseKeys", value: function(t4) {
          var e3 = { CMD: /(Mac)/i.test(navigator.platform) ? "metaKey" : "ctrlKey", ALT: "altKey", SHIFT: "shiftKey" }, n3 = t4.slice(0, -1).map(function(t5) {
            return e3[t5];
          }), r3 = n3.includes("shiftKey") && t4.length === 2 ? t4[t4.length - 1].toUpperCase() : t4[t4.length - 1].toLowerCase();
          return n3.push(r3), n3;
        } }, { key: "setEventListeners", value: function() {
          var t4 = this, e3 = this.holder, n3 = this.config.shortcuts, r3 = n3.undo, o5 = n3.redo, i3 = r3.map(function(t5) {
            return t5.replace(/ /g, "").split("+");
          }), a3 = o5.map(function(t5) {
            return t5.replace(/ /g, "").split("+");
          }), s2 = i3.map(function(e4) {
            return t4.parseKeys(e4);
          }), c4 = a3.map(function(e4) {
            return t4.parseKeys(e4);
          }), u3 = function(t5, e4) {
            return e4.reduce(function(e5, n4) {
              return e5 || function(t6, e6) {
                return e6.length === 3 && t6[e6[0]] && t6[e6[1]] && t6.key.toLowerCase() === e6[2];
              }(t5, n4);
            }, false);
          }, l3 = function(t5, e4, n4) {
            return !(!function(t6, e5) {
              return e5.reduce(function(e6, n5) {
                return e6 || function(t7, e7) {
                  return e7.length === 2 && t7[e7[0]] && t7.key.toLowerCase() === e7[1];
                }(t6, n5);
              }, false);
            }(t5, e4) || u3(t5, n4)) || !!u3(t5, e4);
          }, h5 = function(e4) {
            l3(e4, s2, c4) && (e4.preventDefault(), t4.undo());
          }, f3 = function(e4) {
            l3(e4, c4, s2) && (e4.preventDefault(), t4.redo());
          };
          e3.addEventListener("keydown", h5), e3.addEventListener("keydown", f3), e3.addEventListener("destroy", function() {
            e3.removeEventListener("keydown", h5), e3.removeEventListener("keydown", f3);
          });
        } }], [{ key: "isReadOnlySupported", get: function() {
          return true;
        } }]);
        var t3, n2, r2, o4, i2;
      }();
    })(), r.default;
  })());
});

// node_modules/editorjs-paragraph-with-alignment/dist/bundle.js
var require_bundle3 = __commonJS((exports, module) => {
  (function(t, e) {
    typeof exports == "object" && typeof module == "object" ? module.exports = e() : typeof define == "function" && define.amd ? define([], e) : typeof exports == "object" ? exports.Paragraph = e() : t.Paragraph = e();
  })(window, function() {
    return function(t) {
      var e = {};
      function n(a3) {
        if (e[a3])
          return e[a3].exports;
        var i = e[a3] = { i: a3, l: false, exports: {} };
        return t[a3].call(i.exports, i, i.exports, n), i.l = true, i.exports;
      }
      return n.m = t, n.c = e, n.d = function(t2, e2, a3) {
        n.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: a3 });
      }, n.r = function(t2) {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      }, n.t = function(t2, e2) {
        if (1 & e2 && (t2 = n(t2)), 8 & e2)
          return t2;
        if (4 & e2 && typeof t2 == "object" && t2 && t2.__esModule)
          return t2;
        var a3 = Object.create(null);
        if (n.r(a3), Object.defineProperty(a3, "default", { enumerable: true, value: t2 }), 2 & e2 && typeof t2 != "string")
          for (var i in t2)
            n.d(a3, i, function(e3) {
              return t2[e3];
            }.bind(null, i));
        return a3;
      }, n.n = function(t2) {
        var e2 = t2 && t2.__esModule ? function() {
          return t2.default;
        } : function() {
          return t2;
        };
        return n.d(e2, "a", e2), e2;
      }, n.o = function(t2, e2) {
        return Object.prototype.hasOwnProperty.call(t2, e2);
      }, n.p = "/", n(n.s = 0);
    }([function(t, e, n) {
      function a3(t2, e2) {
        for (var n2 = 0;n2 < e2.length; n2++) {
          var a4 = e2[n2];
          a4.enumerable = a4.enumerable || false, a4.configurable = true, "value" in a4 && (a4.writable = true), Object.defineProperty(t2, a4.key, a4);
        }
      }
      function i(t2, e2, n2) {
        return e2 && a3(t2.prototype, e2), n2 && a3(t2, n2), t2;
      }
      n(1).toString();
      var r = function() {
        function t2(e2) {
          var { data: n2, config: a4, api: i2, readOnly: r2 } = e2;
          (function(t3, e3) {
            if (!(t3 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          })(this, t2), this.api = i2, this.config = a4, this.readOnly = r2, this._CSS = { block: this.api.styles.block, wrapper: "ce-paragraph", alignment: { left: "ce-paragraph--left", center: "ce-paragraph--center", right: "ce-paragraph--right", justify: "ce-paragraph--justify" } }, this.CSS = { baseClass: this.api.styles.block, loading: this.api.styles.loader, input: this.api.styles.input, settingsButton: this.api.styles.settingsButton, settingsButtonActive: this.api.styles.settingsButtonActive }, this.settings = [{ name: "left", icon: '<svg xmlns="http://www.w3.org/2000/svg" id="Layer" enable-background="new 0 0 64 64" height="20" viewBox="0 0 64 64" width="20"><path d="m54 8h-44c-1.104 0-2 .896-2 2s.896 2 2 2h44c1.104 0 2-.896 2-2s-.896-2-2-2z"/><path d="m54 52h-44c-1.104 0-2 .896-2 2s.896 2 2 2h44c1.104 0 2-.896 2-2s-.896-2-2-2z"/><path d="m10 23h28c1.104 0 2-.896 2-2s-.896-2-2-2h-28c-1.104 0-2 .896-2 2s.896 2 2 2z"/><path d="m54 30h-44c-1.104 0-2 .896-2 2s.896 2 2 2h44c1.104 0 2-.896 2-2s-.896-2-2-2z"/><path d="m10 45h28c1.104 0 2-.896 2-2s-.896-2-2-2h-28c-1.104 0-2 .896-2 2s.896 2 2 2z"/></svg>' }, { name: "center", icon: '<svg xmlns="http://www.w3.org/2000/svg" id="Layer" enable-background="new 0 0 64 64" height="20" viewBox="0 0 64 64" width="20"><path d="m54 8h-44c-1.104 0-2 .896-2 2s.896 2 2 2h44c1.104 0 2-.896 2-2s-.896-2-2-2z"/><path d="m54 52h-44c-1.104 0-2 .896-2 2s.896 2 2 2h44c1.104 0 2-.896 2-2s-.896-2-2-2z"/><path d="m46 23c1.104 0 2-.896 2-2s-.896-2-2-2h-28c-1.104 0-2 .896-2 2s.896 2 2 2z"/><path d="m54 30h-44c-1.104 0-2 .896-2 2s.896 2 2 2h44c1.104 0 2-.896 2-2s-.896-2-2-2z"/><path d="m46 45c1.104 0 2-.896 2-2s-.896-2-2-2h-28c-1.104 0-2 .896-2 2s.896 2 2 2z"/></svg>' }, { name: "right", icon: '<svg xmlns="http://www.w3.org/2000/svg" id="Layer" enable-background="new 0 0 64 64" height="20" viewBox="0 0 64 64" width="20"><path d="m54 8h-44c-1.104 0-2 .896-2 2s.896 2 2 2h44c1.104 0 2-.896 2-2s-.896-2-2-2z"/><path d="m54 52h-44c-1.104 0-2 .896-2 2s.896 2 2 2h44c1.104 0 2-.896 2-2s-.896-2-2-2z"/><path d="m54 19h-28c-1.104 0-2 .896-2 2s.896 2 2 2h28c1.104 0 2-.896 2-2s-.896-2-2-2z"/><path d="m54 30h-44c-1.104 0-2 .896-2 2s.896 2 2 2h44c1.104 0 2-.896 2-2s-.896-2-2-2z"/><path d="m54 41h-28c-1.104 0-2 .896-2 2s.896 2 2 2h28c1.104 0 2-.896 2-2s-.896-2-2-2z"/></svg>' }, { name: "justify", icon: '<svg viewBox="0 0 64 64" width="20" height="20"><path d="m54 8h-44c-1.104 0-2 .896-2 2s.896 2 2 2h44c1.104 0 2-.896 2-2s-.896-2-2-2z"></path><path d="m54 52h-44c-1.104 0-2 .896-2 2s.896 2 2 2h44c1.104 0 2-.896 2-2s-.896-2-2-2z"></path><path d="M 52.867 19 L 10.914 19 C 9.26 19 7.918 19.896 7.918 21 C 7.918 22.104 9.26 23 10.914 23 L 52.867 23 C 54.522 23 55.863 22.104 55.863 21 C 55.863 19.896 54.522 19 52.867 19 Z" style=""></path><path d="m54 30h-44c-1.104 0-2 .896-2 2s.896 2 2 2h44c1.104 0 2-.896 2-2s-.896-2-2-2z"></path><path d="M 52.779 41 L 11.113 41 C 9.469 41 8.136 41.896 8.136 43 C 8.136 44.104 9.469 45 11.113 45 L 52.779 45 C 54.421 45 55.754 44.104 55.754 43 C 55.754 41.896 54.421 41 52.779 41 Z" style=""></path></svg>' }], this.onKeyUp = this.onKeyUp.bind(this), this._placeholder = a4.placeholder ? a4.placeholder : t2.DEFAULT_PLACEHOLDER, this._data = { text: n2.text || "", alignment: n2.alignment || a4.defaultAlignment || t2.DEFAULT_ALIGNMENT }, this._element = this.drawView(), this.data = n2, this._preserveBlank = a4.preserveBlank !== undefined && a4.preserveBlank;
        }
        return i(t2, null, [{ key: "DEFAULT_PLACEHOLDER", get: function() {
          return "";
        } }, { key: "ALIGNMENTS", get: function() {
          return { left: "left", center: "center", right: "right", justify: "justify" };
        } }, { key: "isReadOnlySupported", get: function() {
          return true;
        } }, { key: "DEFAULT_ALIGNMENT", get: function() {
          return t2.ALIGNMENTS.left;
        } }]), i(t2, [{ key: "onKeyUp", value: function(t3) {
          t3.code !== "Backspace" && t3.code !== "Delete" || this._element.textContent === "" && (this._element.innerHTML = "");
        } }, { key: "drawView", value: function() {
          var t3 = document.createElement("DIV");
          return t3.classList.add(this._CSS.wrapper, this._CSS.block, this._CSS.alignment[this.data.alignment]), t3.contentEditable = !this.readOnly, t3.dataset.placeholder = this.api.i18n.t(this._placeholder), t3.innerHTML = this.data.text, t3.addEventListener("keyup", this.onKeyUp), t3;
        } }, { key: "render", value: function() {
          return this._element;
        } }, { key: "merge", value: function(t3) {
          var e2 = { text: this.data.text += t3.text, alignment: this.data.alignment };
          this._element.innerHTML = this.data.text, this.data = e2;
        } }, { key: "validate", value: function(t3) {
          return !(t3.text.trim() === "" && !this._preserveBlank);
        } }, { key: "save", value: function(t3) {
          return Object.assign(this.data, { text: t3.innerHTML });
        } }, { key: "onPaste", value: function(e2) {
          var n2 = { text: e2.detail.data.innerHTML, alignment: this.config.defaultAlignment || t2.DEFAULT_ALIGNMENT };
          this.data = n2;
        } }, { key: "renderSettings", value: function() {
          var t3 = this, e2 = document.createElement("div");
          return this.settings.map(function(n2) {
            var a4 = document.createElement("div");
            return a4.classList.add("cdx-settings-button"), a4.innerHTML = n2.icon, a4.classList.toggle(t3.CSS.settingsButtonActive, n2.name === t3.data.alignment), e2.appendChild(a4), a4;
          }).forEach(function(e3, n2, a4) {
            e3.addEventListener("click", function() {
              t3._toggleTune(t3.settings[n2].name), a4.forEach(function(e4, n3) {
                var a5 = t3.settings[n3].name;
                e4.classList.toggle(t3.CSS.settingsButtonActive, a5 === t3.data.alignment), t3._element.classList.toggle(t3._CSS.alignment[a5], a5 === t3.data.alignment);
              });
            });
          }), e2;
        } }, { key: "_toggleTune", value: function(t3) {
          this.data.alignment = t3;
        } }, { key: "data", get: function() {
          return this._data;
        }, set: function(e2) {
          this._data = { text: e2.text || "", alignment: e2.alignment || this.config.defaultAlignment || t2.DEFAULT_ALIGNMENT }, this._element.innerHTML = this._data.text || "";
        } }], [{ key: "conversionConfig", get: function() {
          return { export: "text", import: "text" };
        } }, { key: "sanitize", get: function() {
          return { text: { br: true }, alignment: {} };
        } }, { key: "pasteConfig", get: function() {
          return { tags: ["P"] };
        } }, { key: "toolbox", get: function() {
          return { icon: n(5).default, title: "Text" };
        } }]), t2;
      }();
      t.exports = r;
    }, function(t, e, n) {
      var a3 = n(2), i = n(3);
      typeof (i = i.__esModule ? i.default : i) == "string" && (i = [[t.i, i, ""]]);
      var r = { insert: "head", singleton: false };
      a3(i, r);
      t.exports = i.locals || {};
    }, function(t, e, n) {
      var a3, i = function() {
        return a3 === undefined && (a3 = Boolean(window && document && document.all && !window.atob)), a3;
      }, r = function() {
        var t2 = {};
        return function(e2) {
          if (t2[e2] === undefined) {
            var n2 = document.querySelector(e2);
            if (window.HTMLIFrameElement && n2 instanceof window.HTMLIFrameElement)
              try {
                n2 = n2.contentDocument.head;
              } catch (t3) {
                n2 = null;
              }
            t2[e2] = n2;
          }
          return t2[e2];
        };
      }(), o3 = [];
      function c4(t2) {
        for (var e2 = -1, n2 = 0;n2 < o3.length; n2++)
          if (o3[n2].identifier === t2) {
            e2 = n2;
            break;
          }
        return e2;
      }
      function s2(t2, e2) {
        for (var n2 = {}, a4 = [], i2 = 0;i2 < t2.length; i2++) {
          var r2 = t2[i2], s3 = e2.base ? r2[0] + e2.base : r2[0], l3 = n2[s3] || 0, u3 = "".concat(s3, " ").concat(l3);
          n2[s3] = l3 + 1;
          var h5 = c4(u3), d4 = { css: r2[1], media: r2[2], sourceMap: r2[3] };
          h5 !== -1 ? (o3[h5].references++, o3[h5].updater(d4)) : o3.push({ identifier: u3, updater: m4(d4, e2), references: 1 }), a4.push(u3);
        }
        return a4;
      }
      function l2(t2) {
        var e2 = document.createElement("style"), a4 = t2.attributes || {};
        if (a4.nonce === undefined) {
          var i2 = n.nc;
          i2 && (a4.nonce = i2);
        }
        if (Object.keys(a4).forEach(function(t3) {
          e2.setAttribute(t3, a4[t3]);
        }), typeof t2.insert == "function")
          t2.insert(e2);
        else {
          var o4 = r(t2.insert || "head");
          if (!o4)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          o4.appendChild(e2);
        }
        return e2;
      }
      var u2, h4 = (u2 = [], function(t2, e2) {
        return u2[t2] = e2, u2.filter(Boolean).join(`
`);
      });
      function d3(t2, e2, n2, a4) {
        var i2 = n2 ? "" : a4.media ? "@media ".concat(a4.media, " {").concat(a4.css, "}") : a4.css;
        if (t2.styleSheet)
          t2.styleSheet.cssText = h4(e2, i2);
        else {
          var r2 = document.createTextNode(i2), o4 = t2.childNodes;
          o4[e2] && t2.removeChild(o4[e2]), o4.length ? t2.insertBefore(r2, o4[e2]) : t2.appendChild(r2);
        }
      }
      function p2(t2, e2, n2) {
        var { css: a4, media: i2, sourceMap: r2 } = n2;
        if (i2 ? t2.setAttribute("media", i2) : t2.removeAttribute("media"), r2 && typeof btoa != "undefined" && (a4 += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(r2)))), " */")), t2.styleSheet)
          t2.styleSheet.cssText = a4;
        else {
          for (;t2.firstChild; )
            t2.removeChild(t2.firstChild);
          t2.appendChild(document.createTextNode(a4));
        }
      }
      var f3 = null, g4 = 0;
      function m4(t2, e2) {
        var n2, a4, i2;
        if (e2.singleton) {
          var r2 = g4++;
          n2 = f3 || (f3 = l2(e2)), a4 = d3.bind(null, n2, r2, false), i2 = d3.bind(null, n2, r2, true);
        } else
          n2 = l2(e2), a4 = p2.bind(null, n2, e2), i2 = function() {
            (function(t3) {
              if (t3.parentNode === null)
                return false;
              t3.parentNode.removeChild(t3);
            })(n2);
          };
        return a4(t2), function(e3) {
          if (e3) {
            if (e3.css === t2.css && e3.media === t2.media && e3.sourceMap === t2.sourceMap)
              return;
            a4(t2 = e3);
          } else
            i2();
        };
      }
      t.exports = function(t2, e2) {
        (e2 = e2 || {}).singleton || typeof e2.singleton == "boolean" || (e2.singleton = i());
        var n2 = s2(t2 = t2 || [], e2);
        return function(t3) {
          if (t3 = t3 || [], Object.prototype.toString.call(t3) === "[object Array]") {
            for (var a4 = 0;a4 < n2.length; a4++) {
              var i2 = c4(n2[a4]);
              o3[i2].references--;
            }
            for (var r2 = s2(t3, e2), l3 = 0;l3 < n2.length; l3++) {
              var u3 = c4(n2[l3]);
              o3[u3].references === 0 && (o3[u3].updater(), o3.splice(u3, 1));
            }
            n2 = r2;
          }
        };
      };
    }, function(t, e, n) {
      (e = n(4)(false)).push([t.i, `.ce-paragraph {
    line-height: 1.6em;
    outline: none;
}
.ce-paragraph--right {
    text-align: right;
}
.ce-paragraph--center {
    text-align: center;
}
.ce-paragraph--left {
    text-align: left;
}

.ce-paragraph--justify {
    text-align: justify;
}

.ce-paragraph[data-placeholder]:empty::before{
  content: attr(data-placeholder);
  color: #707684;
  font-weight: normal;
  opacity: 0;
}

/** Show placeholder at the first paragraph if Editor is empty */
.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty::before {
  opacity: 1;
}

.codex-editor--toolbox-opened .ce-block:first-child .ce-paragraph[data-placeholder]:empty::before,
.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:focus::before {
  opacity: 0;
}

.ce-paragraph p:first-of-type{
    margin-top: 0;
}

.ce-paragraph p:last-of-type{
    margin-bottom: 0;
}


.svg-icon {
    width: 1em;
    height: 1em;
}

.svg-icon path,
.svg-icon polygon,
.svg-icon rect {
    fill: #4691f6;
}

.svg-icon circle {
    stroke: #4691f6;
    stroke-width: 1;
}`, ""]), t.exports = e;
    }, function(t, e, n) {
      t.exports = function(t2) {
        var e2 = [];
        return e2.toString = function() {
          return this.map(function(e3) {
            var n2 = function(t3, e4) {
              var n3 = t3[1] || "", a3 = t3[3];
              if (!a3)
                return n3;
              if (e4 && typeof btoa == "function") {
                var i = (o3 = a3, c4 = btoa(unescape(encodeURIComponent(JSON.stringify(o3)))), s2 = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(c4), "/*# ".concat(s2, " */")), r = a3.sources.map(function(t4) {
                  return "/*# sourceURL=".concat(a3.sourceRoot || "").concat(t4, " */");
                });
                return [n3].concat(r).concat([i]).join(`
`);
              }
              var o3, c4, s2;
              return [n3].join(`
`);
            }(e3, t2);
            return e3[2] ? "@media ".concat(e3[2], " {").concat(n2, "}") : n2;
          }).join("");
        }, e2.i = function(t3, n2, a3) {
          typeof t3 == "string" && (t3 = [[null, t3, ""]]);
          var i = {};
          if (a3)
            for (var r = 0;r < this.length; r++) {
              var o3 = this[r][0];
              o3 != null && (i[o3] = true);
            }
          for (var c4 = 0;c4 < t3.length; c4++) {
            var s2 = [].concat(t3[c4]);
            a3 && i[s2[0]] || (n2 && (s2[2] ? s2[2] = "".concat(n2, " and ").concat(s2[2]) : s2[2] = n2), e2.push(s2));
          }
        }, e2;
      };
    }, function(t, e, n) {
      n.r(e), e.default = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0.2 -0.3 9 11.4" width="12" height="14">
  <path d="M0 2.77V.92A1 1 0 01.2.28C.35.1.56 0 .83 0h7.66c.28.01.48.1.63.28.14.17.21.38.21.64v1.85c0 .26-.08.48-.23.66-.15.17-.37.26-.66.26-.28 0-.5-.09-.64-.26a1 1 0 01-.21-.66V1.69H5.6v7.58h.5c.25 0 .45.08.6.23.17.16.25.35.25.6s-.08.45-.24.6a.87.87 0 01-.62.22H3.21a.87.87 0 01-.61-.22.78.78 0 01-.24-.6c0-.25.08-.44.24-.6a.85.85 0 01.61-.23h.5V1.7H1.73v1.08c0 .26-.08.48-.23.66-.15.17-.37.26-.66.26-.28 0-.5-.09-.64-.26A1 1 0 010 2.77z"/>
</svg>
`;
    }]);
  });
});

// node_modules/katex/dist/katex.js
var require_katex = __commonJS((exports, module) => {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module === "object")
      module.exports = factory();
    else if (typeof define === "function" && define.amd)
      define([], factory);
    else if (typeof exports === "object")
      exports["katex"] = factory();
    else
      root["katex"] = factory();
  })(typeof self !== "undefined" ? self : exports, function() {
    return function() {
      var __webpack_require__ = {};
      (function() {
        __webpack_require__.d = function(exports2, definition) {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      })();
      (function() {
        __webpack_require__.o = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
      })();
      var __webpack_exports__ = {};
      __webpack_require__.d(__webpack_exports__, {
        default: function() {
          return katex_webpack;
        }
      });

      class ParseError {
        constructor(message, token) {
          this.name = undefined;
          this.position = undefined;
          this.length = undefined;
          this.rawMessage = undefined;
          let error = "KaTeX parse error: " + message;
          let start;
          let end;
          const loc = token && token.loc;
          if (loc && loc.start <= loc.end) {
            const input = loc.lexer.input;
            start = loc.start;
            end = loc.end;
            if (start === input.length) {
              error += " at end of input: ";
            } else {
              error += " at position " + (start + 1) + ": ";
            }
            const underlined = input.slice(start, end).replace(/[^]/g, "$&̲");
            let left;
            if (start > 15) {
              left = "…" + input.slice(start - 15, start);
            } else {
              left = input.slice(0, start);
            }
            let right;
            if (end + 15 < input.length) {
              right = input.slice(end, end + 15) + "…";
            } else {
              right = input.slice(end);
            }
            error += left + underlined + right;
          }
          const self2 = new Error(error);
          self2.name = "ParseError";
          self2.__proto__ = ParseError.prototype;
          self2.position = start;
          if (start != null && end != null) {
            self2.length = end - start;
          }
          self2.rawMessage = message;
          return self2;
        }
      }
      ParseError.prototype.__proto__ = Error.prototype;
      var src_ParseError = ParseError;
      const contains = function(list, elem) {
        return list.indexOf(elem) !== -1;
      };
      const deflt = function(setting, defaultIfUndefined) {
        return setting === undefined ? defaultIfUndefined : setting;
      };
      const uppercase = /([A-Z])/g;
      const hyphenate = function(str) {
        return str.replace(uppercase, "-$1").toLowerCase();
      };
      const ESCAPE_LOOKUP = {
        "&": "&amp;",
        ">": "&gt;",
        "<": "&lt;",
        '"': "&quot;",
        "'": "&#x27;"
      };
      const ESCAPE_REGEX = /[&><"']/g;
      function utils_escape(text) {
        return String(text).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
      }
      const getBaseElem = function(group) {
        if (group.type === "ordgroup") {
          if (group.body.length === 1) {
            return getBaseElem(group.body[0]);
          } else {
            return group;
          }
        } else if (group.type === "color") {
          if (group.body.length === 1) {
            return getBaseElem(group.body[0]);
          } else {
            return group;
          }
        } else if (group.type === "font") {
          return getBaseElem(group.body);
        } else {
          return group;
        }
      };
      const isCharacterBox = function(group) {
        const baseElem = getBaseElem(group);
        return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
      };
      const assert = function(value) {
        if (!value) {
          throw new Error("Expected non-null, but got " + String(value));
        }
        return value;
      };
      const protocolFromUrl = function(url) {
        const protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
        if (!protocol) {
          return "_relative";
        }
        if (protocol[2] !== ":") {
          return null;
        }
        if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
          return null;
        }
        return protocol[1].toLowerCase();
      };
      var utils = {
        contains,
        deflt,
        escape: utils_escape,
        hyphenate,
        getBaseElem,
        isCharacterBox,
        protocolFromUrl
      };
      const SETTINGS_SCHEMA = {
        displayMode: {
          type: "boolean",
          description: "Render math in display mode, which puts the math in " + "display style (so \\int and \\sum are large, for example), and " + "centers the math on the page on its own line.",
          cli: "-d, --display-mode"
        },
        output: {
          type: {
            enum: ["htmlAndMathml", "html", "mathml"]
          },
          description: "Determines the markup language of the output.",
          cli: "-F, --format <type>"
        },
        leqno: {
          type: "boolean",
          description: "Render display math in leqno style (left-justified tags)."
        },
        fleqn: {
          type: "boolean",
          description: "Render display math flush left."
        },
        throwOnError: {
          type: "boolean",
          default: true,
          cli: "-t, --no-throw-on-error",
          cliDescription: "Render errors (in the color given by --error-color) ins" + "tead of throwing a ParseError exception when encountering an error."
        },
        errorColor: {
          type: "string",
          default: "#cc0000",
          cli: "-c, --error-color <color>",
          cliDescription: "A color string given in the format 'rgb' or 'rrggbb' " + "(no #). This option determines the color of errors rendered by the " + "-t option.",
          cliProcessor: (color) => "#" + color
        },
        macros: {
          type: "object",
          cli: "-m, --macro <def>",
          cliDescription: "Define custom macro of the form '\\foo:expansion' (use " + "multiple -m arguments for multiple macros).",
          cliDefault: [],
          cliProcessor: (def, defs) => {
            defs.push(def);
            return defs;
          }
        },
        minRuleThickness: {
          type: "number",
          description: "Specifies a minimum thickness, in ems, for fraction lines," + " `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, " + "`\\hdashline`, `\\underline`, `\\overline`, and the borders of " + "`\\fbox`, `\\boxed`, and `\\fcolorbox`.",
          processor: (t) => Math.max(0, t),
          cli: "--min-rule-thickness <size>",
          cliProcessor: parseFloat
        },
        colorIsTextColor: {
          type: "boolean",
          description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, " + "instead of LaTeX's one-argument \\color mode change.",
          cli: "-b, --color-is-text-color"
        },
        strict: {
          type: [{
            enum: ["warn", "ignore", "error"]
          }, "boolean", "function"],
          description: "Turn on strict / LaTeX faithfulness mode, which throws an " + "error if the input uses features that are not supported by LaTeX.",
          cli: "-S, --strict",
          cliDefault: false
        },
        trust: {
          type: ["boolean", "function"],
          description: "Trust the input, enabling all HTML features such as \\url.",
          cli: "-T, --trust"
        },
        maxSize: {
          type: "number",
          default: Infinity,
          description: "If non-zero, all user-specified sizes, e.g. in " + "\\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, " + "elements and spaces can be arbitrarily large",
          processor: (s2) => Math.max(0, s2),
          cli: "-s, --max-size <n>",
          cliProcessor: parseInt
        },
        maxExpand: {
          type: "number",
          default: 1000,
          description: "Limit the number of macro expansions to the specified " + "number, to prevent e.g. infinite macro loops. If set to Infinity, " + "the macro expander will try to fully expand as in LaTeX.",
          processor: (n) => Math.max(0, n),
          cli: "-e, --max-expand <n>",
          cliProcessor: (n) => n === "Infinity" ? Infinity : parseInt(n)
        },
        globalGroup: {
          type: "boolean",
          cli: false
        }
      };
      function getDefaultValue(schema) {
        if (schema.default) {
          return schema.default;
        }
        const type = schema.type;
        const defaultType = Array.isArray(type) ? type[0] : type;
        if (typeof defaultType !== "string") {
          return defaultType.enum[0];
        }
        switch (defaultType) {
          case "boolean":
            return false;
          case "string":
            return "";
          case "number":
            return 0;
          case "object":
            return {};
        }
      }

      class Settings {
        constructor(options) {
          this.displayMode = undefined;
          this.output = undefined;
          this.leqno = undefined;
          this.fleqn = undefined;
          this.throwOnError = undefined;
          this.errorColor = undefined;
          this.macros = undefined;
          this.minRuleThickness = undefined;
          this.colorIsTextColor = undefined;
          this.strict = undefined;
          this.trust = undefined;
          this.maxSize = undefined;
          this.maxExpand = undefined;
          this.globalGroup = undefined;
          options = options || {};
          for (const prop in SETTINGS_SCHEMA) {
            if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
              const schema = SETTINGS_SCHEMA[prop];
              this[prop] = options[prop] !== undefined ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
            }
          }
        }
        reportNonstrict(errorCode, errorMsg, token) {
          let strict = this.strict;
          if (typeof strict === "function") {
            strict = strict(errorCode, errorMsg, token);
          }
          if (!strict || strict === "ignore") {
            return;
          } else if (strict === true || strict === "error") {
            throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
          }
        }
        useStrictBehavior(errorCode, errorMsg, token) {
          let strict = this.strict;
          if (typeof strict === "function") {
            try {
              strict = strict(errorCode, errorMsg, token);
            } catch (error) {
              strict = "error";
            }
          }
          if (!strict || strict === "ignore") {
            return false;
          } else if (strict === true || strict === "error") {
            return true;
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
            return false;
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
            return false;
          }
        }
        isTrusted(context) {
          if (context.url && !context.protocol) {
            const protocol = utils.protocolFromUrl(context.url);
            if (protocol == null) {
              return false;
            }
            context.protocol = protocol;
          }
          const trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
          return Boolean(trust);
        }
      }

      class Style {
        constructor(id, size, cramped) {
          this.id = undefined;
          this.size = undefined;
          this.cramped = undefined;
          this.id = id;
          this.size = size;
          this.cramped = cramped;
        }
        sup() {
          return styles[sup[this.id]];
        }
        sub() {
          return styles[sub[this.id]];
        }
        fracNum() {
          return styles[fracNum[this.id]];
        }
        fracDen() {
          return styles[fracDen[this.id]];
        }
        cramp() {
          return styles[cramp[this.id]];
        }
        text() {
          return styles[Style_text[this.id]];
        }
        isTight() {
          return this.size >= 2;
        }
      }
      const D4 = 0;
      const Dc = 1;
      const T4 = 2;
      const Tc = 3;
      const S5 = 4;
      const Sc = 5;
      const SS = 6;
      const SSc = 7;
      const styles = [new Style(D4, 0, false), new Style(Dc, 0, true), new Style(T4, 1, false), new Style(Tc, 1, true), new Style(S5, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
      const sup = [S5, Sc, S5, Sc, SS, SSc, SS, SSc];
      const sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
      const fracNum = [T4, Tc, S5, Sc, SS, SSc, SS, SSc];
      const fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
      const cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
      const Style_text = [D4, Dc, T4, Tc, T4, Tc, T4, Tc];
      var src_Style = {
        DISPLAY: styles[D4],
        TEXT: styles[T4],
        SCRIPT: styles[S5],
        SCRIPTSCRIPT: styles[SS]
      };
      const scriptData = [{
        name: "latin",
        blocks: [
          [256, 591],
          [768, 879]
        ]
      }, {
        name: "cyrillic",
        blocks: [[1024, 1279]]
      }, {
        name: "armenian",
        blocks: [[1328, 1423]]
      }, {
        name: "brahmic",
        blocks: [[2304, 4255]]
      }, {
        name: "georgian",
        blocks: [[4256, 4351]]
      }, {
        name: "cjk",
        blocks: [
          [12288, 12543],
          [19968, 40879],
          [65280, 65376]
        ]
      }, {
        name: "hangul",
        blocks: [[44032, 55215]]
      }];
      function scriptFromCodepoint(codepoint) {
        for (let i = 0;i < scriptData.length; i++) {
          const script = scriptData[i];
          for (let i2 = 0;i2 < script.blocks.length; i2++) {
            const block = script.blocks[i2];
            if (codepoint >= block[0] && codepoint <= block[1]) {
              return script.name;
            }
          }
        }
        return null;
      }
      const allBlocks = [];
      scriptData.forEach((s2) => s2.blocks.forEach((b5) => allBlocks.push(...b5)));
      function supportedCodepoint(codepoint) {
        for (let i = 0;i < allBlocks.length; i += 2) {
          if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
            return true;
          }
        }
        return false;
      }
      const hLinePad = 80;
      const sqrtMain = function(extraVinculum, hLinePad2) {
        return "M95," + (622 + extraVinculum + hLinePad2) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + extraVinculum / 2.075 + " -" + extraVinculum + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + extraVinculum) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
      };
      const sqrtSize1 = function(extraVinculum, hLinePad2) {
        return "M263," + (601 + extraVinculum + hLinePad2) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + extraVinculum / 2.084 + " -" + extraVinculum + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + extraVinculum) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
      };
      const sqrtSize2 = function(extraVinculum, hLinePad2) {
        return "M983 " + (10 + extraVinculum + hLinePad2) + `
l` + extraVinculum / 3.13 + " -" + extraVinculum + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + extraVinculum) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
      };
      const sqrtSize3 = function(extraVinculum, hLinePad2) {
        return "M424," + (2398 + extraVinculum + hLinePad2) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + extraVinculum / 4.223 + " -" + extraVinculum + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + extraVinculum) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + extraVinculum) + " " + hLinePad2 + `
h400000v` + (40 + extraVinculum) + "h-400000z";
      };
      const sqrtSize4 = function(extraVinculum, hLinePad2) {
        return "M473," + (2713 + extraVinculum + hLinePad2) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + extraVinculum / 5.298 + " -" + extraVinculum + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + extraVinculum) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
      };
      const phasePath = function(y5) {
        const x4 = y5 / 2;
        return "M400000 " + y5 + " H0 L" + x4 + " 0 l65 45 L145 " + (y5 - 80) + " H400000z";
      };
      const sqrtTall = function(extraVinculum, hLinePad2, viewBoxHeight) {
        const vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
        return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + `
H742v` + vertSegment + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
      };
      const sqrtPath = function(size, extraVinculum, viewBoxHeight) {
        extraVinculum = 1000 * extraVinculum;
        let path2 = "";
        switch (size) {
          case "sqrtMain":
            path2 = sqrtMain(extraVinculum, hLinePad);
            break;
          case "sqrtSize1":
            path2 = sqrtSize1(extraVinculum, hLinePad);
            break;
          case "sqrtSize2":
            path2 = sqrtSize2(extraVinculum, hLinePad);
            break;
          case "sqrtSize3":
            path2 = sqrtSize3(extraVinculum, hLinePad);
            break;
          case "sqrtSize4":
            path2 = sqrtSize4(extraVinculum, hLinePad);
            break;
          case "sqrtTall":
            path2 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
        }
        return path2;
      };
      const innerPath = function(name, height) {
        switch (name) {
          case "⎜":
            return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
          case "∣":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
          case "∥":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
          case "⎟":
            return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
          case "⎢":
            return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
          case "⎥":
            return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
          case "⎪":
            return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
          case "⏐":
            return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
          case "‖":
            return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
          default:
            return "";
        }
      };
      const path = {
        doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
        doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
        leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
        leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
        leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
        leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
        leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
        leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
        leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
        leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
        leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
        lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
        leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
        leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
        leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
        longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
        midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
        midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
        oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
        oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
        oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
        oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
        rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
        rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
        rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
        rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
        rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
        rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
        rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
        rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
        rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
        righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
        rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
        rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
        twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
        twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
        tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
        tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
        tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
        tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
        vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
        widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
        widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
        widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
        widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
        widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
        widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
        widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
        widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
        baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
        rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
        baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
        rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
        shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
        shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
      };
      const tallDelim = function(label, midHeight) {
        switch (label) {
          case "lbrack":
            return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + midHeight + " v1759 h84z";
          case "rbrack":
            return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + midHeight + " v1759 h84z";
          case "vert":
            return "M145 15 v585 v" + midHeight + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -midHeight + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + midHeight + " v585 h43z";
          case "doublevert":
            return "M145 15 v585 v" + midHeight + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -midHeight + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + midHeight + ` v585 h43z
M367 15 v585 v` + midHeight + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -midHeight + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + midHeight + " v585 h43z";
          case "lfloor":
            return "M319 602 V0 H403 V602 v" + midHeight + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + midHeight + " v1715 H319z";
          case "rfloor":
            return "M319 602 V0 H403 V602 v" + midHeight + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + midHeight + " v1715 H319z";
          case "lceil":
            return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + ` v602 h84z
M403 1759 V0 H319 V1759 v` + midHeight + " v602 h84z";
          case "rceil":
            return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + midHeight + " v602 h84z";
          case "lparen":
            return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (midHeight + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (midHeight + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
          case "rparen":
            return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (midHeight + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (midHeight + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
          default:
            throw new Error("Unknown stretchy delimiter.");
        }
      };

      class DocumentFragment2 {
        constructor(children) {
          this.children = undefined;
          this.classes = undefined;
          this.height = undefined;
          this.depth = undefined;
          this.maxFontSize = undefined;
          this.style = undefined;
          this.children = children;
          this.classes = [];
          this.height = 0;
          this.depth = 0;
          this.maxFontSize = 0;
          this.style = {};
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          const frag = document.createDocumentFragment();
          for (let i = 0;i < this.children.length; i++) {
            frag.appendChild(this.children[i].toNode());
          }
          return frag;
        }
        toMarkup() {
          let markup = "";
          for (let i = 0;i < this.children.length; i++) {
            markup += this.children[i].toMarkup();
          }
          return markup;
        }
        toText() {
          const toText = (child) => child.toText();
          return this.children.map(toText).join("");
        }
      }
      var fontMetricsData = {
        "AMS-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68889, 0, 0, 0.72222],
          "66": [0, 0.68889, 0, 0, 0.66667],
          "67": [0, 0.68889, 0, 0, 0.72222],
          "68": [0, 0.68889, 0, 0, 0.72222],
          "69": [0, 0.68889, 0, 0, 0.66667],
          "70": [0, 0.68889, 0, 0, 0.61111],
          "71": [0, 0.68889, 0, 0, 0.77778],
          "72": [0, 0.68889, 0, 0, 0.77778],
          "73": [0, 0.68889, 0, 0, 0.38889],
          "74": [0.16667, 0.68889, 0, 0, 0.5],
          "75": [0, 0.68889, 0, 0, 0.77778],
          "76": [0, 0.68889, 0, 0, 0.66667],
          "77": [0, 0.68889, 0, 0, 0.94445],
          "78": [0, 0.68889, 0, 0, 0.72222],
          "79": [0.16667, 0.68889, 0, 0, 0.77778],
          "80": [0, 0.68889, 0, 0, 0.61111],
          "81": [0.16667, 0.68889, 0, 0, 0.77778],
          "82": [0, 0.68889, 0, 0, 0.72222],
          "83": [0, 0.68889, 0, 0, 0.55556],
          "84": [0, 0.68889, 0, 0, 0.66667],
          "85": [0, 0.68889, 0, 0, 0.72222],
          "86": [0, 0.68889, 0, 0, 0.72222],
          "87": [0, 0.68889, 0, 0, 1],
          "88": [0, 0.68889, 0, 0, 0.72222],
          "89": [0, 0.68889, 0, 0, 0.72222],
          "90": [0, 0.68889, 0, 0, 0.66667],
          "107": [0, 0.68889, 0, 0, 0.55556],
          "160": [0, 0, 0, 0, 0.25],
          "165": [0, 0.675, 0.025, 0, 0.75],
          "174": [0.15559, 0.69224, 0, 0, 0.94666],
          "240": [0, 0.68889, 0, 0, 0.55556],
          "295": [0, 0.68889, 0, 0, 0.54028],
          "710": [0, 0.825, 0, 0, 2.33334],
          "732": [0, 0.9, 0, 0, 2.33334],
          "770": [0, 0.825, 0, 0, 2.33334],
          "771": [0, 0.9, 0, 0, 2.33334],
          "989": [0.08167, 0.58167, 0, 0, 0.77778],
          "1008": [0, 0.43056, 0.04028, 0, 0.66667],
          "8245": [0, 0.54986, 0, 0, 0.275],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8487": [0, 0.68889, 0, 0, 0.72222],
          "8498": [0, 0.68889, 0, 0, 0.55556],
          "8502": [0, 0.68889, 0, 0, 0.66667],
          "8503": [0, 0.68889, 0, 0, 0.44445],
          "8504": [0, 0.68889, 0, 0, 0.66667],
          "8513": [0, 0.68889, 0, 0, 0.63889],
          "8592": [-0.03598, 0.46402, 0, 0, 0.5],
          "8594": [-0.03598, 0.46402, 0, 0, 0.5],
          "8602": [-0.13313, 0.36687, 0, 0, 1],
          "8603": [-0.13313, 0.36687, 0, 0, 1],
          "8606": [0.01354, 0.52239, 0, 0, 1],
          "8608": [0.01354, 0.52239, 0, 0, 1],
          "8610": [0.01354, 0.52239, 0, 0, 1.11111],
          "8611": [0.01354, 0.52239, 0, 0, 1.11111],
          "8619": [0, 0.54986, 0, 0, 1],
          "8620": [0, 0.54986, 0, 0, 1],
          "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
          "8622": [-0.13313, 0.36687, 0, 0, 1],
          "8624": [0, 0.69224, 0, 0, 0.5],
          "8625": [0, 0.69224, 0, 0, 0.5],
          "8630": [0, 0.43056, 0, 0, 1],
          "8631": [0, 0.43056, 0, 0, 1],
          "8634": [0.08198, 0.58198, 0, 0, 0.77778],
          "8635": [0.08198, 0.58198, 0, 0, 0.77778],
          "8638": [0.19444, 0.69224, 0, 0, 0.41667],
          "8639": [0.19444, 0.69224, 0, 0, 0.41667],
          "8642": [0.19444, 0.69224, 0, 0, 0.41667],
          "8643": [0.19444, 0.69224, 0, 0, 0.41667],
          "8644": [0.1808, 0.675, 0, 0, 1],
          "8646": [0.1808, 0.675, 0, 0, 1],
          "8647": [0.1808, 0.675, 0, 0, 1],
          "8648": [0.19444, 0.69224, 0, 0, 0.83334],
          "8649": [0.1808, 0.675, 0, 0, 1],
          "8650": [0.19444, 0.69224, 0, 0, 0.83334],
          "8651": [0.01354, 0.52239, 0, 0, 1],
          "8652": [0.01354, 0.52239, 0, 0, 1],
          "8653": [-0.13313, 0.36687, 0, 0, 1],
          "8654": [-0.13313, 0.36687, 0, 0, 1],
          "8655": [-0.13313, 0.36687, 0, 0, 1],
          "8666": [0.13667, 0.63667, 0, 0, 1],
          "8667": [0.13667, 0.63667, 0, 0, 1],
          "8669": [-0.13313, 0.37788, 0, 0, 1],
          "8672": [-0.064, 0.437, 0, 0, 1.334],
          "8674": [-0.064, 0.437, 0, 0, 1.334],
          "8705": [0, 0.825, 0, 0, 0.5],
          "8708": [0, 0.68889, 0, 0, 0.55556],
          "8709": [0.08167, 0.58167, 0, 0, 0.77778],
          "8717": [0, 0.43056, 0, 0, 0.42917],
          "8722": [-0.03598, 0.46402, 0, 0, 0.5],
          "8724": [0.08198, 0.69224, 0, 0, 0.77778],
          "8726": [0.08167, 0.58167, 0, 0, 0.77778],
          "8733": [0, 0.69224, 0, 0, 0.77778],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8737": [0, 0.69224, 0, 0, 0.72222],
          "8738": [0.03517, 0.52239, 0, 0, 0.72222],
          "8739": [0.08167, 0.58167, 0, 0, 0.22222],
          "8740": [0.25142, 0.74111, 0, 0, 0.27778],
          "8741": [0.08167, 0.58167, 0, 0, 0.38889],
          "8742": [0.25142, 0.74111, 0, 0, 0.5],
          "8756": [0, 0.69224, 0, 0, 0.66667],
          "8757": [0, 0.69224, 0, 0, 0.66667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
          "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8774": [0.30274, 0.79383, 0, 0, 0.77778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8778": [0.08167, 0.58167, 0, 0, 0.77778],
          "8782": [0.06062, 0.54986, 0, 0, 0.77778],
          "8783": [0.06062, 0.54986, 0, 0, 0.77778],
          "8785": [0.08198, 0.58198, 0, 0, 0.77778],
          "8786": [0.08198, 0.58198, 0, 0, 0.77778],
          "8787": [0.08198, 0.58198, 0, 0, 0.77778],
          "8790": [0, 0.69224, 0, 0, 0.77778],
          "8791": [0.22958, 0.72958, 0, 0, 0.77778],
          "8796": [0.08198, 0.91667, 0, 0, 0.77778],
          "8806": [0.25583, 0.75583, 0, 0, 0.77778],
          "8807": [0.25583, 0.75583, 0, 0, 0.77778],
          "8808": [0.25142, 0.75726, 0, 0, 0.77778],
          "8809": [0.25142, 0.75726, 0, 0, 0.77778],
          "8812": [0.25583, 0.75583, 0, 0, 0.5],
          "8814": [0.20576, 0.70576, 0, 0, 0.77778],
          "8815": [0.20576, 0.70576, 0, 0, 0.77778],
          "8816": [0.30274, 0.79383, 0, 0, 0.77778],
          "8817": [0.30274, 0.79383, 0, 0, 0.77778],
          "8818": [0.22958, 0.72958, 0, 0, 0.77778],
          "8819": [0.22958, 0.72958, 0, 0, 0.77778],
          "8822": [0.1808, 0.675, 0, 0, 0.77778],
          "8823": [0.1808, 0.675, 0, 0, 0.77778],
          "8828": [0.13667, 0.63667, 0, 0, 0.77778],
          "8829": [0.13667, 0.63667, 0, 0, 0.77778],
          "8830": [0.22958, 0.72958, 0, 0, 0.77778],
          "8831": [0.22958, 0.72958, 0, 0, 0.77778],
          "8832": [0.20576, 0.70576, 0, 0, 0.77778],
          "8833": [0.20576, 0.70576, 0, 0, 0.77778],
          "8840": [0.30274, 0.79383, 0, 0, 0.77778],
          "8841": [0.30274, 0.79383, 0, 0, 0.77778],
          "8842": [0.13597, 0.63597, 0, 0, 0.77778],
          "8843": [0.13597, 0.63597, 0, 0, 0.77778],
          "8847": [0.03517, 0.54986, 0, 0, 0.77778],
          "8848": [0.03517, 0.54986, 0, 0, 0.77778],
          "8858": [0.08198, 0.58198, 0, 0, 0.77778],
          "8859": [0.08198, 0.58198, 0, 0, 0.77778],
          "8861": [0.08198, 0.58198, 0, 0, 0.77778],
          "8862": [0, 0.675, 0, 0, 0.77778],
          "8863": [0, 0.675, 0, 0, 0.77778],
          "8864": [0, 0.675, 0, 0, 0.77778],
          "8865": [0, 0.675, 0, 0, 0.77778],
          "8872": [0, 0.69224, 0, 0, 0.61111],
          "8873": [0, 0.69224, 0, 0, 0.72222],
          "8874": [0, 0.69224, 0, 0, 0.88889],
          "8876": [0, 0.68889, 0, 0, 0.61111],
          "8877": [0, 0.68889, 0, 0, 0.61111],
          "8878": [0, 0.68889, 0, 0, 0.72222],
          "8879": [0, 0.68889, 0, 0, 0.72222],
          "8882": [0.03517, 0.54986, 0, 0, 0.77778],
          "8883": [0.03517, 0.54986, 0, 0, 0.77778],
          "8884": [0.13667, 0.63667, 0, 0, 0.77778],
          "8885": [0.13667, 0.63667, 0, 0, 0.77778],
          "8888": [0, 0.54986, 0, 0, 1.11111],
          "8890": [0.19444, 0.43056, 0, 0, 0.55556],
          "8891": [0.19444, 0.69224, 0, 0, 0.61111],
          "8892": [0.19444, 0.69224, 0, 0, 0.61111],
          "8901": [0, 0.54986, 0, 0, 0.27778],
          "8903": [0.08167, 0.58167, 0, 0, 0.77778],
          "8905": [0.08167, 0.58167, 0, 0, 0.77778],
          "8906": [0.08167, 0.58167, 0, 0, 0.77778],
          "8907": [0, 0.69224, 0, 0, 0.77778],
          "8908": [0, 0.69224, 0, 0, 0.77778],
          "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
          "8910": [0, 0.54986, 0, 0, 0.76042],
          "8911": [0, 0.54986, 0, 0, 0.76042],
          "8912": [0.03517, 0.54986, 0, 0, 0.77778],
          "8913": [0.03517, 0.54986, 0, 0, 0.77778],
          "8914": [0, 0.54986, 0, 0, 0.66667],
          "8915": [0, 0.54986, 0, 0, 0.66667],
          "8916": [0, 0.69224, 0, 0, 0.66667],
          "8918": [0.0391, 0.5391, 0, 0, 0.77778],
          "8919": [0.0391, 0.5391, 0, 0, 0.77778],
          "8920": [0.03517, 0.54986, 0, 0, 1.33334],
          "8921": [0.03517, 0.54986, 0, 0, 1.33334],
          "8922": [0.38569, 0.88569, 0, 0, 0.77778],
          "8923": [0.38569, 0.88569, 0, 0, 0.77778],
          "8926": [0.13667, 0.63667, 0, 0, 0.77778],
          "8927": [0.13667, 0.63667, 0, 0, 0.77778],
          "8928": [0.30274, 0.79383, 0, 0, 0.77778],
          "8929": [0.30274, 0.79383, 0, 0, 0.77778],
          "8934": [0.23222, 0.74111, 0, 0, 0.77778],
          "8935": [0.23222, 0.74111, 0, 0, 0.77778],
          "8936": [0.23222, 0.74111, 0, 0, 0.77778],
          "8937": [0.23222, 0.74111, 0, 0, 0.77778],
          "8938": [0.20576, 0.70576, 0, 0, 0.77778],
          "8939": [0.20576, 0.70576, 0, 0, 0.77778],
          "8940": [0.30274, 0.79383, 0, 0, 0.77778],
          "8941": [0.30274, 0.79383, 0, 0, 0.77778],
          "8994": [0.19444, 0.69224, 0, 0, 0.77778],
          "8995": [0.19444, 0.69224, 0, 0, 0.77778],
          "9416": [0.15559, 0.69224, 0, 0, 0.90222],
          "9484": [0, 0.69224, 0, 0, 0.5],
          "9488": [0, 0.69224, 0, 0, 0.5],
          "9492": [0, 0.37788, 0, 0, 0.5],
          "9496": [0, 0.37788, 0, 0, 0.5],
          "9585": [0.19444, 0.68889, 0, 0, 0.88889],
          "9586": [0.19444, 0.74111, 0, 0, 0.88889],
          "9632": [0, 0.675, 0, 0, 0.77778],
          "9633": [0, 0.675, 0, 0, 0.77778],
          "9650": [0, 0.54986, 0, 0, 0.72222],
          "9651": [0, 0.54986, 0, 0, 0.72222],
          "9654": [0.03517, 0.54986, 0, 0, 0.77778],
          "9660": [0, 0.54986, 0, 0, 0.72222],
          "9661": [0, 0.54986, 0, 0, 0.72222],
          "9664": [0.03517, 0.54986, 0, 0, 0.77778],
          "9674": [0.11111, 0.69224, 0, 0, 0.66667],
          "9733": [0.19444, 0.69224, 0, 0, 0.94445],
          "10003": [0, 0.69224, 0, 0, 0.83334],
          "10016": [0, 0.69224, 0, 0, 0.83334],
          "10731": [0.11111, 0.69224, 0, 0, 0.66667],
          "10846": [0.19444, 0.75583, 0, 0, 0.61111],
          "10877": [0.13667, 0.63667, 0, 0, 0.77778],
          "10878": [0.13667, 0.63667, 0, 0, 0.77778],
          "10885": [0.25583, 0.75583, 0, 0, 0.77778],
          "10886": [0.25583, 0.75583, 0, 0, 0.77778],
          "10887": [0.13597, 0.63597, 0, 0, 0.77778],
          "10888": [0.13597, 0.63597, 0, 0, 0.77778],
          "10889": [0.26167, 0.75726, 0, 0, 0.77778],
          "10890": [0.26167, 0.75726, 0, 0, 0.77778],
          "10891": [0.48256, 0.98256, 0, 0, 0.77778],
          "10892": [0.48256, 0.98256, 0, 0, 0.77778],
          "10901": [0.13667, 0.63667, 0, 0, 0.77778],
          "10902": [0.13667, 0.63667, 0, 0, 0.77778],
          "10933": [0.25142, 0.75726, 0, 0, 0.77778],
          "10934": [0.25142, 0.75726, 0, 0, 0.77778],
          "10935": [0.26167, 0.75726, 0, 0, 0.77778],
          "10936": [0.26167, 0.75726, 0, 0, 0.77778],
          "10937": [0.26167, 0.75726, 0, 0, 0.77778],
          "10938": [0.26167, 0.75726, 0, 0, 0.77778],
          "10949": [0.25583, 0.75583, 0, 0, 0.77778],
          "10950": [0.25583, 0.75583, 0, 0, 0.77778],
          "10955": [0.28481, 0.79383, 0, 0, 0.77778],
          "10956": [0.28481, 0.79383, 0, 0, 0.77778],
          "57350": [0.08167, 0.58167, 0, 0, 0.22222],
          "57351": [0.08167, 0.58167, 0, 0, 0.38889],
          "57352": [0.08167, 0.58167, 0, 0, 0.77778],
          "57353": [0, 0.43056, 0.04028, 0, 0.66667],
          "57356": [0.25142, 0.75726, 0, 0, 0.77778],
          "57357": [0.25142, 0.75726, 0, 0, 0.77778],
          "57358": [0.41951, 0.91951, 0, 0, 0.77778],
          "57359": [0.30274, 0.79383, 0, 0, 0.77778],
          "57360": [0.30274, 0.79383, 0, 0, 0.77778],
          "57361": [0.41951, 0.91951, 0, 0, 0.77778],
          "57366": [0.25142, 0.75726, 0, 0, 0.77778],
          "57367": [0.25142, 0.75726, 0, 0, 0.77778],
          "57368": [0.25142, 0.75726, 0, 0, 0.77778],
          "57369": [0.25142, 0.75726, 0, 0, 0.77778],
          "57370": [0.13597, 0.63597, 0, 0, 0.77778],
          "57371": [0.13597, 0.63597, 0, 0, 0.77778]
        },
        "Caligraphic-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68333, 0, 0.19445, 0.79847],
          "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
          "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
          "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
          "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
          "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
          "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
          "72": [0, 0.68333, 0.00965, 0.11111, 0.84452],
          "73": [0, 0.68333, 0.07382, 0, 0.54452],
          "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
          "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
          "76": [0, 0.68333, 0, 0.13889, 0.68972],
          "77": [0, 0.68333, 0, 0.13889, 1.2009],
          "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
          "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
          "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
          "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
          "82": [0, 0.68333, 0, 0.08334, 0.8475],
          "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
          "84": [0, 0.68333, 0.25417, 0, 0.54464],
          "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
          "86": [0, 0.68333, 0.08222, 0, 0.61278],
          "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
          "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
          "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
          "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Fraktur-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69141, 0, 0, 0.29574],
          "34": [0, 0.69141, 0, 0, 0.21471],
          "38": [0, 0.69141, 0, 0, 0.73786],
          "39": [0, 0.69141, 0, 0, 0.21201],
          "40": [0.24982, 0.74947, 0, 0, 0.38865],
          "41": [0.24982, 0.74947, 0, 0, 0.38865],
          "42": [0, 0.62119, 0, 0, 0.27764],
          "43": [0.08319, 0.58283, 0, 0, 0.75623],
          "44": [0, 0.10803, 0, 0, 0.27764],
          "45": [0.08319, 0.58283, 0, 0, 0.75623],
          "46": [0, 0.10803, 0, 0, 0.27764],
          "47": [0.24982, 0.74947, 0, 0, 0.50181],
          "48": [0, 0.47534, 0, 0, 0.50181],
          "49": [0, 0.47534, 0, 0, 0.50181],
          "50": [0, 0.47534, 0, 0, 0.50181],
          "51": [0.18906, 0.47534, 0, 0, 0.50181],
          "52": [0.18906, 0.47534, 0, 0, 0.50181],
          "53": [0.18906, 0.47534, 0, 0, 0.50181],
          "54": [0, 0.69141, 0, 0, 0.50181],
          "55": [0.18906, 0.47534, 0, 0, 0.50181],
          "56": [0, 0.69141, 0, 0, 0.50181],
          "57": [0.18906, 0.47534, 0, 0, 0.50181],
          "58": [0, 0.47534, 0, 0, 0.21606],
          "59": [0.12604, 0.47534, 0, 0, 0.21606],
          "61": [-0.13099, 0.36866, 0, 0, 0.75623],
          "63": [0, 0.69141, 0, 0, 0.36245],
          "65": [0, 0.69141, 0, 0, 0.7176],
          "66": [0, 0.69141, 0, 0, 0.88397],
          "67": [0, 0.69141, 0, 0, 0.61254],
          "68": [0, 0.69141, 0, 0, 0.83158],
          "69": [0, 0.69141, 0, 0, 0.66278],
          "70": [0.12604, 0.69141, 0, 0, 0.61119],
          "71": [0, 0.69141, 0, 0, 0.78539],
          "72": [0.06302, 0.69141, 0, 0, 0.7203],
          "73": [0, 0.69141, 0, 0, 0.55448],
          "74": [0.12604, 0.69141, 0, 0, 0.55231],
          "75": [0, 0.69141, 0, 0, 0.66845],
          "76": [0, 0.69141, 0, 0, 0.66602],
          "77": [0, 0.69141, 0, 0, 1.04953],
          "78": [0, 0.69141, 0, 0, 0.83212],
          "79": [0, 0.69141, 0, 0, 0.82699],
          "80": [0.18906, 0.69141, 0, 0, 0.82753],
          "81": [0.03781, 0.69141, 0, 0, 0.82699],
          "82": [0, 0.69141, 0, 0, 0.82807],
          "83": [0, 0.69141, 0, 0, 0.82861],
          "84": [0, 0.69141, 0, 0, 0.66899],
          "85": [0, 0.69141, 0, 0, 0.64576],
          "86": [0, 0.69141, 0, 0, 0.83131],
          "87": [0, 0.69141, 0, 0, 1.04602],
          "88": [0, 0.69141, 0, 0, 0.71922],
          "89": [0.18906, 0.69141, 0, 0, 0.83293],
          "90": [0.12604, 0.69141, 0, 0, 0.60201],
          "91": [0.24982, 0.74947, 0, 0, 0.27764],
          "93": [0.24982, 0.74947, 0, 0, 0.27764],
          "94": [0, 0.69141, 0, 0, 0.49965],
          "97": [0, 0.47534, 0, 0, 0.50046],
          "98": [0, 0.69141, 0, 0, 0.51315],
          "99": [0, 0.47534, 0, 0, 0.38946],
          "100": [0, 0.62119, 0, 0, 0.49857],
          "101": [0, 0.47534, 0, 0, 0.40053],
          "102": [0.18906, 0.69141, 0, 0, 0.32626],
          "103": [0.18906, 0.47534, 0, 0, 0.5037],
          "104": [0.18906, 0.69141, 0, 0, 0.52126],
          "105": [0, 0.69141, 0, 0, 0.27899],
          "106": [0, 0.69141, 0, 0, 0.28088],
          "107": [0, 0.69141, 0, 0, 0.38946],
          "108": [0, 0.69141, 0, 0, 0.27953],
          "109": [0, 0.47534, 0, 0, 0.76676],
          "110": [0, 0.47534, 0, 0, 0.52666],
          "111": [0, 0.47534, 0, 0, 0.48885],
          "112": [0.18906, 0.52396, 0, 0, 0.50046],
          "113": [0.18906, 0.47534, 0, 0, 0.48912],
          "114": [0, 0.47534, 0, 0, 0.38919],
          "115": [0, 0.47534, 0, 0, 0.44266],
          "116": [0, 0.62119, 0, 0, 0.33301],
          "117": [0, 0.47534, 0, 0, 0.5172],
          "118": [0, 0.52396, 0, 0, 0.5118],
          "119": [0, 0.52396, 0, 0, 0.77351],
          "120": [0.18906, 0.47534, 0, 0, 0.38865],
          "121": [0.18906, 0.47534, 0, 0, 0.49884],
          "122": [0.18906, 0.47534, 0, 0, 0.39054],
          "160": [0, 0, 0, 0, 0.25],
          "8216": [0, 0.69141, 0, 0, 0.21471],
          "8217": [0, 0.69141, 0, 0, 0.21471],
          "58112": [0, 0.62119, 0, 0, 0.49749],
          "58113": [0, 0.62119, 0, 0, 0.4983],
          "58114": [0.18906, 0.69141, 0, 0, 0.33328],
          "58115": [0.18906, 0.69141, 0, 0, 0.32923],
          "58116": [0.18906, 0.47534, 0, 0, 0.50343],
          "58117": [0, 0.69141, 0, 0, 0.33301],
          "58118": [0, 0.62119, 0, 0, 0.33409],
          "58119": [0, 0.47534, 0, 0, 0.50073]
        },
        "Main-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.35],
          "34": [0, 0.69444, 0, 0, 0.60278],
          "35": [0.19444, 0.69444, 0, 0, 0.95833],
          "36": [0.05556, 0.75, 0, 0, 0.575],
          "37": [0.05556, 0.75, 0, 0, 0.95833],
          "38": [0, 0.69444, 0, 0, 0.89444],
          "39": [0, 0.69444, 0, 0, 0.31944],
          "40": [0.25, 0.75, 0, 0, 0.44722],
          "41": [0.25, 0.75, 0, 0, 0.44722],
          "42": [0, 0.75, 0, 0, 0.575],
          "43": [0.13333, 0.63333, 0, 0, 0.89444],
          "44": [0.19444, 0.15556, 0, 0, 0.31944],
          "45": [0, 0.44444, 0, 0, 0.38333],
          "46": [0, 0.15556, 0, 0, 0.31944],
          "47": [0.25, 0.75, 0, 0, 0.575],
          "48": [0, 0.64444, 0, 0, 0.575],
          "49": [0, 0.64444, 0, 0, 0.575],
          "50": [0, 0.64444, 0, 0, 0.575],
          "51": [0, 0.64444, 0, 0, 0.575],
          "52": [0, 0.64444, 0, 0, 0.575],
          "53": [0, 0.64444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0, 0.64444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0, 0.64444, 0, 0, 0.575],
          "58": [0, 0.44444, 0, 0, 0.31944],
          "59": [0.19444, 0.44444, 0, 0, 0.31944],
          "60": [0.08556, 0.58556, 0, 0, 0.89444],
          "61": [-0.10889, 0.39111, 0, 0, 0.89444],
          "62": [0.08556, 0.58556, 0, 0, 0.89444],
          "63": [0, 0.69444, 0, 0, 0.54305],
          "64": [0, 0.69444, 0, 0, 0.89444],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0, 0, 0.81805],
          "67": [0, 0.68611, 0, 0, 0.83055],
          "68": [0, 0.68611, 0, 0, 0.88194],
          "69": [0, 0.68611, 0, 0, 0.75555],
          "70": [0, 0.68611, 0, 0, 0.72361],
          "71": [0, 0.68611, 0, 0, 0.90416],
          "72": [0, 0.68611, 0, 0, 0.9],
          "73": [0, 0.68611, 0, 0, 0.43611],
          "74": [0, 0.68611, 0, 0, 0.59444],
          "75": [0, 0.68611, 0, 0, 0.90138],
          "76": [0, 0.68611, 0, 0, 0.69166],
          "77": [0, 0.68611, 0, 0, 1.09166],
          "78": [0, 0.68611, 0, 0, 0.9],
          "79": [0, 0.68611, 0, 0, 0.86388],
          "80": [0, 0.68611, 0, 0, 0.78611],
          "81": [0.19444, 0.68611, 0, 0, 0.86388],
          "82": [0, 0.68611, 0, 0, 0.8625],
          "83": [0, 0.68611, 0, 0, 0.63889],
          "84": [0, 0.68611, 0, 0, 0.8],
          "85": [0, 0.68611, 0, 0, 0.88472],
          "86": [0, 0.68611, 0.01597, 0, 0.86944],
          "87": [0, 0.68611, 0.01597, 0, 1.18888],
          "88": [0, 0.68611, 0, 0, 0.86944],
          "89": [0, 0.68611, 0.02875, 0, 0.86944],
          "90": [0, 0.68611, 0, 0, 0.70277],
          "91": [0.25, 0.75, 0, 0, 0.31944],
          "92": [0.25, 0.75, 0, 0, 0.575],
          "93": [0.25, 0.75, 0, 0, 0.31944],
          "94": [0, 0.69444, 0, 0, 0.575],
          "95": [0.31, 0.13444, 0.03194, 0, 0.575],
          "97": [0, 0.44444, 0, 0, 0.55902],
          "98": [0, 0.69444, 0, 0, 0.63889],
          "99": [0, 0.44444, 0, 0, 0.51111],
          "100": [0, 0.69444, 0, 0, 0.63889],
          "101": [0, 0.44444, 0, 0, 0.52708],
          "102": [0, 0.69444, 0.10903, 0, 0.35139],
          "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
          "104": [0, 0.69444, 0, 0, 0.63889],
          "105": [0, 0.69444, 0, 0, 0.31944],
          "106": [0.19444, 0.69444, 0, 0, 0.35139],
          "107": [0, 0.69444, 0, 0, 0.60694],
          "108": [0, 0.69444, 0, 0, 0.31944],
          "109": [0, 0.44444, 0, 0, 0.95833],
          "110": [0, 0.44444, 0, 0, 0.63889],
          "111": [0, 0.44444, 0, 0, 0.575],
          "112": [0.19444, 0.44444, 0, 0, 0.63889],
          "113": [0.19444, 0.44444, 0, 0, 0.60694],
          "114": [0, 0.44444, 0, 0, 0.47361],
          "115": [0, 0.44444, 0, 0, 0.45361],
          "116": [0, 0.63492, 0, 0, 0.44722],
          "117": [0, 0.44444, 0, 0, 0.63889],
          "118": [0, 0.44444, 0.01597, 0, 0.60694],
          "119": [0, 0.44444, 0.01597, 0, 0.83055],
          "120": [0, 0.44444, 0, 0, 0.60694],
          "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
          "122": [0, 0.44444, 0, 0, 0.51111],
          "123": [0.25, 0.75, 0, 0, 0.575],
          "124": [0.25, 0.75, 0, 0, 0.31944],
          "125": [0.25, 0.75, 0, 0, 0.575],
          "126": [0.35, 0.34444, 0, 0, 0.575],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.86853],
          "168": [0, 0.69444, 0, 0, 0.575],
          "172": [0, 0.44444, 0, 0, 0.76666],
          "176": [0, 0.69444, 0, 0, 0.86944],
          "177": [0.13333, 0.63333, 0, 0, 0.89444],
          "184": [0.17014, 0, 0, 0, 0.51111],
          "198": [0, 0.68611, 0, 0, 1.04166],
          "215": [0.13333, 0.63333, 0, 0, 0.89444],
          "216": [0.04861, 0.73472, 0, 0, 0.89444],
          "223": [0, 0.69444, 0, 0, 0.59722],
          "230": [0, 0.44444, 0, 0, 0.83055],
          "247": [0.13333, 0.63333, 0, 0, 0.89444],
          "248": [0.09722, 0.54167, 0, 0, 0.575],
          "305": [0, 0.44444, 0, 0, 0.31944],
          "338": [0, 0.68611, 0, 0, 1.16944],
          "339": [0, 0.44444, 0, 0, 0.89444],
          "567": [0.19444, 0.44444, 0, 0, 0.35139],
          "710": [0, 0.69444, 0, 0, 0.575],
          "711": [0, 0.63194, 0, 0, 0.575],
          "713": [0, 0.59611, 0, 0, 0.575],
          "714": [0, 0.69444, 0, 0, 0.575],
          "715": [0, 0.69444, 0, 0, 0.575],
          "728": [0, 0.69444, 0, 0, 0.575],
          "729": [0, 0.69444, 0, 0, 0.31944],
          "730": [0, 0.69444, 0, 0, 0.86944],
          "732": [0, 0.69444, 0, 0, 0.575],
          "733": [0, 0.69444, 0, 0, 0.575],
          "915": [0, 0.68611, 0, 0, 0.69166],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0, 0, 0.89444],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0, 0, 0.76666],
          "928": [0, 0.68611, 0, 0, 0.9],
          "931": [0, 0.68611, 0, 0, 0.83055],
          "933": [0, 0.68611, 0, 0, 0.89444],
          "934": [0, 0.68611, 0, 0, 0.83055],
          "936": [0, 0.68611, 0, 0, 0.89444],
          "937": [0, 0.68611, 0, 0, 0.83055],
          "8211": [0, 0.44444, 0.03194, 0, 0.575],
          "8212": [0, 0.44444, 0.03194, 0, 1.14999],
          "8216": [0, 0.69444, 0, 0, 0.31944],
          "8217": [0, 0.69444, 0, 0, 0.31944],
          "8220": [0, 0.69444, 0, 0, 0.60278],
          "8221": [0, 0.69444, 0, 0, 0.60278],
          "8224": [0.19444, 0.69444, 0, 0, 0.51111],
          "8225": [0.19444, 0.69444, 0, 0, 0.51111],
          "8242": [0, 0.55556, 0, 0, 0.34444],
          "8407": [0, 0.72444, 0.15486, 0, 0.575],
          "8463": [0, 0.69444, 0, 0, 0.66759],
          "8465": [0, 0.69444, 0, 0, 0.83055],
          "8467": [0, 0.69444, 0, 0, 0.47361],
          "8472": [0.19444, 0.44444, 0, 0, 0.74027],
          "8476": [0, 0.69444, 0, 0, 0.83055],
          "8501": [0, 0.69444, 0, 0, 0.70277],
          "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8593": [0.19444, 0.69444, 0, 0, 0.575],
          "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8595": [0.19444, 0.69444, 0, 0, 0.575],
          "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8597": [0.25, 0.75, 0, 0, 0.575],
          "8598": [0.19444, 0.69444, 0, 0, 1.14999],
          "8599": [0.19444, 0.69444, 0, 0, 1.14999],
          "8600": [0.19444, 0.69444, 0, 0, 1.14999],
          "8601": [0.19444, 0.69444, 0, 0, 1.14999],
          "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8657": [0.19444, 0.69444, 0, 0, 0.70277],
          "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8659": [0.19444, 0.69444, 0, 0, 0.70277],
          "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8661": [0.25, 0.75, 0, 0, 0.70277],
          "8704": [0, 0.69444, 0, 0, 0.63889],
          "8706": [0, 0.69444, 0.06389, 0, 0.62847],
          "8707": [0, 0.69444, 0, 0, 0.63889],
          "8709": [0.05556, 0.75, 0, 0, 0.575],
          "8711": [0, 0.68611, 0, 0, 0.95833],
          "8712": [0.08556, 0.58556, 0, 0, 0.76666],
          "8715": [0.08556, 0.58556, 0, 0, 0.76666],
          "8722": [0.13333, 0.63333, 0, 0, 0.89444],
          "8723": [0.13333, 0.63333, 0, 0, 0.89444],
          "8725": [0.25, 0.75, 0, 0, 0.575],
          "8726": [0.25, 0.75, 0, 0, 0.575],
          "8727": [-0.02778, 0.47222, 0, 0, 0.575],
          "8728": [-0.02639, 0.47361, 0, 0, 0.575],
          "8729": [-0.02639, 0.47361, 0, 0, 0.575],
          "8730": [0.18, 0.82, 0, 0, 0.95833],
          "8733": [0, 0.44444, 0, 0, 0.89444],
          "8734": [0, 0.44444, 0, 0, 1.14999],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.31944],
          "8741": [0.25, 0.75, 0, 0, 0.575],
          "8743": [0, 0.55556, 0, 0, 0.76666],
          "8744": [0, 0.55556, 0, 0, 0.76666],
          "8745": [0, 0.55556, 0, 0, 0.76666],
          "8746": [0, 0.55556, 0, 0, 0.76666],
          "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
          "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
          "8768": [0.19444, 0.69444, 0, 0, 0.31944],
          "8771": [0.00222, 0.50222, 0, 0, 0.89444],
          "8773": [0.027, 0.638, 0, 0, 0.894],
          "8776": [0.02444, 0.52444, 0, 0, 0.89444],
          "8781": [0.00222, 0.50222, 0, 0, 0.89444],
          "8801": [0.00222, 0.50222, 0, 0, 0.89444],
          "8804": [0.19667, 0.69667, 0, 0, 0.89444],
          "8805": [0.19667, 0.69667, 0, 0, 0.89444],
          "8810": [0.08556, 0.58556, 0, 0, 1.14999],
          "8811": [0.08556, 0.58556, 0, 0, 1.14999],
          "8826": [0.08556, 0.58556, 0, 0, 0.89444],
          "8827": [0.08556, 0.58556, 0, 0, 0.89444],
          "8834": [0.08556, 0.58556, 0, 0, 0.89444],
          "8835": [0.08556, 0.58556, 0, 0, 0.89444],
          "8838": [0.19667, 0.69667, 0, 0, 0.89444],
          "8839": [0.19667, 0.69667, 0, 0, 0.89444],
          "8846": [0, 0.55556, 0, 0, 0.76666],
          "8849": [0.19667, 0.69667, 0, 0, 0.89444],
          "8850": [0.19667, 0.69667, 0, 0, 0.89444],
          "8851": [0, 0.55556, 0, 0, 0.76666],
          "8852": [0, 0.55556, 0, 0, 0.76666],
          "8853": [0.13333, 0.63333, 0, 0, 0.89444],
          "8854": [0.13333, 0.63333, 0, 0, 0.89444],
          "8855": [0.13333, 0.63333, 0, 0, 0.89444],
          "8856": [0.13333, 0.63333, 0, 0, 0.89444],
          "8857": [0.13333, 0.63333, 0, 0, 0.89444],
          "8866": [0, 0.69444, 0, 0, 0.70277],
          "8867": [0, 0.69444, 0, 0, 0.70277],
          "8868": [0, 0.69444, 0, 0, 0.89444],
          "8869": [0, 0.69444, 0, 0, 0.89444],
          "8900": [-0.02639, 0.47361, 0, 0, 0.575],
          "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
          "8902": [-0.02778, 0.47222, 0, 0, 0.575],
          "8968": [0.25, 0.75, 0, 0, 0.51111],
          "8969": [0.25, 0.75, 0, 0, 0.51111],
          "8970": [0.25, 0.75, 0, 0, 0.51111],
          "8971": [0.25, 0.75, 0, 0, 0.51111],
          "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
          "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
          "9651": [0.19444, 0.69444, 0, 0, 1.02222],
          "9657": [-0.02778, 0.47222, 0, 0, 0.575],
          "9661": [0.19444, 0.69444, 0, 0, 1.02222],
          "9667": [-0.02778, 0.47222, 0, 0, 0.575],
          "9711": [0.19444, 0.69444, 0, 0, 1.14999],
          "9824": [0.12963, 0.69444, 0, 0, 0.89444],
          "9825": [0.12963, 0.69444, 0, 0, 0.89444],
          "9826": [0.12963, 0.69444, 0, 0, 0.89444],
          "9827": [0.12963, 0.69444, 0, 0, 0.89444],
          "9837": [0, 0.75, 0, 0, 0.44722],
          "9838": [0.19444, 0.69444, 0, 0, 0.44722],
          "9839": [0.19444, 0.69444, 0, 0, 0.44722],
          "10216": [0.25, 0.75, 0, 0, 0.44722],
          "10217": [0.25, 0.75, 0, 0, 0.44722],
          "10815": [0, 0.68611, 0, 0, 0.9],
          "10927": [0.19667, 0.69667, 0, 0, 0.89444],
          "10928": [0.19667, 0.69667, 0, 0, 0.89444],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Main-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.11417, 0, 0.38611],
          "34": [0, 0.69444, 0.07939, 0, 0.62055],
          "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
          "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
          "38": [0, 0.69444, 0.08528, 0, 0.88555],
          "39": [0, 0.69444, 0.12945, 0, 0.35555],
          "40": [0.25, 0.75, 0.15806, 0, 0.47333],
          "41": [0.25, 0.75, 0.03306, 0, 0.47333],
          "42": [0, 0.75, 0.14333, 0, 0.59111],
          "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
          "44": [0.19444, 0.14722, 0, 0, 0.35555],
          "45": [0, 0.44444, 0.02611, 0, 0.41444],
          "46": [0, 0.14722, 0, 0, 0.35555],
          "47": [0.25, 0.75, 0.15806, 0, 0.59111],
          "48": [0, 0.64444, 0.13167, 0, 0.59111],
          "49": [0, 0.64444, 0.13167, 0, 0.59111],
          "50": [0, 0.64444, 0.13167, 0, 0.59111],
          "51": [0, 0.64444, 0.13167, 0, 0.59111],
          "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "53": [0, 0.64444, 0.13167, 0, 0.59111],
          "54": [0, 0.64444, 0.13167, 0, 0.59111],
          "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "56": [0, 0.64444, 0.13167, 0, 0.59111],
          "57": [0, 0.64444, 0.13167, 0, 0.59111],
          "58": [0, 0.44444, 0.06695, 0, 0.35555],
          "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
          "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
          "63": [0, 0.69444, 0.11472, 0, 0.59111],
          "64": [0, 0.69444, 0.09208, 0, 0.88555],
          "65": [0, 0.68611, 0, 0, 0.86555],
          "66": [0, 0.68611, 0.0992, 0, 0.81666],
          "67": [0, 0.68611, 0.14208, 0, 0.82666],
          "68": [0, 0.68611, 0.09062, 0, 0.87555],
          "69": [0, 0.68611, 0.11431, 0, 0.75666],
          "70": [0, 0.68611, 0.12903, 0, 0.72722],
          "71": [0, 0.68611, 0.07347, 0, 0.89527],
          "72": [0, 0.68611, 0.17208, 0, 0.8961],
          "73": [0, 0.68611, 0.15681, 0, 0.47166],
          "74": [0, 0.68611, 0.145, 0, 0.61055],
          "75": [0, 0.68611, 0.14208, 0, 0.89499],
          "76": [0, 0.68611, 0, 0, 0.69777],
          "77": [0, 0.68611, 0.17208, 0, 1.07277],
          "78": [0, 0.68611, 0.17208, 0, 0.8961],
          "79": [0, 0.68611, 0.09062, 0, 0.85499],
          "80": [0, 0.68611, 0.0992, 0, 0.78721],
          "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
          "82": [0, 0.68611, 0.02559, 0, 0.85944],
          "83": [0, 0.68611, 0.11264, 0, 0.64999],
          "84": [0, 0.68611, 0.12903, 0, 0.7961],
          "85": [0, 0.68611, 0.17208, 0, 0.88083],
          "86": [0, 0.68611, 0.18625, 0, 0.86555],
          "87": [0, 0.68611, 0.18625, 0, 1.15999],
          "88": [0, 0.68611, 0.15681, 0, 0.86555],
          "89": [0, 0.68611, 0.19803, 0, 0.86555],
          "90": [0, 0.68611, 0.14208, 0, 0.70888],
          "91": [0.25, 0.75, 0.1875, 0, 0.35611],
          "93": [0.25, 0.75, 0.09972, 0, 0.35611],
          "94": [0, 0.69444, 0.06709, 0, 0.59111],
          "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
          "97": [0, 0.44444, 0.09426, 0, 0.59111],
          "98": [0, 0.69444, 0.07861, 0, 0.53222],
          "99": [0, 0.44444, 0.05222, 0, 0.53222],
          "100": [0, 0.69444, 0.10861, 0, 0.59111],
          "101": [0, 0.44444, 0.085, 0, 0.53222],
          "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
          "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "104": [0, 0.69444, 0.09426, 0, 0.59111],
          "105": [0, 0.69326, 0.11387, 0, 0.35555],
          "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
          "107": [0, 0.69444, 0.11111, 0, 0.53222],
          "108": [0, 0.69444, 0.10861, 0, 0.29666],
          "109": [0, 0.44444, 0.09426, 0, 0.94444],
          "110": [0, 0.44444, 0.09426, 0, 0.64999],
          "111": [0, 0.44444, 0.07861, 0, 0.59111],
          "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
          "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "114": [0, 0.44444, 0.11111, 0, 0.50167],
          "115": [0, 0.44444, 0.08167, 0, 0.48694],
          "116": [0, 0.63492, 0.09639, 0, 0.385],
          "117": [0, 0.44444, 0.09426, 0, 0.62055],
          "118": [0, 0.44444, 0.11111, 0, 0.53222],
          "119": [0, 0.44444, 0.11111, 0, 0.76777],
          "120": [0, 0.44444, 0.12583, 0, 0.56055],
          "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
          "122": [0, 0.44444, 0.13889, 0, 0.49055],
          "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0.11473, 0, 0.59111],
          "176": [0, 0.69444, 0, 0, 0.94888],
          "184": [0.17014, 0, 0, 0, 0.53222],
          "198": [0, 0.68611, 0.11431, 0, 1.02277],
          "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
          "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
          "230": [0, 0.44444, 0.085, 0, 0.82666],
          "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
          "305": [0, 0.44444, 0.09426, 0, 0.35555],
          "338": [0, 0.68611, 0.11431, 0, 1.14054],
          "339": [0, 0.44444, 0.085, 0, 0.82666],
          "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
          "710": [0, 0.69444, 0.06709, 0, 0.59111],
          "711": [0, 0.63194, 0.08271, 0, 0.59111],
          "713": [0, 0.59444, 0.10444, 0, 0.59111],
          "714": [0, 0.69444, 0.08528, 0, 0.59111],
          "715": [0, 0.69444, 0, 0, 0.59111],
          "728": [0, 0.69444, 0.10333, 0, 0.59111],
          "729": [0, 0.69444, 0.12945, 0, 0.35555],
          "730": [0, 0.69444, 0, 0, 0.94888],
          "732": [0, 0.69444, 0.11472, 0, 0.59111],
          "733": [0, 0.69444, 0.11472, 0, 0.59111],
          "915": [0, 0.68611, 0.12903, 0, 0.69777],
          "916": [0, 0.68611, 0, 0, 0.94444],
          "920": [0, 0.68611, 0.09062, 0, 0.88555],
          "923": [0, 0.68611, 0, 0, 0.80666],
          "926": [0, 0.68611, 0.15092, 0, 0.76777],
          "928": [0, 0.68611, 0.17208, 0, 0.8961],
          "931": [0, 0.68611, 0.11431, 0, 0.82666],
          "933": [0, 0.68611, 0.10778, 0, 0.88555],
          "934": [0, 0.68611, 0.05632, 0, 0.82666],
          "936": [0, 0.68611, 0.10778, 0, 0.88555],
          "937": [0, 0.68611, 0.0992, 0, 0.82666],
          "8211": [0, 0.44444, 0.09811, 0, 0.59111],
          "8212": [0, 0.44444, 0.09811, 0, 1.18221],
          "8216": [0, 0.69444, 0.12945, 0, 0.35555],
          "8217": [0, 0.69444, 0.12945, 0, 0.35555],
          "8220": [0, 0.69444, 0.16772, 0, 0.62055],
          "8221": [0, 0.69444, 0.07939, 0, 0.62055]
        },
        "Main-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.12417, 0, 0.30667],
          "34": [0, 0.69444, 0.06961, 0, 0.51444],
          "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
          "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
          "38": [0, 0.69444, 0.09694, 0, 0.76666],
          "39": [0, 0.69444, 0.12417, 0, 0.30667],
          "40": [0.25, 0.75, 0.16194, 0, 0.40889],
          "41": [0.25, 0.75, 0.03694, 0, 0.40889],
          "42": [0, 0.75, 0.14917, 0, 0.51111],
          "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
          "44": [0.19444, 0.10556, 0, 0, 0.30667],
          "45": [0, 0.43056, 0.02826, 0, 0.35778],
          "46": [0, 0.10556, 0, 0, 0.30667],
          "47": [0.25, 0.75, 0.16194, 0, 0.51111],
          "48": [0, 0.64444, 0.13556, 0, 0.51111],
          "49": [0, 0.64444, 0.13556, 0, 0.51111],
          "50": [0, 0.64444, 0.13556, 0, 0.51111],
          "51": [0, 0.64444, 0.13556, 0, 0.51111],
          "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "53": [0, 0.64444, 0.13556, 0, 0.51111],
          "54": [0, 0.64444, 0.13556, 0, 0.51111],
          "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "56": [0, 0.64444, 0.13556, 0, 0.51111],
          "57": [0, 0.64444, 0.13556, 0, 0.51111],
          "58": [0, 0.43056, 0.0582, 0, 0.30667],
          "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
          "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
          "63": [0, 0.69444, 0.1225, 0, 0.51111],
          "64": [0, 0.69444, 0.09597, 0, 0.76666],
          "65": [0, 0.68333, 0, 0, 0.74333],
          "66": [0, 0.68333, 0.10257, 0, 0.70389],
          "67": [0, 0.68333, 0.14528, 0, 0.71555],
          "68": [0, 0.68333, 0.09403, 0, 0.755],
          "69": [0, 0.68333, 0.12028, 0, 0.67833],
          "70": [0, 0.68333, 0.13305, 0, 0.65277],
          "71": [0, 0.68333, 0.08722, 0, 0.77361],
          "72": [0, 0.68333, 0.16389, 0, 0.74333],
          "73": [0, 0.68333, 0.15806, 0, 0.38555],
          "74": [0, 0.68333, 0.14028, 0, 0.525],
          "75": [0, 0.68333, 0.14528, 0, 0.76888],
          "76": [0, 0.68333, 0, 0, 0.62722],
          "77": [0, 0.68333, 0.16389, 0, 0.89666],
          "78": [0, 0.68333, 0.16389, 0, 0.74333],
          "79": [0, 0.68333, 0.09403, 0, 0.76666],
          "80": [0, 0.68333, 0.10257, 0, 0.67833],
          "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
          "82": [0, 0.68333, 0.03868, 0, 0.72944],
          "83": [0, 0.68333, 0.11972, 0, 0.56222],
          "84": [0, 0.68333, 0.13305, 0, 0.71555],
          "85": [0, 0.68333, 0.16389, 0, 0.74333],
          "86": [0, 0.68333, 0.18361, 0, 0.74333],
          "87": [0, 0.68333, 0.18361, 0, 0.99888],
          "88": [0, 0.68333, 0.15806, 0, 0.74333],
          "89": [0, 0.68333, 0.19383, 0, 0.74333],
          "90": [0, 0.68333, 0.14528, 0, 0.61333],
          "91": [0.25, 0.75, 0.1875, 0, 0.30667],
          "93": [0.25, 0.75, 0.10528, 0, 0.30667],
          "94": [0, 0.69444, 0.06646, 0, 0.51111],
          "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
          "97": [0, 0.43056, 0.07671, 0, 0.51111],
          "98": [0, 0.69444, 0.06312, 0, 0.46],
          "99": [0, 0.43056, 0.05653, 0, 0.46],
          "100": [0, 0.69444, 0.10333, 0, 0.51111],
          "101": [0, 0.43056, 0.07514, 0, 0.46],
          "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
          "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "104": [0, 0.69444, 0.07671, 0, 0.51111],
          "105": [0, 0.65536, 0.1019, 0, 0.30667],
          "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
          "107": [0, 0.69444, 0.10764, 0, 0.46],
          "108": [0, 0.69444, 0.10333, 0, 0.25555],
          "109": [0, 0.43056, 0.07671, 0, 0.81777],
          "110": [0, 0.43056, 0.07671, 0, 0.56222],
          "111": [0, 0.43056, 0.06312, 0, 0.51111],
          "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
          "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "114": [0, 0.43056, 0.10764, 0, 0.42166],
          "115": [0, 0.43056, 0.08208, 0, 0.40889],
          "116": [0, 0.61508, 0.09486, 0, 0.33222],
          "117": [0, 0.43056, 0.07671, 0, 0.53666],
          "118": [0, 0.43056, 0.10764, 0, 0.46],
          "119": [0, 0.43056, 0.10764, 0, 0.66444],
          "120": [0, 0.43056, 0.12042, 0, 0.46389],
          "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
          "122": [0, 0.43056, 0.12292, 0, 0.40889],
          "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.66786, 0.10474, 0, 0.51111],
          "176": [0, 0.69444, 0, 0, 0.83129],
          "184": [0.17014, 0, 0, 0, 0.46],
          "198": [0, 0.68333, 0.12028, 0, 0.88277],
          "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
          "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
          "230": [0, 0.43056, 0.07514, 0, 0.71555],
          "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
          "338": [0, 0.68333, 0.12028, 0, 0.98499],
          "339": [0, 0.43056, 0.07514, 0, 0.71555],
          "710": [0, 0.69444, 0.06646, 0, 0.51111],
          "711": [0, 0.62847, 0.08295, 0, 0.51111],
          "713": [0, 0.56167, 0.10333, 0, 0.51111],
          "714": [0, 0.69444, 0.09694, 0, 0.51111],
          "715": [0, 0.69444, 0, 0, 0.51111],
          "728": [0, 0.69444, 0.10806, 0, 0.51111],
          "729": [0, 0.66786, 0.11752, 0, 0.30667],
          "730": [0, 0.69444, 0, 0, 0.83129],
          "732": [0, 0.66786, 0.11585, 0, 0.51111],
          "733": [0, 0.69444, 0.1225, 0, 0.51111],
          "915": [0, 0.68333, 0.13305, 0, 0.62722],
          "916": [0, 0.68333, 0, 0, 0.81777],
          "920": [0, 0.68333, 0.09403, 0, 0.76666],
          "923": [0, 0.68333, 0, 0, 0.69222],
          "926": [0, 0.68333, 0.15294, 0, 0.66444],
          "928": [0, 0.68333, 0.16389, 0, 0.74333],
          "931": [0, 0.68333, 0.12028, 0, 0.71555],
          "933": [0, 0.68333, 0.11111, 0, 0.76666],
          "934": [0, 0.68333, 0.05986, 0, 0.71555],
          "936": [0, 0.68333, 0.11111, 0, 0.76666],
          "937": [0, 0.68333, 0.10257, 0, 0.71555],
          "8211": [0, 0.43056, 0.09208, 0, 0.51111],
          "8212": [0, 0.43056, 0.09208, 0, 1.02222],
          "8216": [0, 0.69444, 0.12417, 0, 0.30667],
          "8217": [0, 0.69444, 0.12417, 0, 0.30667],
          "8220": [0, 0.69444, 0.1685, 0, 0.51444],
          "8221": [0, 0.69444, 0.06961, 0, 0.51444],
          "8463": [0, 0.68889, 0, 0, 0.54028]
        },
        "Main-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.27778],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.77778],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.19444, 0.10556, 0, 0, 0.27778],
          "45": [0, 0.43056, 0, 0, 0.33333],
          "46": [0, 0.10556, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.64444, 0, 0, 0.5],
          "49": [0, 0.64444, 0, 0, 0.5],
          "50": [0, 0.64444, 0, 0, 0.5],
          "51": [0, 0.64444, 0, 0, 0.5],
          "52": [0, 0.64444, 0, 0, 0.5],
          "53": [0, 0.64444, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0, 0.64444, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0, 0.64444, 0, 0, 0.5],
          "58": [0, 0.43056, 0, 0, 0.27778],
          "59": [0.19444, 0.43056, 0, 0, 0.27778],
          "60": [0.0391, 0.5391, 0, 0, 0.77778],
          "61": [-0.13313, 0.36687, 0, 0, 0.77778],
          "62": [0.0391, 0.5391, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.77778],
          "65": [0, 0.68333, 0, 0, 0.75],
          "66": [0, 0.68333, 0, 0, 0.70834],
          "67": [0, 0.68333, 0, 0, 0.72222],
          "68": [0, 0.68333, 0, 0, 0.76389],
          "69": [0, 0.68333, 0, 0, 0.68056],
          "70": [0, 0.68333, 0, 0, 0.65278],
          "71": [0, 0.68333, 0, 0, 0.78472],
          "72": [0, 0.68333, 0, 0, 0.75],
          "73": [0, 0.68333, 0, 0, 0.36111],
          "74": [0, 0.68333, 0, 0, 0.51389],
          "75": [0, 0.68333, 0, 0, 0.77778],
          "76": [0, 0.68333, 0, 0, 0.625],
          "77": [0, 0.68333, 0, 0, 0.91667],
          "78": [0, 0.68333, 0, 0, 0.75],
          "79": [0, 0.68333, 0, 0, 0.77778],
          "80": [0, 0.68333, 0, 0, 0.68056],
          "81": [0.19444, 0.68333, 0, 0, 0.77778],
          "82": [0, 0.68333, 0, 0, 0.73611],
          "83": [0, 0.68333, 0, 0, 0.55556],
          "84": [0, 0.68333, 0, 0, 0.72222],
          "85": [0, 0.68333, 0, 0, 0.75],
          "86": [0, 0.68333, 0.01389, 0, 0.75],
          "87": [0, 0.68333, 0.01389, 0, 1.02778],
          "88": [0, 0.68333, 0, 0, 0.75],
          "89": [0, 0.68333, 0.025, 0, 0.75],
          "90": [0, 0.68333, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.27778],
          "92": [0.25, 0.75, 0, 0, 0.5],
          "93": [0.25, 0.75, 0, 0, 0.27778],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.31, 0.12056, 0.02778, 0, 0.5],
          "97": [0, 0.43056, 0, 0, 0.5],
          "98": [0, 0.69444, 0, 0, 0.55556],
          "99": [0, 0.43056, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.55556],
          "101": [0, 0.43056, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.07778, 0, 0.30556],
          "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.55556],
          "105": [0, 0.66786, 0, 0, 0.27778],
          "106": [0.19444, 0.66786, 0, 0, 0.30556],
          "107": [0, 0.69444, 0, 0, 0.52778],
          "108": [0, 0.69444, 0, 0, 0.27778],
          "109": [0, 0.43056, 0, 0, 0.83334],
          "110": [0, 0.43056, 0, 0, 0.55556],
          "111": [0, 0.43056, 0, 0, 0.5],
          "112": [0.19444, 0.43056, 0, 0, 0.55556],
          "113": [0.19444, 0.43056, 0, 0, 0.52778],
          "114": [0, 0.43056, 0, 0, 0.39167],
          "115": [0, 0.43056, 0, 0, 0.39445],
          "116": [0, 0.61508, 0, 0, 0.38889],
          "117": [0, 0.43056, 0, 0, 0.55556],
          "118": [0, 0.43056, 0.01389, 0, 0.52778],
          "119": [0, 0.43056, 0.01389, 0, 0.72222],
          "120": [0, 0.43056, 0, 0, 0.52778],
          "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
          "122": [0, 0.43056, 0, 0, 0.44445],
          "123": [0.25, 0.75, 0, 0, 0.5],
          "124": [0.25, 0.75, 0, 0, 0.27778],
          "125": [0.25, 0.75, 0, 0, 0.5],
          "126": [0.35, 0.31786, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.76909],
          "167": [0.19444, 0.69444, 0, 0, 0.44445],
          "168": [0, 0.66786, 0, 0, 0.5],
          "172": [0, 0.43056, 0, 0, 0.66667],
          "176": [0, 0.69444, 0, 0, 0.75],
          "177": [0.08333, 0.58333, 0, 0, 0.77778],
          "182": [0.19444, 0.69444, 0, 0, 0.61111],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "198": [0, 0.68333, 0, 0, 0.90278],
          "215": [0.08333, 0.58333, 0, 0, 0.77778],
          "216": [0.04861, 0.73194, 0, 0, 0.77778],
          "223": [0, 0.69444, 0, 0, 0.5],
          "230": [0, 0.43056, 0, 0, 0.72222],
          "247": [0.08333, 0.58333, 0, 0, 0.77778],
          "248": [0.09722, 0.52778, 0, 0, 0.5],
          "305": [0, 0.43056, 0, 0, 0.27778],
          "338": [0, 0.68333, 0, 0, 1.01389],
          "339": [0, 0.43056, 0, 0, 0.77778],
          "567": [0.19444, 0.43056, 0, 0, 0.30556],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.62847, 0, 0, 0.5],
          "713": [0, 0.56778, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.66786, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.75],
          "732": [0, 0.66786, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.68333, 0, 0, 0.625],
          "916": [0, 0.68333, 0, 0, 0.83334],
          "920": [0, 0.68333, 0, 0, 0.77778],
          "923": [0, 0.68333, 0, 0, 0.69445],
          "926": [0, 0.68333, 0, 0, 0.66667],
          "928": [0, 0.68333, 0, 0, 0.75],
          "931": [0, 0.68333, 0, 0, 0.72222],
          "933": [0, 0.68333, 0, 0, 0.77778],
          "934": [0, 0.68333, 0, 0, 0.72222],
          "936": [0, 0.68333, 0, 0, 0.77778],
          "937": [0, 0.68333, 0, 0, 0.72222],
          "8211": [0, 0.43056, 0.02778, 0, 0.5],
          "8212": [0, 0.43056, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5],
          "8224": [0.19444, 0.69444, 0, 0, 0.44445],
          "8225": [0.19444, 0.69444, 0, 0, 0.44445],
          "8230": [0, 0.123, 0, 0, 1.172],
          "8242": [0, 0.55556, 0, 0, 0.275],
          "8407": [0, 0.71444, 0.15382, 0, 0.5],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8465": [0, 0.69444, 0, 0, 0.72222],
          "8467": [0, 0.69444, 0, 0.11111, 0.41667],
          "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
          "8476": [0, 0.69444, 0, 0, 0.72222],
          "8501": [0, 0.69444, 0, 0, 0.61111],
          "8592": [-0.13313, 0.36687, 0, 0, 1],
          "8593": [0.19444, 0.69444, 0, 0, 0.5],
          "8594": [-0.13313, 0.36687, 0, 0, 1],
          "8595": [0.19444, 0.69444, 0, 0, 0.5],
          "8596": [-0.13313, 0.36687, 0, 0, 1],
          "8597": [0.25, 0.75, 0, 0, 0.5],
          "8598": [0.19444, 0.69444, 0, 0, 1],
          "8599": [0.19444, 0.69444, 0, 0, 1],
          "8600": [0.19444, 0.69444, 0, 0, 1],
          "8601": [0.19444, 0.69444, 0, 0, 1],
          "8614": [0.011, 0.511, 0, 0, 1],
          "8617": [0.011, 0.511, 0, 0, 1.126],
          "8618": [0.011, 0.511, 0, 0, 1.126],
          "8636": [-0.13313, 0.36687, 0, 0, 1],
          "8637": [-0.13313, 0.36687, 0, 0, 1],
          "8640": [-0.13313, 0.36687, 0, 0, 1],
          "8641": [-0.13313, 0.36687, 0, 0, 1],
          "8652": [0.011, 0.671, 0, 0, 1],
          "8656": [-0.13313, 0.36687, 0, 0, 1],
          "8657": [0.19444, 0.69444, 0, 0, 0.61111],
          "8658": [-0.13313, 0.36687, 0, 0, 1],
          "8659": [0.19444, 0.69444, 0, 0, 0.61111],
          "8660": [-0.13313, 0.36687, 0, 0, 1],
          "8661": [0.25, 0.75, 0, 0, 0.61111],
          "8704": [0, 0.69444, 0, 0, 0.55556],
          "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
          "8707": [0, 0.69444, 0, 0, 0.55556],
          "8709": [0.05556, 0.75, 0, 0, 0.5],
          "8711": [0, 0.68333, 0, 0, 0.83334],
          "8712": [0.0391, 0.5391, 0, 0, 0.66667],
          "8715": [0.0391, 0.5391, 0, 0, 0.66667],
          "8722": [0.08333, 0.58333, 0, 0, 0.77778],
          "8723": [0.08333, 0.58333, 0, 0, 0.77778],
          "8725": [0.25, 0.75, 0, 0, 0.5],
          "8726": [0.25, 0.75, 0, 0, 0.5],
          "8727": [-0.03472, 0.46528, 0, 0, 0.5],
          "8728": [-0.05555, 0.44445, 0, 0, 0.5],
          "8729": [-0.05555, 0.44445, 0, 0, 0.5],
          "8730": [0.2, 0.8, 0, 0, 0.83334],
          "8733": [0, 0.43056, 0, 0, 0.77778],
          "8734": [0, 0.43056, 0, 0, 1],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.27778],
          "8741": [0.25, 0.75, 0, 0, 0.5],
          "8743": [0, 0.55556, 0, 0, 0.66667],
          "8744": [0, 0.55556, 0, 0, 0.66667],
          "8745": [0, 0.55556, 0, 0, 0.66667],
          "8746": [0, 0.55556, 0, 0, 0.66667],
          "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8768": [0.19444, 0.69444, 0, 0, 0.27778],
          "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8773": [-0.022, 0.589, 0, 0, 0.778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8784": [-0.133, 0.673, 0, 0, 0.778],
          "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8804": [0.13597, 0.63597, 0, 0, 0.77778],
          "8805": [0.13597, 0.63597, 0, 0, 0.77778],
          "8810": [0.0391, 0.5391, 0, 0, 1],
          "8811": [0.0391, 0.5391, 0, 0, 1],
          "8826": [0.0391, 0.5391, 0, 0, 0.77778],
          "8827": [0.0391, 0.5391, 0, 0, 0.77778],
          "8834": [0.0391, 0.5391, 0, 0, 0.77778],
          "8835": [0.0391, 0.5391, 0, 0, 0.77778],
          "8838": [0.13597, 0.63597, 0, 0, 0.77778],
          "8839": [0.13597, 0.63597, 0, 0, 0.77778],
          "8846": [0, 0.55556, 0, 0, 0.66667],
          "8849": [0.13597, 0.63597, 0, 0, 0.77778],
          "8850": [0.13597, 0.63597, 0, 0, 0.77778],
          "8851": [0, 0.55556, 0, 0, 0.66667],
          "8852": [0, 0.55556, 0, 0, 0.66667],
          "8853": [0.08333, 0.58333, 0, 0, 0.77778],
          "8854": [0.08333, 0.58333, 0, 0, 0.77778],
          "8855": [0.08333, 0.58333, 0, 0, 0.77778],
          "8856": [0.08333, 0.58333, 0, 0, 0.77778],
          "8857": [0.08333, 0.58333, 0, 0, 0.77778],
          "8866": [0, 0.69444, 0, 0, 0.61111],
          "8867": [0, 0.69444, 0, 0, 0.61111],
          "8868": [0, 0.69444, 0, 0, 0.77778],
          "8869": [0, 0.69444, 0, 0, 0.77778],
          "8872": [0.249, 0.75, 0, 0, 0.867],
          "8900": [-0.05555, 0.44445, 0, 0, 0.5],
          "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
          "8902": [-0.03472, 0.46528, 0, 0, 0.5],
          "8904": [0.005, 0.505, 0, 0, 0.9],
          "8942": [0.03, 0.903, 0, 0, 0.278],
          "8943": [-0.19, 0.313, 0, 0, 1.172],
          "8945": [-0.1, 0.823, 0, 0, 1.282],
          "8968": [0.25, 0.75, 0, 0, 0.44445],
          "8969": [0.25, 0.75, 0, 0, 0.44445],
          "8970": [0.25, 0.75, 0, 0, 0.44445],
          "8971": [0.25, 0.75, 0, 0, 0.44445],
          "8994": [-0.14236, 0.35764, 0, 0, 1],
          "8995": [-0.14236, 0.35764, 0, 0, 1],
          "9136": [0.244, 0.744, 0, 0, 0.412],
          "9137": [0.244, 0.745, 0, 0, 0.412],
          "9651": [0.19444, 0.69444, 0, 0, 0.88889],
          "9657": [-0.03472, 0.46528, 0, 0, 0.5],
          "9661": [0.19444, 0.69444, 0, 0, 0.88889],
          "9667": [-0.03472, 0.46528, 0, 0, 0.5],
          "9711": [0.19444, 0.69444, 0, 0, 1],
          "9824": [0.12963, 0.69444, 0, 0, 0.77778],
          "9825": [0.12963, 0.69444, 0, 0, 0.77778],
          "9826": [0.12963, 0.69444, 0, 0, 0.77778],
          "9827": [0.12963, 0.69444, 0, 0, 0.77778],
          "9837": [0, 0.75, 0, 0, 0.38889],
          "9838": [0.19444, 0.69444, 0, 0, 0.38889],
          "9839": [0.19444, 0.69444, 0, 0, 0.38889],
          "10216": [0.25, 0.75, 0, 0, 0.38889],
          "10217": [0.25, 0.75, 0, 0, 0.38889],
          "10222": [0.244, 0.744, 0, 0, 0.412],
          "10223": [0.244, 0.745, 0, 0, 0.412],
          "10229": [0.011, 0.511, 0, 0, 1.609],
          "10230": [0.011, 0.511, 0, 0, 1.638],
          "10231": [0.011, 0.511, 0, 0, 1.859],
          "10232": [0.024, 0.525, 0, 0, 1.609],
          "10233": [0.024, 0.525, 0, 0, 1.638],
          "10234": [0.024, 0.525, 0, 0, 1.858],
          "10236": [0.011, 0.511, 0, 0, 1.638],
          "10815": [0, 0.68333, 0, 0, 0.75],
          "10927": [0.13597, 0.63597, 0, 0, 0.77778],
          "10928": [0.13597, 0.63597, 0, 0, 0.77778],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Math-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.44444, 0, 0, 0.575],
          "49": [0, 0.44444, 0, 0, 0.575],
          "50": [0, 0.44444, 0, 0, 0.575],
          "51": [0.19444, 0.44444, 0, 0, 0.575],
          "52": [0.19444, 0.44444, 0, 0, 0.575],
          "53": [0.19444, 0.44444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0.19444, 0.44444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0.19444, 0.44444, 0, 0, 0.575],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0.04835, 0, 0.8664],
          "67": [0, 0.68611, 0.06979, 0, 0.81694],
          "68": [0, 0.68611, 0.03194, 0, 0.93812],
          "69": [0, 0.68611, 0.05451, 0, 0.81007],
          "70": [0, 0.68611, 0.15972, 0, 0.68889],
          "71": [0, 0.68611, 0, 0, 0.88673],
          "72": [0, 0.68611, 0.08229, 0, 0.98229],
          "73": [0, 0.68611, 0.07778, 0, 0.51111],
          "74": [0, 0.68611, 0.10069, 0, 0.63125],
          "75": [0, 0.68611, 0.06979, 0, 0.97118],
          "76": [0, 0.68611, 0, 0, 0.75555],
          "77": [0, 0.68611, 0.11424, 0, 1.14201],
          "78": [0, 0.68611, 0.11424, 0, 0.95034],
          "79": [0, 0.68611, 0.03194, 0, 0.83666],
          "80": [0, 0.68611, 0.15972, 0, 0.72309],
          "81": [0.19444, 0.68611, 0, 0, 0.86861],
          "82": [0, 0.68611, 0.00421, 0, 0.87235],
          "83": [0, 0.68611, 0.05382, 0, 0.69271],
          "84": [0, 0.68611, 0.15972, 0, 0.63663],
          "85": [0, 0.68611, 0.11424, 0, 0.80027],
          "86": [0, 0.68611, 0.25555, 0, 0.67778],
          "87": [0, 0.68611, 0.15972, 0, 1.09305],
          "88": [0, 0.68611, 0.07778, 0, 0.94722],
          "89": [0, 0.68611, 0.25555, 0, 0.67458],
          "90": [0, 0.68611, 0.06979, 0, 0.77257],
          "97": [0, 0.44444, 0, 0, 0.63287],
          "98": [0, 0.69444, 0, 0, 0.52083],
          "99": [0, 0.44444, 0, 0, 0.51342],
          "100": [0, 0.69444, 0, 0, 0.60972],
          "101": [0, 0.44444, 0, 0, 0.55361],
          "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
          "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
          "104": [0, 0.69444, 0, 0, 0.66759],
          "105": [0, 0.69326, 0, 0, 0.4048],
          "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
          "107": [0, 0.69444, 0.01852, 0, 0.6037],
          "108": [0, 0.69444, 0.0088, 0, 0.34815],
          "109": [0, 0.44444, 0, 0, 1.0324],
          "110": [0, 0.44444, 0, 0, 0.71296],
          "111": [0, 0.44444, 0, 0, 0.58472],
          "112": [0.19444, 0.44444, 0, 0, 0.60092],
          "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
          "114": [0, 0.44444, 0.03194, 0, 0.5287],
          "115": [0, 0.44444, 0, 0, 0.53125],
          "116": [0, 0.63492, 0, 0, 0.41528],
          "117": [0, 0.44444, 0, 0, 0.68102],
          "118": [0, 0.44444, 0.03704, 0, 0.56666],
          "119": [0, 0.44444, 0.02778, 0, 0.83148],
          "120": [0, 0.44444, 0, 0, 0.65903],
          "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
          "122": [0, 0.44444, 0.04213, 0, 0.55509],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68611, 0.15972, 0, 0.65694],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0.03194, 0, 0.86722],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0.07458, 0, 0.84125],
          "928": [0, 0.68611, 0.08229, 0, 0.98229],
          "931": [0, 0.68611, 0.05451, 0, 0.88507],
          "933": [0, 0.68611, 0.15972, 0, 0.67083],
          "934": [0, 0.68611, 0, 0, 0.76666],
          "936": [0, 0.68611, 0.11653, 0, 0.71402],
          "937": [0, 0.68611, 0.04835, 0, 0.8789],
          "945": [0, 0.44444, 0, 0, 0.76064],
          "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
          "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
          "948": [0, 0.69444, 0.03819, 0, 0.52222],
          "949": [0, 0.44444, 0, 0, 0.52882],
          "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
          "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
          "952": [0, 0.69444, 0.03194, 0, 0.5618],
          "953": [0, 0.44444, 0, 0, 0.41204],
          "954": [0, 0.44444, 0, 0, 0.66759],
          "955": [0, 0.69444, 0, 0, 0.67083],
          "956": [0.19444, 0.44444, 0, 0, 0.70787],
          "957": [0, 0.44444, 0.06898, 0, 0.57685],
          "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
          "959": [0, 0.44444, 0, 0, 0.58472],
          "960": [0, 0.44444, 0.03704, 0, 0.68241],
          "961": [0.19444, 0.44444, 0, 0, 0.6118],
          "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
          "963": [0, 0.44444, 0.03704, 0, 0.68588],
          "964": [0, 0.44444, 0.13472, 0, 0.52083],
          "965": [0, 0.44444, 0.03704, 0, 0.63055],
          "966": [0.19444, 0.44444, 0, 0, 0.74722],
          "967": [0.19444, 0.44444, 0, 0, 0.71805],
          "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
          "969": [0, 0.44444, 0.03704, 0, 0.71782],
          "977": [0, 0.69444, 0, 0, 0.69155],
          "981": [0.19444, 0.69444, 0, 0, 0.7125],
          "982": [0, 0.44444, 0.03194, 0, 0.975],
          "1009": [0.19444, 0.44444, 0, 0, 0.6118],
          "1013": [0, 0.44444, 0, 0, 0.48333],
          "57649": [0, 0.44444, 0, 0, 0.39352],
          "57911": [0.19444, 0.44444, 0, 0, 0.43889]
        },
        "Math-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.43056, 0, 0, 0.5],
          "49": [0, 0.43056, 0, 0, 0.5],
          "50": [0, 0.43056, 0, 0, 0.5],
          "51": [0.19444, 0.43056, 0, 0, 0.5],
          "52": [0.19444, 0.43056, 0, 0, 0.5],
          "53": [0.19444, 0.43056, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0.19444, 0.43056, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0.19444, 0.43056, 0, 0, 0.5],
          "65": [0, 0.68333, 0, 0.13889, 0.75],
          "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
          "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
          "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
          "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
          "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
          "71": [0, 0.68333, 0, 0.08334, 0.78625],
          "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
          "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
          "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
          "76": [0, 0.68333, 0, 0.02778, 0.68056],
          "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
          "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
          "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
          "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
          "82": [0, 0.68333, 0.00773, 0.08334, 0.75929],
          "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
          "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
          "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
          "86": [0, 0.68333, 0.22222, 0, 0.58333],
          "87": [0, 0.68333, 0.13889, 0, 0.94445],
          "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
          "89": [0, 0.68333, 0.22222, 0, 0.58056],
          "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
          "97": [0, 0.43056, 0, 0, 0.52859],
          "98": [0, 0.69444, 0, 0, 0.42917],
          "99": [0, 0.43056, 0, 0.05556, 0.43276],
          "100": [0, 0.69444, 0, 0.16667, 0.52049],
          "101": [0, 0.43056, 0, 0.05556, 0.46563],
          "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
          "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
          "104": [0, 0.69444, 0, 0, 0.57616],
          "105": [0, 0.65952, 0, 0, 0.34451],
          "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
          "107": [0, 0.69444, 0.03148, 0, 0.5206],
          "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
          "109": [0, 0.43056, 0, 0, 0.87801],
          "110": [0, 0.43056, 0, 0, 0.60023],
          "111": [0, 0.43056, 0, 0.05556, 0.48472],
          "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
          "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
          "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
          "115": [0, 0.43056, 0, 0.05556, 0.46875],
          "116": [0, 0.61508, 0, 0.08334, 0.36111],
          "117": [0, 0.43056, 0, 0.02778, 0.57246],
          "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
          "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
          "120": [0, 0.43056, 0, 0.02778, 0.57153],
          "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
          "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
          "916": [0, 0.68333, 0, 0.16667, 0.83334],
          "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "923": [0, 0.68333, 0, 0.16667, 0.69445],
          "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
          "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
          "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
          "934": [0, 0.68333, 0, 0.08334, 0.66667],
          "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
          "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
          "945": [0, 0.43056, 0.0037, 0.02778, 0.6397],
          "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
          "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
          "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
          "949": [0, 0.43056, 0, 0.08334, 0.46632],
          "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
          "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
          "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
          "953": [0, 0.43056, 0, 0.05556, 0.35394],
          "954": [0, 0.43056, 0, 0, 0.57616],
          "955": [0, 0.69444, 0, 0, 0.58334],
          "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
          "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
          "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
          "959": [0, 0.43056, 0, 0.05556, 0.48472],
          "960": [0, 0.43056, 0.03588, 0, 0.57003],
          "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
          "963": [0, 0.43056, 0.03588, 0, 0.57141],
          "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
          "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
          "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
          "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
          "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
          "969": [0, 0.43056, 0.03588, 0, 0.62245],
          "977": [0, 0.69444, 0, 0.08334, 0.59144],
          "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
          "982": [0, 0.43056, 0.02778, 0, 0.82813],
          "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "1013": [0, 0.43056, 0, 0.05556, 0.4059],
          "57649": [0, 0.43056, 0, 0.02778, 0.32246],
          "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
        },
        "SansSerif-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.36667],
          "34": [0, 0.69444, 0, 0, 0.55834],
          "35": [0.19444, 0.69444, 0, 0, 0.91667],
          "36": [0.05556, 0.75, 0, 0, 0.55],
          "37": [0.05556, 0.75, 0, 0, 1.02912],
          "38": [0, 0.69444, 0, 0, 0.83056],
          "39": [0, 0.69444, 0, 0, 0.30556],
          "40": [0.25, 0.75, 0, 0, 0.42778],
          "41": [0.25, 0.75, 0, 0, 0.42778],
          "42": [0, 0.75, 0, 0, 0.55],
          "43": [0.11667, 0.61667, 0, 0, 0.85556],
          "44": [0.10556, 0.13056, 0, 0, 0.30556],
          "45": [0, 0.45833, 0, 0, 0.36667],
          "46": [0, 0.13056, 0, 0, 0.30556],
          "47": [0.25, 0.75, 0, 0, 0.55],
          "48": [0, 0.69444, 0, 0, 0.55],
          "49": [0, 0.69444, 0, 0, 0.55],
          "50": [0, 0.69444, 0, 0, 0.55],
          "51": [0, 0.69444, 0, 0, 0.55],
          "52": [0, 0.69444, 0, 0, 0.55],
          "53": [0, 0.69444, 0, 0, 0.55],
          "54": [0, 0.69444, 0, 0, 0.55],
          "55": [0, 0.69444, 0, 0, 0.55],
          "56": [0, 0.69444, 0, 0, 0.55],
          "57": [0, 0.69444, 0, 0, 0.55],
          "58": [0, 0.45833, 0, 0, 0.30556],
          "59": [0.10556, 0.45833, 0, 0, 0.30556],
          "61": [-0.09375, 0.40625, 0, 0, 0.85556],
          "63": [0, 0.69444, 0, 0, 0.51945],
          "64": [0, 0.69444, 0, 0, 0.73334],
          "65": [0, 0.69444, 0, 0, 0.73334],
          "66": [0, 0.69444, 0, 0, 0.73334],
          "67": [0, 0.69444, 0, 0, 0.70278],
          "68": [0, 0.69444, 0, 0, 0.79445],
          "69": [0, 0.69444, 0, 0, 0.64167],
          "70": [0, 0.69444, 0, 0, 0.61111],
          "71": [0, 0.69444, 0, 0, 0.73334],
          "72": [0, 0.69444, 0, 0, 0.79445],
          "73": [0, 0.69444, 0, 0, 0.33056],
          "74": [0, 0.69444, 0, 0, 0.51945],
          "75": [0, 0.69444, 0, 0, 0.76389],
          "76": [0, 0.69444, 0, 0, 0.58056],
          "77": [0, 0.69444, 0, 0, 0.97778],
          "78": [0, 0.69444, 0, 0, 0.79445],
          "79": [0, 0.69444, 0, 0, 0.79445],
          "80": [0, 0.69444, 0, 0, 0.70278],
          "81": [0.10556, 0.69444, 0, 0, 0.79445],
          "82": [0, 0.69444, 0, 0, 0.70278],
          "83": [0, 0.69444, 0, 0, 0.61111],
          "84": [0, 0.69444, 0, 0, 0.73334],
          "85": [0, 0.69444, 0, 0, 0.76389],
          "86": [0, 0.69444, 0.01528, 0, 0.73334],
          "87": [0, 0.69444, 0.01528, 0, 1.03889],
          "88": [0, 0.69444, 0, 0, 0.73334],
          "89": [0, 0.69444, 0.0275, 0, 0.73334],
          "90": [0, 0.69444, 0, 0, 0.67223],
          "91": [0.25, 0.75, 0, 0, 0.34306],
          "93": [0.25, 0.75, 0, 0, 0.34306],
          "94": [0, 0.69444, 0, 0, 0.55],
          "95": [0.35, 0.10833, 0.03056, 0, 0.55],
          "97": [0, 0.45833, 0, 0, 0.525],
          "98": [0, 0.69444, 0, 0, 0.56111],
          "99": [0, 0.45833, 0, 0, 0.48889],
          "100": [0, 0.69444, 0, 0, 0.56111],
          "101": [0, 0.45833, 0, 0, 0.51111],
          "102": [0, 0.69444, 0.07639, 0, 0.33611],
          "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
          "104": [0, 0.69444, 0, 0, 0.56111],
          "105": [0, 0.69444, 0, 0, 0.25556],
          "106": [0.19444, 0.69444, 0, 0, 0.28611],
          "107": [0, 0.69444, 0, 0, 0.53056],
          "108": [0, 0.69444, 0, 0, 0.25556],
          "109": [0, 0.45833, 0, 0, 0.86667],
          "110": [0, 0.45833, 0, 0, 0.56111],
          "111": [0, 0.45833, 0, 0, 0.55],
          "112": [0.19444, 0.45833, 0, 0, 0.56111],
          "113": [0.19444, 0.45833, 0, 0, 0.56111],
          "114": [0, 0.45833, 0.01528, 0, 0.37222],
          "115": [0, 0.45833, 0, 0, 0.42167],
          "116": [0, 0.58929, 0, 0, 0.40417],
          "117": [0, 0.45833, 0, 0, 0.56111],
          "118": [0, 0.45833, 0.01528, 0, 0.5],
          "119": [0, 0.45833, 0.01528, 0, 0.74445],
          "120": [0, 0.45833, 0, 0, 0.5],
          "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
          "122": [0, 0.45833, 0, 0, 0.47639],
          "126": [0.35, 0.34444, 0, 0, 0.55],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0, 0, 0.55],
          "176": [0, 0.69444, 0, 0, 0.73334],
          "180": [0, 0.69444, 0, 0, 0.55],
          "184": [0.17014, 0, 0, 0, 0.48889],
          "305": [0, 0.45833, 0, 0, 0.25556],
          "567": [0.19444, 0.45833, 0, 0, 0.28611],
          "710": [0, 0.69444, 0, 0, 0.55],
          "711": [0, 0.63542, 0, 0, 0.55],
          "713": [0, 0.63778, 0, 0, 0.55],
          "728": [0, 0.69444, 0, 0, 0.55],
          "729": [0, 0.69444, 0, 0, 0.30556],
          "730": [0, 0.69444, 0, 0, 0.73334],
          "732": [0, 0.69444, 0, 0, 0.55],
          "733": [0, 0.69444, 0, 0, 0.55],
          "915": [0, 0.69444, 0, 0, 0.58056],
          "916": [0, 0.69444, 0, 0, 0.91667],
          "920": [0, 0.69444, 0, 0, 0.85556],
          "923": [0, 0.69444, 0, 0, 0.67223],
          "926": [0, 0.69444, 0, 0, 0.73334],
          "928": [0, 0.69444, 0, 0, 0.79445],
          "931": [0, 0.69444, 0, 0, 0.79445],
          "933": [0, 0.69444, 0, 0, 0.85556],
          "934": [0, 0.69444, 0, 0, 0.79445],
          "936": [0, 0.69444, 0, 0, 0.85556],
          "937": [0, 0.69444, 0, 0, 0.79445],
          "8211": [0, 0.45833, 0.03056, 0, 0.55],
          "8212": [0, 0.45833, 0.03056, 0, 1.10001],
          "8216": [0, 0.69444, 0, 0, 0.30556],
          "8217": [0, 0.69444, 0, 0, 0.30556],
          "8220": [0, 0.69444, 0, 0, 0.55834],
          "8221": [0, 0.69444, 0, 0, 0.55834]
        },
        "SansSerif-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.05733, 0, 0.31945],
          "34": [0, 0.69444, 0.00316, 0, 0.5],
          "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
          "36": [0.05556, 0.75, 0.11156, 0, 0.5],
          "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
          "38": [0, 0.69444, 0.03058, 0, 0.75834],
          "39": [0, 0.69444, 0.07816, 0, 0.27778],
          "40": [0.25, 0.75, 0.13164, 0, 0.38889],
          "41": [0.25, 0.75, 0.02536, 0, 0.38889],
          "42": [0, 0.75, 0.11775, 0, 0.5],
          "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0.01946, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0.13164, 0, 0.5],
          "48": [0, 0.65556, 0.11156, 0, 0.5],
          "49": [0, 0.65556, 0.11156, 0, 0.5],
          "50": [0, 0.65556, 0.11156, 0, 0.5],
          "51": [0, 0.65556, 0.11156, 0, 0.5],
          "52": [0, 0.65556, 0.11156, 0, 0.5],
          "53": [0, 0.65556, 0.11156, 0, 0.5],
          "54": [0, 0.65556, 0.11156, 0, 0.5],
          "55": [0, 0.65556, 0.11156, 0, 0.5],
          "56": [0, 0.65556, 0.11156, 0, 0.5],
          "57": [0, 0.65556, 0.11156, 0, 0.5],
          "58": [0, 0.44444, 0.02502, 0, 0.27778],
          "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
          "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
          "63": [0, 0.69444, 0.11809, 0, 0.47222],
          "64": [0, 0.69444, 0.07555, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0.08293, 0, 0.66667],
          "67": [0, 0.69444, 0.11983, 0, 0.63889],
          "68": [0, 0.69444, 0.07555, 0, 0.72223],
          "69": [0, 0.69444, 0.11983, 0, 0.59722],
          "70": [0, 0.69444, 0.13372, 0, 0.56945],
          "71": [0, 0.69444, 0.11983, 0, 0.66667],
          "72": [0, 0.69444, 0.08094, 0, 0.70834],
          "73": [0, 0.69444, 0.13372, 0, 0.27778],
          "74": [0, 0.69444, 0.08094, 0, 0.47222],
          "75": [0, 0.69444, 0.11983, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0.08094, 0, 0.875],
          "78": [0, 0.69444, 0.08094, 0, 0.70834],
          "79": [0, 0.69444, 0.07555, 0, 0.73611],
          "80": [0, 0.69444, 0.08293, 0, 0.63889],
          "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
          "82": [0, 0.69444, 0.08293, 0, 0.64584],
          "83": [0, 0.69444, 0.09205, 0, 0.55556],
          "84": [0, 0.69444, 0.13372, 0, 0.68056],
          "85": [0, 0.69444, 0.08094, 0, 0.6875],
          "86": [0, 0.69444, 0.1615, 0, 0.66667],
          "87": [0, 0.69444, 0.1615, 0, 0.94445],
          "88": [0, 0.69444, 0.13372, 0, 0.66667],
          "89": [0, 0.69444, 0.17261, 0, 0.66667],
          "90": [0, 0.69444, 0.11983, 0, 0.61111],
          "91": [0.25, 0.75, 0.15942, 0, 0.28889],
          "93": [0.25, 0.75, 0.08719, 0, 0.28889],
          "94": [0, 0.69444, 0.0799, 0, 0.5],
          "95": [0.35, 0.09444, 0.08616, 0, 0.5],
          "97": [0, 0.44444, 0.00981, 0, 0.48056],
          "98": [0, 0.69444, 0.03057, 0, 0.51667],
          "99": [0, 0.44444, 0.08336, 0, 0.44445],
          "100": [0, 0.69444, 0.09483, 0, 0.51667],
          "101": [0, 0.44444, 0.06778, 0, 0.44445],
          "102": [0, 0.69444, 0.21705, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
          "104": [0, 0.69444, 0.01778, 0, 0.51667],
          "105": [0, 0.67937, 0.09718, 0, 0.23889],
          "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
          "107": [0, 0.69444, 0.08336, 0, 0.48889],
          "108": [0, 0.69444, 0.09483, 0, 0.23889],
          "109": [0, 0.44444, 0.01778, 0, 0.79445],
          "110": [0, 0.44444, 0.01778, 0, 0.51667],
          "111": [0, 0.44444, 0.06613, 0, 0.5],
          "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
          "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
          "114": [0, 0.44444, 0.10836, 0, 0.34167],
          "115": [0, 0.44444, 0.0778, 0, 0.38333],
          "116": [0, 0.57143, 0.07225, 0, 0.36111],
          "117": [0, 0.44444, 0.04169, 0, 0.51667],
          "118": [0, 0.44444, 0.10836, 0, 0.46111],
          "119": [0, 0.44444, 0.10836, 0, 0.68334],
          "120": [0, 0.44444, 0.09169, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
          "122": [0, 0.44444, 0.08752, 0, 0.43472],
          "126": [0.35, 0.32659, 0.08826, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0.06385, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.73752],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0.04169, 0, 0.23889],
          "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
          "710": [0, 0.69444, 0.0799, 0, 0.5],
          "711": [0, 0.63194, 0.08432, 0, 0.5],
          "713": [0, 0.60889, 0.08776, 0, 0.5],
          "714": [0, 0.69444, 0.09205, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0.09483, 0, 0.5],
          "729": [0, 0.67937, 0.07774, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.73752],
          "732": [0, 0.67659, 0.08826, 0, 0.5],
          "733": [0, 0.69444, 0.09205, 0, 0.5],
          "915": [0, 0.69444, 0.13372, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0.07555, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0.12816, 0, 0.66667],
          "928": [0, 0.69444, 0.08094, 0, 0.70834],
          "931": [0, 0.69444, 0.11983, 0, 0.72222],
          "933": [0, 0.69444, 0.09031, 0, 0.77778],
          "934": [0, 0.69444, 0.04603, 0, 0.72222],
          "936": [0, 0.69444, 0.09031, 0, 0.77778],
          "937": [0, 0.69444, 0.08293, 0, 0.72222],
          "8211": [0, 0.44444, 0.08616, 0, 0.5],
          "8212": [0, 0.44444, 0.08616, 0, 1],
          "8216": [0, 0.69444, 0.07816, 0, 0.27778],
          "8217": [0, 0.69444, 0.07816, 0, 0.27778],
          "8220": [0, 0.69444, 0.14205, 0, 0.5],
          "8221": [0, 0.69444, 0.00316, 0, 0.5]
        },
        "SansSerif-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.31945],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.75834],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.65556, 0, 0, 0.5],
          "49": [0, 0.65556, 0, 0, 0.5],
          "50": [0, 0.65556, 0, 0, 0.5],
          "51": [0, 0.65556, 0, 0, 0.5],
          "52": [0, 0.65556, 0, 0, 0.5],
          "53": [0, 0.65556, 0, 0, 0.5],
          "54": [0, 0.65556, 0, 0, 0.5],
          "55": [0, 0.65556, 0, 0, 0.5],
          "56": [0, 0.65556, 0, 0, 0.5],
          "57": [0, 0.65556, 0, 0, 0.5],
          "58": [0, 0.44444, 0, 0, 0.27778],
          "59": [0.125, 0.44444, 0, 0, 0.27778],
          "61": [-0.13, 0.37, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0, 0, 0.66667],
          "67": [0, 0.69444, 0, 0, 0.63889],
          "68": [0, 0.69444, 0, 0, 0.72223],
          "69": [0, 0.69444, 0, 0, 0.59722],
          "70": [0, 0.69444, 0, 0, 0.56945],
          "71": [0, 0.69444, 0, 0, 0.66667],
          "72": [0, 0.69444, 0, 0, 0.70834],
          "73": [0, 0.69444, 0, 0, 0.27778],
          "74": [0, 0.69444, 0, 0, 0.47222],
          "75": [0, 0.69444, 0, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0, 0, 0.875],
          "78": [0, 0.69444, 0, 0, 0.70834],
          "79": [0, 0.69444, 0, 0, 0.73611],
          "80": [0, 0.69444, 0, 0, 0.63889],
          "81": [0.125, 0.69444, 0, 0, 0.73611],
          "82": [0, 0.69444, 0, 0, 0.64584],
          "83": [0, 0.69444, 0, 0, 0.55556],
          "84": [0, 0.69444, 0, 0, 0.68056],
          "85": [0, 0.69444, 0, 0, 0.6875],
          "86": [0, 0.69444, 0.01389, 0, 0.66667],
          "87": [0, 0.69444, 0.01389, 0, 0.94445],
          "88": [0, 0.69444, 0, 0, 0.66667],
          "89": [0, 0.69444, 0.025, 0, 0.66667],
          "90": [0, 0.69444, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.28889],
          "93": [0.25, 0.75, 0, 0, 0.28889],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.35, 0.09444, 0.02778, 0, 0.5],
          "97": [0, 0.44444, 0, 0, 0.48056],
          "98": [0, 0.69444, 0, 0, 0.51667],
          "99": [0, 0.44444, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.51667],
          "101": [0, 0.44444, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.06944, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.51667],
          "105": [0, 0.67937, 0, 0, 0.23889],
          "106": [0.19444, 0.67937, 0, 0, 0.26667],
          "107": [0, 0.69444, 0, 0, 0.48889],
          "108": [0, 0.69444, 0, 0, 0.23889],
          "109": [0, 0.44444, 0, 0, 0.79445],
          "110": [0, 0.44444, 0, 0, 0.51667],
          "111": [0, 0.44444, 0, 0, 0.5],
          "112": [0.19444, 0.44444, 0, 0, 0.51667],
          "113": [0.19444, 0.44444, 0, 0, 0.51667],
          "114": [0, 0.44444, 0.01389, 0, 0.34167],
          "115": [0, 0.44444, 0, 0, 0.38333],
          "116": [0, 0.57143, 0, 0, 0.36111],
          "117": [0, 0.44444, 0, 0, 0.51667],
          "118": [0, 0.44444, 0.01389, 0, 0.46111],
          "119": [0, 0.44444, 0.01389, 0, 0.68334],
          "120": [0, 0.44444, 0, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
          "122": [0, 0.44444, 0, 0, 0.43472],
          "126": [0.35, 0.32659, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.66667],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0, 0, 0.23889],
          "567": [0.19444, 0.44444, 0, 0, 0.26667],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.63194, 0, 0, 0.5],
          "713": [0, 0.60889, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.67937, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.66667],
          "732": [0, 0.67659, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.69444, 0, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0, 0, 0.66667],
          "928": [0, 0.69444, 0, 0, 0.70834],
          "931": [0, 0.69444, 0, 0, 0.72222],
          "933": [0, 0.69444, 0, 0, 0.77778],
          "934": [0, 0.69444, 0, 0, 0.72222],
          "936": [0, 0.69444, 0, 0, 0.77778],
          "937": [0, 0.69444, 0, 0, 0.72222],
          "8211": [0, 0.44444, 0.02778, 0, 0.5],
          "8212": [0, 0.44444, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5]
        },
        "Script-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.7, 0.22925, 0, 0.80253],
          "66": [0, 0.7, 0.04087, 0, 0.90757],
          "67": [0, 0.7, 0.1689, 0, 0.66619],
          "68": [0, 0.7, 0.09371, 0, 0.77443],
          "69": [0, 0.7, 0.18583, 0, 0.56162],
          "70": [0, 0.7, 0.13634, 0, 0.89544],
          "71": [0, 0.7, 0.17322, 0, 0.60961],
          "72": [0, 0.7, 0.29694, 0, 0.96919],
          "73": [0, 0.7, 0.19189, 0, 0.80907],
          "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
          "75": [0, 0.7, 0.31259, 0, 0.91364],
          "76": [0, 0.7, 0.19189, 0, 0.87373],
          "77": [0, 0.7, 0.15981, 0, 1.08031],
          "78": [0, 0.7, 0.3525, 0, 0.9015],
          "79": [0, 0.7, 0.08078, 0, 0.73787],
          "80": [0, 0.7, 0.08078, 0, 1.01262],
          "81": [0, 0.7, 0.03305, 0, 0.88282],
          "82": [0, 0.7, 0.06259, 0, 0.85],
          "83": [0, 0.7, 0.19189, 0, 0.86767],
          "84": [0, 0.7, 0.29087, 0, 0.74697],
          "85": [0, 0.7, 0.25815, 0, 0.79996],
          "86": [0, 0.7, 0.27523, 0, 0.62204],
          "87": [0, 0.7, 0.27523, 0, 0.80532],
          "88": [0, 0.7, 0.26006, 0, 0.94445],
          "89": [0, 0.7, 0.2939, 0, 0.70961],
          "90": [0, 0.7, 0.24037, 0, 0.8212],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Size1-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.35001, 0.85, 0, 0, 0.45834],
          "41": [0.35001, 0.85, 0, 0, 0.45834],
          "47": [0.35001, 0.85, 0, 0, 0.57778],
          "91": [0.35001, 0.85, 0, 0, 0.41667],
          "92": [0.35001, 0.85, 0, 0, 0.57778],
          "93": [0.35001, 0.85, 0, 0, 0.41667],
          "123": [0.35001, 0.85, 0, 0, 0.58334],
          "125": [0.35001, 0.85, 0, 0, 0.58334],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.72222, 0, 0, 0.55556],
          "732": [0, 0.72222, 0, 0, 0.55556],
          "770": [0, 0.72222, 0, 0, 0.55556],
          "771": [0, 0.72222, 0, 0, 0.55556],
          "8214": [-0.00099, 0.601, 0, 0, 0.77778],
          "8593": [0.00001, 0.6, 0, 0, 0.66667],
          "8595": [0.00001, 0.6, 0, 0, 0.66667],
          "8657": [0.00001, 0.6, 0, 0, 0.77778],
          "8659": [0.00001, 0.6, 0, 0, 0.77778],
          "8719": [0.25001, 0.75, 0, 0, 0.94445],
          "8720": [0.25001, 0.75, 0, 0, 0.94445],
          "8721": [0.25001, 0.75, 0, 0, 1.05556],
          "8730": [0.35001, 0.85, 0, 0, 1],
          "8739": [-0.00599, 0.606, 0, 0, 0.33333],
          "8741": [-0.00599, 0.606, 0, 0, 0.55556],
          "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8896": [0.25001, 0.75, 0, 0, 0.83334],
          "8897": [0.25001, 0.75, 0, 0, 0.83334],
          "8898": [0.25001, 0.75, 0, 0, 0.83334],
          "8899": [0.25001, 0.75, 0, 0, 0.83334],
          "8968": [0.35001, 0.85, 0, 0, 0.47222],
          "8969": [0.35001, 0.85, 0, 0, 0.47222],
          "8970": [0.35001, 0.85, 0, 0, 0.47222],
          "8971": [0.35001, 0.85, 0, 0, 0.47222],
          "9168": [-0.00099, 0.601, 0, 0, 0.66667],
          "10216": [0.35001, 0.85, 0, 0, 0.47222],
          "10217": [0.35001, 0.85, 0, 0, 0.47222],
          "10752": [0.25001, 0.75, 0, 0, 1.11111],
          "10753": [0.25001, 0.75, 0, 0, 1.11111],
          "10754": [0.25001, 0.75, 0, 0, 1.11111],
          "10756": [0.25001, 0.75, 0, 0, 0.83334],
          "10758": [0.25001, 0.75, 0, 0, 0.83334]
        },
        "Size2-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.65002, 1.15, 0, 0, 0.59722],
          "41": [0.65002, 1.15, 0, 0, 0.59722],
          "47": [0.65002, 1.15, 0, 0, 0.81111],
          "91": [0.65002, 1.15, 0, 0, 0.47222],
          "92": [0.65002, 1.15, 0, 0, 0.81111],
          "93": [0.65002, 1.15, 0, 0, 0.47222],
          "123": [0.65002, 1.15, 0, 0, 0.66667],
          "125": [0.65002, 1.15, 0, 0, 0.66667],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1],
          "732": [0, 0.75, 0, 0, 1],
          "770": [0, 0.75, 0, 0, 1],
          "771": [0, 0.75, 0, 0, 1],
          "8719": [0.55001, 1.05, 0, 0, 1.27778],
          "8720": [0.55001, 1.05, 0, 0, 1.27778],
          "8721": [0.55001, 1.05, 0, 0, 1.44445],
          "8730": [0.65002, 1.15, 0, 0, 1],
          "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8896": [0.55001, 1.05, 0, 0, 1.11111],
          "8897": [0.55001, 1.05, 0, 0, 1.11111],
          "8898": [0.55001, 1.05, 0, 0, 1.11111],
          "8899": [0.55001, 1.05, 0, 0, 1.11111],
          "8968": [0.65002, 1.15, 0, 0, 0.52778],
          "8969": [0.65002, 1.15, 0, 0, 0.52778],
          "8970": [0.65002, 1.15, 0, 0, 0.52778],
          "8971": [0.65002, 1.15, 0, 0, 0.52778],
          "10216": [0.65002, 1.15, 0, 0, 0.61111],
          "10217": [0.65002, 1.15, 0, 0, 0.61111],
          "10752": [0.55001, 1.05, 0, 0, 1.51112],
          "10753": [0.55001, 1.05, 0, 0, 1.51112],
          "10754": [0.55001, 1.05, 0, 0, 1.51112],
          "10756": [0.55001, 1.05, 0, 0, 1.11111],
          "10758": [0.55001, 1.05, 0, 0, 1.11111]
        },
        "Size3-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.95003, 1.45, 0, 0, 0.73611],
          "41": [0.95003, 1.45, 0, 0, 0.73611],
          "47": [0.95003, 1.45, 0, 0, 1.04445],
          "91": [0.95003, 1.45, 0, 0, 0.52778],
          "92": [0.95003, 1.45, 0, 0, 1.04445],
          "93": [0.95003, 1.45, 0, 0, 0.52778],
          "123": [0.95003, 1.45, 0, 0, 0.75],
          "125": [0.95003, 1.45, 0, 0, 0.75],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1.44445],
          "732": [0, 0.75, 0, 0, 1.44445],
          "770": [0, 0.75, 0, 0, 1.44445],
          "771": [0, 0.75, 0, 0, 1.44445],
          "8730": [0.95003, 1.45, 0, 0, 1],
          "8968": [0.95003, 1.45, 0, 0, 0.58334],
          "8969": [0.95003, 1.45, 0, 0, 0.58334],
          "8970": [0.95003, 1.45, 0, 0, 0.58334],
          "8971": [0.95003, 1.45, 0, 0, 0.58334],
          "10216": [0.95003, 1.45, 0, 0, 0.75],
          "10217": [0.95003, 1.45, 0, 0, 0.75]
        },
        "Size4-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [1.25003, 1.75, 0, 0, 0.79167],
          "41": [1.25003, 1.75, 0, 0, 0.79167],
          "47": [1.25003, 1.75, 0, 0, 1.27778],
          "91": [1.25003, 1.75, 0, 0, 0.58334],
          "92": [1.25003, 1.75, 0, 0, 1.27778],
          "93": [1.25003, 1.75, 0, 0, 0.58334],
          "123": [1.25003, 1.75, 0, 0, 0.80556],
          "125": [1.25003, 1.75, 0, 0, 0.80556],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.825, 0, 0, 1.8889],
          "732": [0, 0.825, 0, 0, 1.8889],
          "770": [0, 0.825, 0, 0, 1.8889],
          "771": [0, 0.825, 0, 0, 1.8889],
          "8730": [1.25003, 1.75, 0, 0, 1],
          "8968": [1.25003, 1.75, 0, 0, 0.63889],
          "8969": [1.25003, 1.75, 0, 0, 0.63889],
          "8970": [1.25003, 1.75, 0, 0, 0.63889],
          "8971": [1.25003, 1.75, 0, 0, 0.63889],
          "9115": [0.64502, 1.155, 0, 0, 0.875],
          "9116": [0.00001, 0.6, 0, 0, 0.875],
          "9117": [0.64502, 1.155, 0, 0, 0.875],
          "9118": [0.64502, 1.155, 0, 0, 0.875],
          "9119": [0.00001, 0.6, 0, 0, 0.875],
          "9120": [0.64502, 1.155, 0, 0, 0.875],
          "9121": [0.64502, 1.155, 0, 0, 0.66667],
          "9122": [-0.00099, 0.601, 0, 0, 0.66667],
          "9123": [0.64502, 1.155, 0, 0, 0.66667],
          "9124": [0.64502, 1.155, 0, 0, 0.66667],
          "9125": [-0.00099, 0.601, 0, 0, 0.66667],
          "9126": [0.64502, 1.155, 0, 0, 0.66667],
          "9127": [0.00001, 0.9, 0, 0, 0.88889],
          "9128": [0.65002, 1.15, 0, 0, 0.88889],
          "9129": [0.90001, 0, 0, 0, 0.88889],
          "9130": [0, 0.3, 0, 0, 0.88889],
          "9131": [0.00001, 0.9, 0, 0, 0.88889],
          "9132": [0.65002, 1.15, 0, 0, 0.88889],
          "9133": [0.90001, 0, 0, 0, 0.88889],
          "9143": [0.88502, 0.915, 0, 0, 1.05556],
          "10216": [1.25003, 1.75, 0, 0, 0.80556],
          "10217": [1.25003, 1.75, 0, 0, 0.80556],
          "57344": [-0.00499, 0.605, 0, 0, 1.05556],
          "57345": [-0.00499, 0.605, 0, 0, 1.05556],
          "57680": [0, 0.12, 0, 0, 0.45],
          "57681": [0, 0.12, 0, 0, 0.45],
          "57682": [0, 0.12, 0, 0, 0.45],
          "57683": [0, 0.12, 0, 0, 0.45]
        },
        "Typewriter-Regular": {
          "32": [0, 0, 0, 0, 0.525],
          "33": [0, 0.61111, 0, 0, 0.525],
          "34": [0, 0.61111, 0, 0, 0.525],
          "35": [0, 0.61111, 0, 0, 0.525],
          "36": [0.08333, 0.69444, 0, 0, 0.525],
          "37": [0.08333, 0.69444, 0, 0, 0.525],
          "38": [0, 0.61111, 0, 0, 0.525],
          "39": [0, 0.61111, 0, 0, 0.525],
          "40": [0.08333, 0.69444, 0, 0, 0.525],
          "41": [0.08333, 0.69444, 0, 0, 0.525],
          "42": [0, 0.52083, 0, 0, 0.525],
          "43": [-0.08056, 0.53055, 0, 0, 0.525],
          "44": [0.13889, 0.125, 0, 0, 0.525],
          "45": [-0.08056, 0.53055, 0, 0, 0.525],
          "46": [0, 0.125, 0, 0, 0.525],
          "47": [0.08333, 0.69444, 0, 0, 0.525],
          "48": [0, 0.61111, 0, 0, 0.525],
          "49": [0, 0.61111, 0, 0, 0.525],
          "50": [0, 0.61111, 0, 0, 0.525],
          "51": [0, 0.61111, 0, 0, 0.525],
          "52": [0, 0.61111, 0, 0, 0.525],
          "53": [0, 0.61111, 0, 0, 0.525],
          "54": [0, 0.61111, 0, 0, 0.525],
          "55": [0, 0.61111, 0, 0, 0.525],
          "56": [0, 0.61111, 0, 0, 0.525],
          "57": [0, 0.61111, 0, 0, 0.525],
          "58": [0, 0.43056, 0, 0, 0.525],
          "59": [0.13889, 0.43056, 0, 0, 0.525],
          "60": [-0.05556, 0.55556, 0, 0, 0.525],
          "61": [-0.19549, 0.41562, 0, 0, 0.525],
          "62": [-0.05556, 0.55556, 0, 0, 0.525],
          "63": [0, 0.61111, 0, 0, 0.525],
          "64": [0, 0.61111, 0, 0, 0.525],
          "65": [0, 0.61111, 0, 0, 0.525],
          "66": [0, 0.61111, 0, 0, 0.525],
          "67": [0, 0.61111, 0, 0, 0.525],
          "68": [0, 0.61111, 0, 0, 0.525],
          "69": [0, 0.61111, 0, 0, 0.525],
          "70": [0, 0.61111, 0, 0, 0.525],
          "71": [0, 0.61111, 0, 0, 0.525],
          "72": [0, 0.61111, 0, 0, 0.525],
          "73": [0, 0.61111, 0, 0, 0.525],
          "74": [0, 0.61111, 0, 0, 0.525],
          "75": [0, 0.61111, 0, 0, 0.525],
          "76": [0, 0.61111, 0, 0, 0.525],
          "77": [0, 0.61111, 0, 0, 0.525],
          "78": [0, 0.61111, 0, 0, 0.525],
          "79": [0, 0.61111, 0, 0, 0.525],
          "80": [0, 0.61111, 0, 0, 0.525],
          "81": [0.13889, 0.61111, 0, 0, 0.525],
          "82": [0, 0.61111, 0, 0, 0.525],
          "83": [0, 0.61111, 0, 0, 0.525],
          "84": [0, 0.61111, 0, 0, 0.525],
          "85": [0, 0.61111, 0, 0, 0.525],
          "86": [0, 0.61111, 0, 0, 0.525],
          "87": [0, 0.61111, 0, 0, 0.525],
          "88": [0, 0.61111, 0, 0, 0.525],
          "89": [0, 0.61111, 0, 0, 0.525],
          "90": [0, 0.61111, 0, 0, 0.525],
          "91": [0.08333, 0.69444, 0, 0, 0.525],
          "92": [0.08333, 0.69444, 0, 0, 0.525],
          "93": [0.08333, 0.69444, 0, 0, 0.525],
          "94": [0, 0.61111, 0, 0, 0.525],
          "95": [0.09514, 0, 0, 0, 0.525],
          "96": [0, 0.61111, 0, 0, 0.525],
          "97": [0, 0.43056, 0, 0, 0.525],
          "98": [0, 0.61111, 0, 0, 0.525],
          "99": [0, 0.43056, 0, 0, 0.525],
          "100": [0, 0.61111, 0, 0, 0.525],
          "101": [0, 0.43056, 0, 0, 0.525],
          "102": [0, 0.61111, 0, 0, 0.525],
          "103": [0.22222, 0.43056, 0, 0, 0.525],
          "104": [0, 0.61111, 0, 0, 0.525],
          "105": [0, 0.61111, 0, 0, 0.525],
          "106": [0.22222, 0.61111, 0, 0, 0.525],
          "107": [0, 0.61111, 0, 0, 0.525],
          "108": [0, 0.61111, 0, 0, 0.525],
          "109": [0, 0.43056, 0, 0, 0.525],
          "110": [0, 0.43056, 0, 0, 0.525],
          "111": [0, 0.43056, 0, 0, 0.525],
          "112": [0.22222, 0.43056, 0, 0, 0.525],
          "113": [0.22222, 0.43056, 0, 0, 0.525],
          "114": [0, 0.43056, 0, 0, 0.525],
          "115": [0, 0.43056, 0, 0, 0.525],
          "116": [0, 0.55358, 0, 0, 0.525],
          "117": [0, 0.43056, 0, 0, 0.525],
          "118": [0, 0.43056, 0, 0, 0.525],
          "119": [0, 0.43056, 0, 0, 0.525],
          "120": [0, 0.43056, 0, 0, 0.525],
          "121": [0.22222, 0.43056, 0, 0, 0.525],
          "122": [0, 0.43056, 0, 0, 0.525],
          "123": [0.08333, 0.69444, 0, 0, 0.525],
          "124": [0.08333, 0.69444, 0, 0, 0.525],
          "125": [0.08333, 0.69444, 0, 0, 0.525],
          "126": [0, 0.61111, 0, 0, 0.525],
          "127": [0, 0.61111, 0, 0, 0.525],
          "160": [0, 0, 0, 0, 0.525],
          "176": [0, 0.61111, 0, 0, 0.525],
          "184": [0.19445, 0, 0, 0, 0.525],
          "305": [0, 0.43056, 0, 0, 0.525],
          "567": [0.22222, 0.43056, 0, 0, 0.525],
          "711": [0, 0.56597, 0, 0, 0.525],
          "713": [0, 0.56555, 0, 0, 0.525],
          "714": [0, 0.61111, 0, 0, 0.525],
          "715": [0, 0.61111, 0, 0, 0.525],
          "728": [0, 0.61111, 0, 0, 0.525],
          "730": [0, 0.61111, 0, 0, 0.525],
          "770": [0, 0.61111, 0, 0, 0.525],
          "771": [0, 0.61111, 0, 0, 0.525],
          "776": [0, 0.61111, 0, 0, 0.525],
          "915": [0, 0.61111, 0, 0, 0.525],
          "916": [0, 0.61111, 0, 0, 0.525],
          "920": [0, 0.61111, 0, 0, 0.525],
          "923": [0, 0.61111, 0, 0, 0.525],
          "926": [0, 0.61111, 0, 0, 0.525],
          "928": [0, 0.61111, 0, 0, 0.525],
          "931": [0, 0.61111, 0, 0, 0.525],
          "933": [0, 0.61111, 0, 0, 0.525],
          "934": [0, 0.61111, 0, 0, 0.525],
          "936": [0, 0.61111, 0, 0, 0.525],
          "937": [0, 0.61111, 0, 0, 0.525],
          "8216": [0, 0.61111, 0, 0, 0.525],
          "8217": [0, 0.61111, 0, 0, 0.525],
          "8242": [0, 0.61111, 0, 0, 0.525],
          "9251": [0.11111, 0.21944, 0, 0, 0.525]
        }
      };
      const sigmasAndXis = {
        slant: [0.25, 0.25, 0.25],
        space: [0, 0, 0],
        stretch: [0, 0, 0],
        shrink: [0, 0, 0],
        xHeight: [0.431, 0.431, 0.431],
        quad: [1, 1.171, 1.472],
        extraSpace: [0, 0, 0],
        num1: [0.677, 0.732, 0.925],
        num2: [0.394, 0.384, 0.387],
        num3: [0.444, 0.471, 0.504],
        denom1: [0.686, 0.752, 1.025],
        denom2: [0.345, 0.344, 0.532],
        sup1: [0.413, 0.503, 0.504],
        sup2: [0.363, 0.431, 0.404],
        sup3: [0.289, 0.286, 0.294],
        sub1: [0.15, 0.143, 0.2],
        sub2: [0.247, 0.286, 0.4],
        supDrop: [0.386, 0.353, 0.494],
        subDrop: [0.05, 0.071, 0.1],
        delim1: [2.39, 1.7, 1.98],
        delim2: [1.01, 1.157, 1.42],
        axisHeight: [0.25, 0.25, 0.25],
        defaultRuleThickness: [0.04, 0.049, 0.049],
        bigOpSpacing1: [0.111, 0.111, 0.111],
        bigOpSpacing2: [0.166, 0.166, 0.166],
        bigOpSpacing3: [0.2, 0.2, 0.2],
        bigOpSpacing4: [0.6, 0.611, 0.611],
        bigOpSpacing5: [0.1, 0.143, 0.143],
        sqrtRuleThickness: [0.04, 0.04, 0.04],
        ptPerEm: [10, 10, 10],
        doubleRuleSep: [0.2, 0.2, 0.2],
        arrayRuleWidth: [0.04, 0.04, 0.04],
        fboxsep: [0.3, 0.3, 0.3],
        fboxrule: [0.04, 0.04, 0.04]
      };
      const extraCharacterMap = {
        "Å": "A",
        "Ð": "D",
        "Þ": "o",
        "å": "a",
        "ð": "d",
        "þ": "o",
        "А": "A",
        "Б": "B",
        "В": "B",
        "Г": "F",
        "Д": "A",
        "Е": "E",
        "Ж": "K",
        "З": "3",
        "И": "N",
        "Й": "N",
        "К": "K",
        "Л": "N",
        "М": "M",
        "Н": "H",
        "О": "O",
        "П": "N",
        "Р": "P",
        "С": "C",
        "Т": "T",
        "У": "y",
        "Ф": "O",
        "Х": "X",
        "Ц": "U",
        "Ч": "h",
        "Ш": "W",
        "Щ": "W",
        "Ъ": "B",
        "Ы": "X",
        "Ь": "B",
        "Э": "3",
        "Ю": "X",
        "Я": "R",
        "а": "a",
        "б": "b",
        "в": "a",
        "г": "r",
        "д": "y",
        "е": "e",
        "ж": "m",
        "з": "e",
        "и": "n",
        "й": "n",
        "к": "n",
        "л": "n",
        "м": "m",
        "н": "n",
        "о": "o",
        "п": "n",
        "р": "p",
        "с": "c",
        "т": "o",
        "у": "y",
        "ф": "b",
        "х": "x",
        "ц": "n",
        "ч": "n",
        "ш": "w",
        "щ": "w",
        "ъ": "a",
        "ы": "m",
        "ь": "a",
        "э": "e",
        "ю": "m",
        "я": "r"
      };
      function setFontMetrics(fontName, metrics) {
        fontMetricsData[fontName] = metrics;
      }
      function getCharacterMetrics(character, font, mode) {
        if (!fontMetricsData[font]) {
          throw new Error("Font metrics not found for font: " + font + ".");
        }
        let ch = character.charCodeAt(0);
        let metrics = fontMetricsData[font][ch];
        if (!metrics && character[0] in extraCharacterMap) {
          ch = extraCharacterMap[character[0]].charCodeAt(0);
          metrics = fontMetricsData[font][ch];
        }
        if (!metrics && mode === "text") {
          if (supportedCodepoint(ch)) {
            metrics = fontMetricsData[font][77];
          }
        }
        if (metrics) {
          return {
            depth: metrics[0],
            height: metrics[1],
            italic: metrics[2],
            skew: metrics[3],
            width: metrics[4]
          };
        }
      }
      const fontMetricsBySizeIndex = {};
      function getGlobalMetrics(size) {
        let sizeIndex;
        if (size >= 5) {
          sizeIndex = 0;
        } else if (size >= 3) {
          sizeIndex = 1;
        } else {
          sizeIndex = 2;
        }
        if (!fontMetricsBySizeIndex[sizeIndex]) {
          const metrics = fontMetricsBySizeIndex[sizeIndex] = {
            cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
          };
          for (const key in sigmasAndXis) {
            if (sigmasAndXis.hasOwnProperty(key)) {
              metrics[key] = sigmasAndXis[key][sizeIndex];
            }
          }
        }
        return fontMetricsBySizeIndex[sizeIndex];
      }
      const sizeStyleMap = [
        [1, 1, 1],
        [2, 1, 1],
        [3, 1, 1],
        [4, 2, 1],
        [5, 2, 1],
        [6, 3, 1],
        [7, 4, 2],
        [8, 6, 3],
        [9, 7, 6],
        [10, 8, 7],
        [11, 10, 9]
      ];
      const sizeMultipliers = [
        0.5,
        0.6,
        0.7,
        0.8,
        0.9,
        1,
        1.2,
        1.44,
        1.728,
        2.074,
        2.488
      ];
      const sizeAtStyle = function(size, style) {
        return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
      };

      class Options {
        constructor(data) {
          this.style = undefined;
          this.color = undefined;
          this.size = undefined;
          this.textSize = undefined;
          this.phantom = undefined;
          this.font = undefined;
          this.fontFamily = undefined;
          this.fontWeight = undefined;
          this.fontShape = undefined;
          this.sizeMultiplier = undefined;
          this.maxSize = undefined;
          this.minRuleThickness = undefined;
          this._fontMetrics = undefined;
          this.style = data.style;
          this.color = data.color;
          this.size = data.size || Options.BASESIZE;
          this.textSize = data.textSize || this.size;
          this.phantom = !!data.phantom;
          this.font = data.font || "";
          this.fontFamily = data.fontFamily || "";
          this.fontWeight = data.fontWeight || "";
          this.fontShape = data.fontShape || "";
          this.sizeMultiplier = sizeMultipliers[this.size - 1];
          this.maxSize = data.maxSize;
          this.minRuleThickness = data.minRuleThickness;
          this._fontMetrics = undefined;
        }
        extend(extension) {
          const data = {
            style: this.style,
            size: this.size,
            textSize: this.textSize,
            color: this.color,
            phantom: this.phantom,
            font: this.font,
            fontFamily: this.fontFamily,
            fontWeight: this.fontWeight,
            fontShape: this.fontShape,
            maxSize: this.maxSize,
            minRuleThickness: this.minRuleThickness
          };
          for (const key in extension) {
            if (extension.hasOwnProperty(key)) {
              data[key] = extension[key];
            }
          }
          return new Options(data);
        }
        havingStyle(style) {
          if (this.style === style) {
            return this;
          } else {
            return this.extend({
              style,
              size: sizeAtStyle(this.textSize, style)
            });
          }
        }
        havingCrampedStyle() {
          return this.havingStyle(this.style.cramp());
        }
        havingSize(size) {
          if (this.size === size && this.textSize === size) {
            return this;
          } else {
            return this.extend({
              style: this.style.text(),
              size,
              textSize: size,
              sizeMultiplier: sizeMultipliers[size - 1]
            });
          }
        }
        havingBaseStyle(style) {
          style = style || this.style.text();
          const wantSize = sizeAtStyle(Options.BASESIZE, style);
          if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
            return this;
          } else {
            return this.extend({
              style,
              size: wantSize
            });
          }
        }
        havingBaseSizing() {
          let size;
          switch (this.style.id) {
            case 4:
            case 5:
              size = 3;
              break;
            case 6:
            case 7:
              size = 1;
              break;
            default:
              size = 6;
          }
          return this.extend({
            style: this.style.text(),
            size
          });
        }
        withColor(color) {
          return this.extend({
            color
          });
        }
        withPhantom() {
          return this.extend({
            phantom: true
          });
        }
        withFont(font) {
          return this.extend({
            font
          });
        }
        withTextFontFamily(fontFamily) {
          return this.extend({
            fontFamily,
            font: ""
          });
        }
        withTextFontWeight(fontWeight) {
          return this.extend({
            fontWeight,
            font: ""
          });
        }
        withTextFontShape(fontShape) {
          return this.extend({
            fontShape,
            font: ""
          });
        }
        sizingClasses(oldOptions) {
          if (oldOptions.size !== this.size) {
            return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
          } else {
            return [];
          }
        }
        baseSizingClasses() {
          if (this.size !== Options.BASESIZE) {
            return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
          } else {
            return [];
          }
        }
        fontMetrics() {
          if (!this._fontMetrics) {
            this._fontMetrics = getGlobalMetrics(this.size);
          }
          return this._fontMetrics;
        }
        getColor() {
          if (this.phantom) {
            return "transparent";
          } else {
            return this.color;
          }
        }
      }
      Options.BASESIZE = 6;
      var src_Options = Options;
      const ptPerUnit = {
        pt: 1,
        mm: 7227 / 2540,
        cm: 7227 / 254,
        in: 72.27,
        bp: 803 / 800,
        pc: 12,
        dd: 1238 / 1157,
        cc: 14856 / 1157,
        nd: 685 / 642,
        nc: 1370 / 107,
        sp: 1 / 65536,
        px: 803 / 800
      };
      const relativeUnit = {
        ex: true,
        em: true,
        mu: true
      };
      const validUnit = function(unit) {
        if (typeof unit !== "string") {
          unit = unit.unit;
        }
        return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
      };
      const calculateSize = function(sizeValue, options) {
        let scale;
        if (sizeValue.unit in ptPerUnit) {
          scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
        } else if (sizeValue.unit === "mu") {
          scale = options.fontMetrics().cssEmPerMu;
        } else {
          let unitOptions;
          if (options.style.isTight()) {
            unitOptions = options.havingStyle(options.style.text());
          } else {
            unitOptions = options;
          }
          if (sizeValue.unit === "ex") {
            scale = unitOptions.fontMetrics().xHeight;
          } else if (sizeValue.unit === "em") {
            scale = unitOptions.fontMetrics().quad;
          } else {
            throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
          }
          if (unitOptions !== options) {
            scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
          }
        }
        return Math.min(sizeValue.number * scale, options.maxSize);
      };
      const makeEm = function(n) {
        return +n.toFixed(4) + "em";
      };
      const createClass = function(classes) {
        return classes.filter((cls) => cls).join(" ");
      };
      const initNode = function(classes, options, style) {
        this.classes = classes || [];
        this.attributes = {};
        this.height = 0;
        this.depth = 0;
        this.maxFontSize = 0;
        this.style = style || {};
        if (options) {
          if (options.style.isTight()) {
            this.classes.push("mtight");
          }
          const color = options.getColor();
          if (color) {
            this.style.color = color;
          }
        }
      };
      const toNode = function(tagName) {
        const node = document.createElement(tagName);
        node.className = createClass(this.classes);
        for (const style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            node.style[style] = this.style[style];
          }
        }
        for (const attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }
        for (let i = 0;i < this.children.length; i++) {
          node.appendChild(this.children[i].toNode());
        }
        return node;
      };
      const invalidAttributeNameRegex = /[\s"'>/=\x00-\x1f]/;
      const toMarkup = function(tagName) {
        let markup = "<" + tagName;
        if (this.classes.length) {
          markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
        }
        let styles2 = "";
        for (const style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
          }
        }
        if (styles2) {
          markup += ' style="' + utils.escape(styles2) + '"';
        }
        for (const attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            if (invalidAttributeNameRegex.test(attr)) {
              throw new src_ParseError("Invalid attribute name '" + attr + "'");
            }
            markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
          }
        }
        markup += ">";
        for (let i = 0;i < this.children.length; i++) {
          markup += this.children[i].toMarkup();
        }
        markup += "</" + tagName + ">";
        return markup;
      };

      class Span {
        constructor(classes, children, options, style) {
          this.children = undefined;
          this.attributes = undefined;
          this.classes = undefined;
          this.height = undefined;
          this.depth = undefined;
          this.width = undefined;
          this.maxFontSize = undefined;
          this.style = undefined;
          initNode.call(this, classes, options, style);
          this.children = children || [];
        }
        setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          return toNode.call(this, "span");
        }
        toMarkup() {
          return toMarkup.call(this, "span");
        }
      }

      class Anchor {
        constructor(href, classes, children, options) {
          this.children = undefined;
          this.attributes = undefined;
          this.classes = undefined;
          this.height = undefined;
          this.depth = undefined;
          this.maxFontSize = undefined;
          this.style = undefined;
          initNode.call(this, classes, options);
          this.children = children || [];
          this.setAttribute("href", href);
        }
        setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          return toNode.call(this, "a");
        }
        toMarkup() {
          return toMarkup.call(this, "a");
        }
      }

      class Img {
        constructor(src, alt, style) {
          this.src = undefined;
          this.alt = undefined;
          this.classes = undefined;
          this.height = undefined;
          this.depth = undefined;
          this.maxFontSize = undefined;
          this.style = undefined;
          this.alt = alt;
          this.src = src;
          this.classes = ["mord"];
          this.style = style;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          const node = document.createElement("img");
          node.src = this.src;
          node.alt = this.alt;
          node.className = "mord";
          for (const style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              node.style[style] = this.style[style];
            }
          }
          return node;
        }
        toMarkup() {
          let markup = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"');
          let styles2 = "";
          for (const style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles2) {
            markup += ' style="' + utils.escape(styles2) + '"';
          }
          markup += "'/>";
          return markup;
        }
      }
      const iCombinations = {
        "î": "ı̂",
        "ï": "ı̈",
        "í": "ı́",
        "ì": "ı̀"
      };

      class SymbolNode {
        constructor(text, height, depth, italic, skew, width, classes, style) {
          this.text = undefined;
          this.height = undefined;
          this.depth = undefined;
          this.italic = undefined;
          this.skew = undefined;
          this.width = undefined;
          this.maxFontSize = undefined;
          this.classes = undefined;
          this.style = undefined;
          this.text = text;
          this.height = height || 0;
          this.depth = depth || 0;
          this.italic = italic || 0;
          this.skew = skew || 0;
          this.width = width || 0;
          this.classes = classes || [];
          this.style = style || {};
          this.maxFontSize = 0;
          const script = scriptFromCodepoint(this.text.charCodeAt(0));
          if (script) {
            this.classes.push(script + "_fallback");
          }
          if (/[îïíì]/.test(this.text)) {
            this.text = iCombinations[this.text];
          }
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          const node = document.createTextNode(this.text);
          let span = null;
          if (this.italic > 0) {
            span = document.createElement("span");
            span.style.marginRight = makeEm(this.italic);
          }
          if (this.classes.length > 0) {
            span = span || document.createElement("span");
            span.className = createClass(this.classes);
          }
          for (const style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              span = span || document.createElement("span");
              span.style[style] = this.style[style];
            }
          }
          if (span) {
            span.appendChild(node);
            return span;
          } else {
            return node;
          }
        }
        toMarkup() {
          let needsSpan = false;
          let markup = "<span";
          if (this.classes.length) {
            needsSpan = true;
            markup += ' class="';
            markup += utils.escape(createClass(this.classes));
            markup += '"';
          }
          let styles2 = "";
          if (this.italic > 0) {
            styles2 += "margin-right:" + this.italic + "em;";
          }
          for (const style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles2) {
            needsSpan = true;
            markup += ' style="' + utils.escape(styles2) + '"';
          }
          const escaped = utils.escape(this.text);
          if (needsSpan) {
            markup += ">";
            markup += escaped;
            markup += "</span>";
            return markup;
          } else {
            return escaped;
          }
        }
      }

      class SvgNode {
        constructor(children, attributes) {
          this.children = undefined;
          this.attributes = undefined;
          this.children = children || [];
          this.attributes = attributes || {};
        }
        toNode() {
          const svgNS = "http://www.w3.org/2000/svg";
          const node = document.createElementNS(svgNS, "svg");
          for (const attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          for (let i = 0;i < this.children.length; i++) {
            node.appendChild(this.children[i].toNode());
          }
          return node;
        }
        toMarkup() {
          let markup = '<svg xmlns="http://www.w3.org/2000/svg"';
          for (const attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
            }
          }
          markup += ">";
          for (let i = 0;i < this.children.length; i++) {
            markup += this.children[i].toMarkup();
          }
          markup += "</svg>";
          return markup;
        }
      }

      class PathNode {
        constructor(pathName, alternate) {
          this.pathName = undefined;
          this.alternate = undefined;
          this.pathName = pathName;
          this.alternate = alternate;
        }
        toNode() {
          const svgNS = "http://www.w3.org/2000/svg";
          const node = document.createElementNS(svgNS, "path");
          if (this.alternate) {
            node.setAttribute("d", this.alternate);
          } else {
            node.setAttribute("d", path[this.pathName]);
          }
          return node;
        }
        toMarkup() {
          if (this.alternate) {
            return '<path d="' + utils.escape(this.alternate) + '"/>';
          } else {
            return '<path d="' + utils.escape(path[this.pathName]) + '"/>';
          }
        }
      }

      class LineNode {
        constructor(attributes) {
          this.attributes = undefined;
          this.attributes = attributes || {};
        }
        toNode() {
          const svgNS = "http://www.w3.org/2000/svg";
          const node = document.createElementNS(svgNS, "line");
          for (const attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          return node;
        }
        toMarkup() {
          let markup = "<line";
          for (const attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
            }
          }
          markup += "/>";
          return markup;
        }
      }
      function assertSymbolDomNode(group) {
        if (group instanceof SymbolNode) {
          return group;
        } else {
          throw new Error("Expected symbolNode but got " + String(group) + ".");
        }
      }
      function assertSpan(group) {
        if (group instanceof Span) {
          return group;
        } else {
          throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
        }
      }
      const ATOMS = {
        bin: 1,
        close: 1,
        inner: 1,
        open: 1,
        punct: 1,
        rel: 1
      };
      const NON_ATOMS = {
        "accent-token": 1,
        mathord: 1,
        "op-token": 1,
        spacing: 1,
        textord: 1
      };
      const symbols = {
        math: {},
        text: {}
      };
      var src_symbols = symbols;
      function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
        symbols[mode][name] = {
          font,
          group,
          replace
        };
        if (acceptUnicodeChar && replace) {
          symbols[mode][replace] = symbols[mode][name];
        }
      }
      const math = "math";
      const symbols_text = "text";
      const main = "main";
      const ams = "ams";
      const accent = "accent-token";
      const bin = "bin";
      const symbols_close = "close";
      const inner = "inner";
      const mathord = "mathord";
      const op = "op-token";
      const symbols_open = "open";
      const punct = "punct";
      const rel = "rel";
      const spacing = "spacing";
      const textord = "textord";
      defineSymbol(math, main, rel, "≡", "\\equiv", true);
      defineSymbol(math, main, rel, "≺", "\\prec", true);
      defineSymbol(math, main, rel, "≻", "\\succ", true);
      defineSymbol(math, main, rel, "∼", "\\sim", true);
      defineSymbol(math, main, rel, "⊥", "\\perp");
      defineSymbol(math, main, rel, "⪯", "\\preceq", true);
      defineSymbol(math, main, rel, "⪰", "\\succeq", true);
      defineSymbol(math, main, rel, "≃", "\\simeq", true);
      defineSymbol(math, main, rel, "∣", "\\mid", true);
      defineSymbol(math, main, rel, "≪", "\\ll", true);
      defineSymbol(math, main, rel, "≫", "\\gg", true);
      defineSymbol(math, main, rel, "≍", "\\asymp", true);
      defineSymbol(math, main, rel, "∥", "\\parallel");
      defineSymbol(math, main, rel, "⋈", "\\bowtie", true);
      defineSymbol(math, main, rel, "⌣", "\\smile", true);
      defineSymbol(math, main, rel, "⊑", "\\sqsubseteq", true);
      defineSymbol(math, main, rel, "⊒", "\\sqsupseteq", true);
      defineSymbol(math, main, rel, "≐", "\\doteq", true);
      defineSymbol(math, main, rel, "⌢", "\\frown", true);
      defineSymbol(math, main, rel, "∋", "\\ni", true);
      defineSymbol(math, main, rel, "∝", "\\propto", true);
      defineSymbol(math, main, rel, "⊢", "\\vdash", true);
      defineSymbol(math, main, rel, "⊣", "\\dashv", true);
      defineSymbol(math, main, rel, "∋", "\\owns");
      defineSymbol(math, main, punct, ".", "\\ldotp");
      defineSymbol(math, main, punct, "⋅", "\\cdotp");
      defineSymbol(math, main, textord, "#", "\\#");
      defineSymbol(symbols_text, main, textord, "#", "\\#");
      defineSymbol(math, main, textord, "&", "\\&");
      defineSymbol(symbols_text, main, textord, "&", "\\&");
      defineSymbol(math, main, textord, "ℵ", "\\aleph", true);
      defineSymbol(math, main, textord, "∀", "\\forall", true);
      defineSymbol(math, main, textord, "ℏ", "\\hbar", true);
      defineSymbol(math, main, textord, "∃", "\\exists", true);
      defineSymbol(math, main, textord, "∇", "\\nabla", true);
      defineSymbol(math, main, textord, "♭", "\\flat", true);
      defineSymbol(math, main, textord, "ℓ", "\\ell", true);
      defineSymbol(math, main, textord, "♮", "\\natural", true);
      defineSymbol(math, main, textord, "♣", "\\clubsuit", true);
      defineSymbol(math, main, textord, "℘", "\\wp", true);
      defineSymbol(math, main, textord, "♯", "\\sharp", true);
      defineSymbol(math, main, textord, "♢", "\\diamondsuit", true);
      defineSymbol(math, main, textord, "ℜ", "\\Re", true);
      defineSymbol(math, main, textord, "♡", "\\heartsuit", true);
      defineSymbol(math, main, textord, "ℑ", "\\Im", true);
      defineSymbol(math, main, textord, "♠", "\\spadesuit", true);
      defineSymbol(math, main, textord, "§", "\\S", true);
      defineSymbol(symbols_text, main, textord, "§", "\\S");
      defineSymbol(math, main, textord, "¶", "\\P", true);
      defineSymbol(symbols_text, main, textord, "¶", "\\P");
      defineSymbol(math, main, textord, "†", "\\dag");
      defineSymbol(symbols_text, main, textord, "†", "\\dag");
      defineSymbol(symbols_text, main, textord, "†", "\\textdagger");
      defineSymbol(math, main, textord, "‡", "\\ddag");
      defineSymbol(symbols_text, main, textord, "‡", "\\ddag");
      defineSymbol(symbols_text, main, textord, "‡", "\\textdaggerdbl");
      defineSymbol(math, main, symbols_close, "⎱", "\\rmoustache", true);
      defineSymbol(math, main, symbols_open, "⎰", "\\lmoustache", true);
      defineSymbol(math, main, symbols_close, "⟯", "\\rgroup", true);
      defineSymbol(math, main, symbols_open, "⟮", "\\lgroup", true);
      defineSymbol(math, main, bin, "∓", "\\mp", true);
      defineSymbol(math, main, bin, "⊖", "\\ominus", true);
      defineSymbol(math, main, bin, "⊎", "\\uplus", true);
      defineSymbol(math, main, bin, "⊓", "\\sqcap", true);
      defineSymbol(math, main, bin, "∗", "\\ast");
      defineSymbol(math, main, bin, "⊔", "\\sqcup", true);
      defineSymbol(math, main, bin, "◯", "\\bigcirc", true);
      defineSymbol(math, main, bin, "∙", "\\bullet", true);
      defineSymbol(math, main, bin, "‡", "\\ddagger");
      defineSymbol(math, main, bin, "≀", "\\wr", true);
      defineSymbol(math, main, bin, "⨿", "\\amalg");
      defineSymbol(math, main, bin, "&", "\\And");
      defineSymbol(math, main, rel, "⟵", "\\longleftarrow", true);
      defineSymbol(math, main, rel, "⇐", "\\Leftarrow", true);
      defineSymbol(math, main, rel, "⟸", "\\Longleftarrow", true);
      defineSymbol(math, main, rel, "⟶", "\\longrightarrow", true);
      defineSymbol(math, main, rel, "⇒", "\\Rightarrow", true);
      defineSymbol(math, main, rel, "⟹", "\\Longrightarrow", true);
      defineSymbol(math, main, rel, "↔", "\\leftrightarrow", true);
      defineSymbol(math, main, rel, "⟷", "\\longleftrightarrow", true);
      defineSymbol(math, main, rel, "⇔", "\\Leftrightarrow", true);
      defineSymbol(math, main, rel, "⟺", "\\Longleftrightarrow", true);
      defineSymbol(math, main, rel, "↦", "\\mapsto", true);
      defineSymbol(math, main, rel, "⟼", "\\longmapsto", true);
      defineSymbol(math, main, rel, "↗", "\\nearrow", true);
      defineSymbol(math, main, rel, "↩", "\\hookleftarrow", true);
      defineSymbol(math, main, rel, "↪", "\\hookrightarrow", true);
      defineSymbol(math, main, rel, "↘", "\\searrow", true);
      defineSymbol(math, main, rel, "↼", "\\leftharpoonup", true);
      defineSymbol(math, main, rel, "⇀", "\\rightharpoonup", true);
      defineSymbol(math, main, rel, "↙", "\\swarrow", true);
      defineSymbol(math, main, rel, "↽", "\\leftharpoondown", true);
      defineSymbol(math, main, rel, "⇁", "\\rightharpoondown", true);
      defineSymbol(math, main, rel, "↖", "\\nwarrow", true);
      defineSymbol(math, main, rel, "⇌", "\\rightleftharpoons", true);
      defineSymbol(math, ams, rel, "≮", "\\nless", true);
      defineSymbol(math, ams, rel, "", "\\@nleqslant");
      defineSymbol(math, ams, rel, "", "\\@nleqq");
      defineSymbol(math, ams, rel, "⪇", "\\lneq", true);
      defineSymbol(math, ams, rel, "≨", "\\lneqq", true);
      defineSymbol(math, ams, rel, "", "\\@lvertneqq");
      defineSymbol(math, ams, rel, "⋦", "\\lnsim", true);
      defineSymbol(math, ams, rel, "⪉", "\\lnapprox", true);
      defineSymbol(math, ams, rel, "⊀", "\\nprec", true);
      defineSymbol(math, ams, rel, "⋠", "\\npreceq", true);
      defineSymbol(math, ams, rel, "⋨", "\\precnsim", true);
      defineSymbol(math, ams, rel, "⪹", "\\precnapprox", true);
      defineSymbol(math, ams, rel, "≁", "\\nsim", true);
      defineSymbol(math, ams, rel, "", "\\@nshortmid");
      defineSymbol(math, ams, rel, "∤", "\\nmid", true);
      defineSymbol(math, ams, rel, "⊬", "\\nvdash", true);
      defineSymbol(math, ams, rel, "⊭", "\\nvDash", true);
      defineSymbol(math, ams, rel, "⋪", "\\ntriangleleft");
      defineSymbol(math, ams, rel, "⋬", "\\ntrianglelefteq", true);
      defineSymbol(math, ams, rel, "⊊", "\\subsetneq", true);
      defineSymbol(math, ams, rel, "", "\\@varsubsetneq");
      defineSymbol(math, ams, rel, "⫋", "\\subsetneqq", true);
      defineSymbol(math, ams, rel, "", "\\@varsubsetneqq");
      defineSymbol(math, ams, rel, "≯", "\\ngtr", true);
      defineSymbol(math, ams, rel, "", "\\@ngeqslant");
      defineSymbol(math, ams, rel, "", "\\@ngeqq");
      defineSymbol(math, ams, rel, "⪈", "\\gneq", true);
      defineSymbol(math, ams, rel, "≩", "\\gneqq", true);
      defineSymbol(math, ams, rel, "", "\\@gvertneqq");
      defineSymbol(math, ams, rel, "⋧", "\\gnsim", true);
      defineSymbol(math, ams, rel, "⪊", "\\gnapprox", true);
      defineSymbol(math, ams, rel, "⊁", "\\nsucc", true);
      defineSymbol(math, ams, rel, "⋡", "\\nsucceq", true);
      defineSymbol(math, ams, rel, "⋩", "\\succnsim", true);
      defineSymbol(math, ams, rel, "⪺", "\\succnapprox", true);
      defineSymbol(math, ams, rel, "≆", "\\ncong", true);
      defineSymbol(math, ams, rel, "", "\\@nshortparallel");
      defineSymbol(math, ams, rel, "∦", "\\nparallel", true);
      defineSymbol(math, ams, rel, "⊯", "\\nVDash", true);
      defineSymbol(math, ams, rel, "⋫", "\\ntriangleright");
      defineSymbol(math, ams, rel, "⋭", "\\ntrianglerighteq", true);
      defineSymbol(math, ams, rel, "", "\\@nsupseteqq");
      defineSymbol(math, ams, rel, "⊋", "\\supsetneq", true);
      defineSymbol(math, ams, rel, "", "\\@varsupsetneq");
      defineSymbol(math, ams, rel, "⫌", "\\supsetneqq", true);
      defineSymbol(math, ams, rel, "", "\\@varsupsetneqq");
      defineSymbol(math, ams, rel, "⊮", "\\nVdash", true);
      defineSymbol(math, ams, rel, "⪵", "\\precneqq", true);
      defineSymbol(math, ams, rel, "⪶", "\\succneqq", true);
      defineSymbol(math, ams, rel, "", "\\@nsubseteqq");
      defineSymbol(math, ams, bin, "⊴", "\\unlhd");
      defineSymbol(math, ams, bin, "⊵", "\\unrhd");
      defineSymbol(math, ams, rel, "↚", "\\nleftarrow", true);
      defineSymbol(math, ams, rel, "↛", "\\nrightarrow", true);
      defineSymbol(math, ams, rel, "⇍", "\\nLeftarrow", true);
      defineSymbol(math, ams, rel, "⇏", "\\nRightarrow", true);
      defineSymbol(math, ams, rel, "↮", "\\nleftrightarrow", true);
      defineSymbol(math, ams, rel, "⇎", "\\nLeftrightarrow", true);
      defineSymbol(math, ams, rel, "△", "\\vartriangle");
      defineSymbol(math, ams, textord, "ℏ", "\\hslash");
      defineSymbol(math, ams, textord, "▽", "\\triangledown");
      defineSymbol(math, ams, textord, "◊", "\\lozenge");
      defineSymbol(math, ams, textord, "Ⓢ", "\\circledS");
      defineSymbol(math, ams, textord, "®", "\\circledR");
      defineSymbol(symbols_text, ams, textord, "®", "\\circledR");
      defineSymbol(math, ams, textord, "∡", "\\measuredangle", true);
      defineSymbol(math, ams, textord, "∄", "\\nexists");
      defineSymbol(math, ams, textord, "℧", "\\mho");
      defineSymbol(math, ams, textord, "Ⅎ", "\\Finv", true);
      defineSymbol(math, ams, textord, "⅁", "\\Game", true);
      defineSymbol(math, ams, textord, "‵", "\\backprime");
      defineSymbol(math, ams, textord, "▲", "\\blacktriangle");
      defineSymbol(math, ams, textord, "▼", "\\blacktriangledown");
      defineSymbol(math, ams, textord, "■", "\\blacksquare");
      defineSymbol(math, ams, textord, "⧫", "\\blacklozenge");
      defineSymbol(math, ams, textord, "★", "\\bigstar");
      defineSymbol(math, ams, textord, "∢", "\\sphericalangle", true);
      defineSymbol(math, ams, textord, "∁", "\\complement", true);
      defineSymbol(math, ams, textord, "ð", "\\eth", true);
      defineSymbol(symbols_text, main, textord, "ð", "ð");
      defineSymbol(math, ams, textord, "╱", "\\diagup");
      defineSymbol(math, ams, textord, "╲", "\\diagdown");
      defineSymbol(math, ams, textord, "□", "\\square");
      defineSymbol(math, ams, textord, "□", "\\Box");
      defineSymbol(math, ams, textord, "◊", "\\Diamond");
      defineSymbol(math, ams, textord, "¥", "\\yen", true);
      defineSymbol(symbols_text, ams, textord, "¥", "\\yen", true);
      defineSymbol(math, ams, textord, "✓", "\\checkmark", true);
      defineSymbol(symbols_text, ams, textord, "✓", "\\checkmark");
      defineSymbol(math, ams, textord, "ℶ", "\\beth", true);
      defineSymbol(math, ams, textord, "ℸ", "\\daleth", true);
      defineSymbol(math, ams, textord, "ℷ", "\\gimel", true);
      defineSymbol(math, ams, textord, "ϝ", "\\digamma", true);
      defineSymbol(math, ams, textord, "ϰ", "\\varkappa");
      defineSymbol(math, ams, symbols_open, "┌", "\\@ulcorner", true);
      defineSymbol(math, ams, symbols_close, "┐", "\\@urcorner", true);
      defineSymbol(math, ams, symbols_open, "└", "\\@llcorner", true);
      defineSymbol(math, ams, symbols_close, "┘", "\\@lrcorner", true);
      defineSymbol(math, ams, rel, "≦", "\\leqq", true);
      defineSymbol(math, ams, rel, "⩽", "\\leqslant", true);
      defineSymbol(math, ams, rel, "⪕", "\\eqslantless", true);
      defineSymbol(math, ams, rel, "≲", "\\lesssim", true);
      defineSymbol(math, ams, rel, "⪅", "\\lessapprox", true);
      defineSymbol(math, ams, rel, "≊", "\\approxeq", true);
      defineSymbol(math, ams, bin, "⋖", "\\lessdot");
      defineSymbol(math, ams, rel, "⋘", "\\lll", true);
      defineSymbol(math, ams, rel, "≶", "\\lessgtr", true);
      defineSymbol(math, ams, rel, "⋚", "\\lesseqgtr", true);
      defineSymbol(math, ams, rel, "⪋", "\\lesseqqgtr", true);
      defineSymbol(math, ams, rel, "≑", "\\doteqdot");
      defineSymbol(math, ams, rel, "≓", "\\risingdotseq", true);
      defineSymbol(math, ams, rel, "≒", "\\fallingdotseq", true);
      defineSymbol(math, ams, rel, "∽", "\\backsim", true);
      defineSymbol(math, ams, rel, "⋍", "\\backsimeq", true);
      defineSymbol(math, ams, rel, "⫅", "\\subseteqq", true);
      defineSymbol(math, ams, rel, "⋐", "\\Subset", true);
      defineSymbol(math, ams, rel, "⊏", "\\sqsubset", true);
      defineSymbol(math, ams, rel, "≼", "\\preccurlyeq", true);
      defineSymbol(math, ams, rel, "⋞", "\\curlyeqprec", true);
      defineSymbol(math, ams, rel, "≾", "\\precsim", true);
      defineSymbol(math, ams, rel, "⪷", "\\precapprox", true);
      defineSymbol(math, ams, rel, "⊲", "\\vartriangleleft");
      defineSymbol(math, ams, rel, "⊴", "\\trianglelefteq");
      defineSymbol(math, ams, rel, "⊨", "\\vDash", true);
      defineSymbol(math, ams, rel, "⊪", "\\Vvdash", true);
      defineSymbol(math, ams, rel, "⌣", "\\smallsmile");
      defineSymbol(math, ams, rel, "⌢", "\\smallfrown");
      defineSymbol(math, ams, rel, "≏", "\\bumpeq", true);
      defineSymbol(math, ams, rel, "≎", "\\Bumpeq", true);
      defineSymbol(math, ams, rel, "≧", "\\geqq", true);
      defineSymbol(math, ams, rel, "⩾", "\\geqslant", true);
      defineSymbol(math, ams, rel, "⪖", "\\eqslantgtr", true);
      defineSymbol(math, ams, rel, "≳", "\\gtrsim", true);
      defineSymbol(math, ams, rel, "⪆", "\\gtrapprox", true);
      defineSymbol(math, ams, bin, "⋗", "\\gtrdot");
      defineSymbol(math, ams, rel, "⋙", "\\ggg", true);
      defineSymbol(math, ams, rel, "≷", "\\gtrless", true);
      defineSymbol(math, ams, rel, "⋛", "\\gtreqless", true);
      defineSymbol(math, ams, rel, "⪌", "\\gtreqqless", true);
      defineSymbol(math, ams, rel, "≖", "\\eqcirc", true);
      defineSymbol(math, ams, rel, "≗", "\\circeq", true);
      defineSymbol(math, ams, rel, "≜", "\\triangleq", true);
      defineSymbol(math, ams, rel, "∼", "\\thicksim");
      defineSymbol(math, ams, rel, "≈", "\\thickapprox");
      defineSymbol(math, ams, rel, "⫆", "\\supseteqq", true);
      defineSymbol(math, ams, rel, "⋑", "\\Supset", true);
      defineSymbol(math, ams, rel, "⊐", "\\sqsupset", true);
      defineSymbol(math, ams, rel, "≽", "\\succcurlyeq", true);
      defineSymbol(math, ams, rel, "⋟", "\\curlyeqsucc", true);
      defineSymbol(math, ams, rel, "≿", "\\succsim", true);
      defineSymbol(math, ams, rel, "⪸", "\\succapprox", true);
      defineSymbol(math, ams, rel, "⊳", "\\vartriangleright");
      defineSymbol(math, ams, rel, "⊵", "\\trianglerighteq");
      defineSymbol(math, ams, rel, "⊩", "\\Vdash", true);
      defineSymbol(math, ams, rel, "∣", "\\shortmid");
      defineSymbol(math, ams, rel, "∥", "\\shortparallel");
      defineSymbol(math, ams, rel, "≬", "\\between", true);
      defineSymbol(math, ams, rel, "⋔", "\\pitchfork", true);
      defineSymbol(math, ams, rel, "∝", "\\varpropto");
      defineSymbol(math, ams, rel, "◀", "\\blacktriangleleft");
      defineSymbol(math, ams, rel, "∴", "\\therefore", true);
      defineSymbol(math, ams, rel, "∍", "\\backepsilon");
      defineSymbol(math, ams, rel, "▶", "\\blacktriangleright");
      defineSymbol(math, ams, rel, "∵", "\\because", true);
      defineSymbol(math, ams, rel, "⋘", "\\llless");
      defineSymbol(math, ams, rel, "⋙", "\\gggtr");
      defineSymbol(math, ams, bin, "⊲", "\\lhd");
      defineSymbol(math, ams, bin, "⊳", "\\rhd");
      defineSymbol(math, ams, rel, "≂", "\\eqsim", true);
      defineSymbol(math, main, rel, "⋈", "\\Join");
      defineSymbol(math, ams, rel, "≑", "\\Doteq", true);
      defineSymbol(math, ams, bin, "∔", "\\dotplus", true);
      defineSymbol(math, ams, bin, "∖", "\\smallsetminus");
      defineSymbol(math, ams, bin, "⋒", "\\Cap", true);
      defineSymbol(math, ams, bin, "⋓", "\\Cup", true);
      defineSymbol(math, ams, bin, "⩞", "\\doublebarwedge", true);
      defineSymbol(math, ams, bin, "⊟", "\\boxminus", true);
      defineSymbol(math, ams, bin, "⊞", "\\boxplus", true);
      defineSymbol(math, ams, bin, "⋇", "\\divideontimes", true);
      defineSymbol(math, ams, bin, "⋉", "\\ltimes", true);
      defineSymbol(math, ams, bin, "⋊", "\\rtimes", true);
      defineSymbol(math, ams, bin, "⋋", "\\leftthreetimes", true);
      defineSymbol(math, ams, bin, "⋌", "\\rightthreetimes", true);
      defineSymbol(math, ams, bin, "⋏", "\\curlywedge", true);
      defineSymbol(math, ams, bin, "⋎", "\\curlyvee", true);
      defineSymbol(math, ams, bin, "⊝", "\\circleddash", true);
      defineSymbol(math, ams, bin, "⊛", "\\circledast", true);
      defineSymbol(math, ams, bin, "⋅", "\\centerdot");
      defineSymbol(math, ams, bin, "⊺", "\\intercal", true);
      defineSymbol(math, ams, bin, "⋒", "\\doublecap");
      defineSymbol(math, ams, bin, "⋓", "\\doublecup");
      defineSymbol(math, ams, bin, "⊠", "\\boxtimes", true);
      defineSymbol(math, ams, rel, "⇢", "\\dashrightarrow", true);
      defineSymbol(math, ams, rel, "⇠", "\\dashleftarrow", true);
      defineSymbol(math, ams, rel, "⇇", "\\leftleftarrows", true);
      defineSymbol(math, ams, rel, "⇆", "\\leftrightarrows", true);
      defineSymbol(math, ams, rel, "⇚", "\\Lleftarrow", true);
      defineSymbol(math, ams, rel, "↞", "\\twoheadleftarrow", true);
      defineSymbol(math, ams, rel, "↢", "\\leftarrowtail", true);
      defineSymbol(math, ams, rel, "↫", "\\looparrowleft", true);
      defineSymbol(math, ams, rel, "⇋", "\\leftrightharpoons", true);
      defineSymbol(math, ams, rel, "↶", "\\curvearrowleft", true);
      defineSymbol(math, ams, rel, "↺", "\\circlearrowleft", true);
      defineSymbol(math, ams, rel, "↰", "\\Lsh", true);
      defineSymbol(math, ams, rel, "⇈", "\\upuparrows", true);
      defineSymbol(math, ams, rel, "↿", "\\upharpoonleft", true);
      defineSymbol(math, ams, rel, "⇃", "\\downharpoonleft", true);
      defineSymbol(math, main, rel, "⊶", "\\origof", true);
      defineSymbol(math, main, rel, "⊷", "\\imageof", true);
      defineSymbol(math, ams, rel, "⊸", "\\multimap", true);
      defineSymbol(math, ams, rel, "↭", "\\leftrightsquigarrow", true);
      defineSymbol(math, ams, rel, "⇉", "\\rightrightarrows", true);
      defineSymbol(math, ams, rel, "⇄", "\\rightleftarrows", true);
      defineSymbol(math, ams, rel, "↠", "\\twoheadrightarrow", true);
      defineSymbol(math, ams, rel, "↣", "\\rightarrowtail", true);
      defineSymbol(math, ams, rel, "↬", "\\looparrowright", true);
      defineSymbol(math, ams, rel, "↷", "\\curvearrowright", true);
      defineSymbol(math, ams, rel, "↻", "\\circlearrowright", true);
      defineSymbol(math, ams, rel, "↱", "\\Rsh", true);
      defineSymbol(math, ams, rel, "⇊", "\\downdownarrows", true);
      defineSymbol(math, ams, rel, "↾", "\\upharpoonright", true);
      defineSymbol(math, ams, rel, "⇂", "\\downharpoonright", true);
      defineSymbol(math, ams, rel, "⇝", "\\rightsquigarrow", true);
      defineSymbol(math, ams, rel, "⇝", "\\leadsto");
      defineSymbol(math, ams, rel, "⇛", "\\Rrightarrow", true);
      defineSymbol(math, ams, rel, "↾", "\\restriction");
      defineSymbol(math, main, textord, "‘", "`");
      defineSymbol(math, main, textord, "$", "\\$");
      defineSymbol(symbols_text, main, textord, "$", "\\$");
      defineSymbol(symbols_text, main, textord, "$", "\\textdollar");
      defineSymbol(math, main, textord, "%", "\\%");
      defineSymbol(symbols_text, main, textord, "%", "\\%");
      defineSymbol(math, main, textord, "_", "\\_");
      defineSymbol(symbols_text, main, textord, "_", "\\_");
      defineSymbol(symbols_text, main, textord, "_", "\\textunderscore");
      defineSymbol(math, main, textord, "∠", "\\angle", true);
      defineSymbol(math, main, textord, "∞", "\\infty", true);
      defineSymbol(math, main, textord, "′", "\\prime");
      defineSymbol(math, main, textord, "△", "\\triangle");
      defineSymbol(math, main, textord, "Γ", "\\Gamma", true);
      defineSymbol(math, main, textord, "Δ", "\\Delta", true);
      defineSymbol(math, main, textord, "Θ", "\\Theta", true);
      defineSymbol(math, main, textord, "Λ", "\\Lambda", true);
      defineSymbol(math, main, textord, "Ξ", "\\Xi", true);
      defineSymbol(math, main, textord, "Π", "\\Pi", true);
      defineSymbol(math, main, textord, "Σ", "\\Sigma", true);
      defineSymbol(math, main, textord, "Υ", "\\Upsilon", true);
      defineSymbol(math, main, textord, "Φ", "\\Phi", true);
      defineSymbol(math, main, textord, "Ψ", "\\Psi", true);
      defineSymbol(math, main, textord, "Ω", "\\Omega", true);
      defineSymbol(math, main, textord, "A", "Α");
      defineSymbol(math, main, textord, "B", "Β");
      defineSymbol(math, main, textord, "E", "Ε");
      defineSymbol(math, main, textord, "Z", "Ζ");
      defineSymbol(math, main, textord, "H", "Η");
      defineSymbol(math, main, textord, "I", "Ι");
      defineSymbol(math, main, textord, "K", "Κ");
      defineSymbol(math, main, textord, "M", "Μ");
      defineSymbol(math, main, textord, "N", "Ν");
      defineSymbol(math, main, textord, "O", "Ο");
      defineSymbol(math, main, textord, "P", "Ρ");
      defineSymbol(math, main, textord, "T", "Τ");
      defineSymbol(math, main, textord, "X", "Χ");
      defineSymbol(math, main, textord, "¬", "\\neg", true);
      defineSymbol(math, main, textord, "¬", "\\lnot");
      defineSymbol(math, main, textord, "⊤", "\\top");
      defineSymbol(math, main, textord, "⊥", "\\bot");
      defineSymbol(math, main, textord, "∅", "\\emptyset");
      defineSymbol(math, ams, textord, "∅", "\\varnothing");
      defineSymbol(math, main, mathord, "α", "\\alpha", true);
      defineSymbol(math, main, mathord, "β", "\\beta", true);
      defineSymbol(math, main, mathord, "γ", "\\gamma", true);
      defineSymbol(math, main, mathord, "δ", "\\delta", true);
      defineSymbol(math, main, mathord, "ϵ", "\\epsilon", true);
      defineSymbol(math, main, mathord, "ζ", "\\zeta", true);
      defineSymbol(math, main, mathord, "η", "\\eta", true);
      defineSymbol(math, main, mathord, "θ", "\\theta", true);
      defineSymbol(math, main, mathord, "ι", "\\iota", true);
      defineSymbol(math, main, mathord, "κ", "\\kappa", true);
      defineSymbol(math, main, mathord, "λ", "\\lambda", true);
      defineSymbol(math, main, mathord, "μ", "\\mu", true);
      defineSymbol(math, main, mathord, "ν", "\\nu", true);
      defineSymbol(math, main, mathord, "ξ", "\\xi", true);
      defineSymbol(math, main, mathord, "ο", "\\omicron", true);
      defineSymbol(math, main, mathord, "π", "\\pi", true);
      defineSymbol(math, main, mathord, "ρ", "\\rho", true);
      defineSymbol(math, main, mathord, "σ", "\\sigma", true);
      defineSymbol(math, main, mathord, "τ", "\\tau", true);
      defineSymbol(math, main, mathord, "υ", "\\upsilon", true);
      defineSymbol(math, main, mathord, "ϕ", "\\phi", true);
      defineSymbol(math, main, mathord, "χ", "\\chi", true);
      defineSymbol(math, main, mathord, "ψ", "\\psi", true);
      defineSymbol(math, main, mathord, "ω", "\\omega", true);
      defineSymbol(math, main, mathord, "ε", "\\varepsilon", true);
      defineSymbol(math, main, mathord, "ϑ", "\\vartheta", true);
      defineSymbol(math, main, mathord, "ϖ", "\\varpi", true);
      defineSymbol(math, main, mathord, "ϱ", "\\varrho", true);
      defineSymbol(math, main, mathord, "ς", "\\varsigma", true);
      defineSymbol(math, main, mathord, "φ", "\\varphi", true);
      defineSymbol(math, main, bin, "∗", "*", true);
      defineSymbol(math, main, bin, "+", "+");
      defineSymbol(math, main, bin, "−", "-", true);
      defineSymbol(math, main, bin, "⋅", "\\cdot", true);
      defineSymbol(math, main, bin, "∘", "\\circ", true);
      defineSymbol(math, main, bin, "÷", "\\div", true);
      defineSymbol(math, main, bin, "±", "\\pm", true);
      defineSymbol(math, main, bin, "×", "\\times", true);
      defineSymbol(math, main, bin, "∩", "\\cap", true);
      defineSymbol(math, main, bin, "∪", "\\cup", true);
      defineSymbol(math, main, bin, "∖", "\\setminus", true);
      defineSymbol(math, main, bin, "∧", "\\land");
      defineSymbol(math, main, bin, "∨", "\\lor");
      defineSymbol(math, main, bin, "∧", "\\wedge", true);
      defineSymbol(math, main, bin, "∨", "\\vee", true);
      defineSymbol(math, main, textord, "√", "\\surd");
      defineSymbol(math, main, symbols_open, "⟨", "\\langle", true);
      defineSymbol(math, main, symbols_open, "∣", "\\lvert");
      defineSymbol(math, main, symbols_open, "∥", "\\lVert");
      defineSymbol(math, main, symbols_close, "?", "?");
      defineSymbol(math, main, symbols_close, "!", "!");
      defineSymbol(math, main, symbols_close, "⟩", "\\rangle", true);
      defineSymbol(math, main, symbols_close, "∣", "\\rvert");
      defineSymbol(math, main, symbols_close, "∥", "\\rVert");
      defineSymbol(math, main, rel, "=", "=");
      defineSymbol(math, main, rel, ":", ":");
      defineSymbol(math, main, rel, "≈", "\\approx", true);
      defineSymbol(math, main, rel, "≅", "\\cong", true);
      defineSymbol(math, main, rel, "≥", "\\ge");
      defineSymbol(math, main, rel, "≥", "\\geq", true);
      defineSymbol(math, main, rel, "←", "\\gets");
      defineSymbol(math, main, rel, ">", "\\gt", true);
      defineSymbol(math, main, rel, "∈", "\\in", true);
      defineSymbol(math, main, rel, "", "\\@not");
      defineSymbol(math, main, rel, "⊂", "\\subset", true);
      defineSymbol(math, main, rel, "⊃", "\\supset", true);
      defineSymbol(math, main, rel, "⊆", "\\subseteq", true);
      defineSymbol(math, main, rel, "⊇", "\\supseteq", true);
      defineSymbol(math, ams, rel, "⊈", "\\nsubseteq", true);
      defineSymbol(math, ams, rel, "⊉", "\\nsupseteq", true);
      defineSymbol(math, main, rel, "⊨", "\\models");
      defineSymbol(math, main, rel, "←", "\\leftarrow", true);
      defineSymbol(math, main, rel, "≤", "\\le");
      defineSymbol(math, main, rel, "≤", "\\leq", true);
      defineSymbol(math, main, rel, "<", "\\lt", true);
      defineSymbol(math, main, rel, "→", "\\rightarrow", true);
      defineSymbol(math, main, rel, "→", "\\to");
      defineSymbol(math, ams, rel, "≱", "\\ngeq", true);
      defineSymbol(math, ams, rel, "≰", "\\nleq", true);
      defineSymbol(math, main, spacing, " ", "\\ ");
      defineSymbol(math, main, spacing, " ", "\\space");
      defineSymbol(math, main, spacing, " ", "\\nobreakspace");
      defineSymbol(symbols_text, main, spacing, " ", "\\ ");
      defineSymbol(symbols_text, main, spacing, " ", " ");
      defineSymbol(symbols_text, main, spacing, " ", "\\space");
      defineSymbol(symbols_text, main, spacing, " ", "\\nobreakspace");
      defineSymbol(math, main, spacing, null, "\\nobreak");
      defineSymbol(math, main, spacing, null, "\\allowbreak");
      defineSymbol(math, main, punct, ",", ",");
      defineSymbol(math, main, punct, ";", ";");
      defineSymbol(math, ams, bin, "⊼", "\\barwedge", true);
      defineSymbol(math, ams, bin, "⊻", "\\veebar", true);
      defineSymbol(math, main, bin, "⊙", "\\odot", true);
      defineSymbol(math, main, bin, "⊕", "\\oplus", true);
      defineSymbol(math, main, bin, "⊗", "\\otimes", true);
      defineSymbol(math, main, textord, "∂", "\\partial", true);
      defineSymbol(math, main, bin, "⊘", "\\oslash", true);
      defineSymbol(math, ams, bin, "⊚", "\\circledcirc", true);
      defineSymbol(math, ams, bin, "⊡", "\\boxdot", true);
      defineSymbol(math, main, bin, "△", "\\bigtriangleup");
      defineSymbol(math, main, bin, "▽", "\\bigtriangledown");
      defineSymbol(math, main, bin, "†", "\\dagger");
      defineSymbol(math, main, bin, "⋄", "\\diamond");
      defineSymbol(math, main, bin, "⋆", "\\star");
      defineSymbol(math, main, bin, "◃", "\\triangleleft");
      defineSymbol(math, main, bin, "▹", "\\triangleright");
      defineSymbol(math, main, symbols_open, "{", "\\{");
      defineSymbol(symbols_text, main, textord, "{", "\\{");
      defineSymbol(symbols_text, main, textord, "{", "\\textbraceleft");
      defineSymbol(math, main, symbols_close, "}", "\\}");
      defineSymbol(symbols_text, main, textord, "}", "\\}");
      defineSymbol(symbols_text, main, textord, "}", "\\textbraceright");
      defineSymbol(math, main, symbols_open, "{", "\\lbrace");
      defineSymbol(math, main, symbols_close, "}", "\\rbrace");
      defineSymbol(math, main, symbols_open, "[", "\\lbrack", true);
      defineSymbol(symbols_text, main, textord, "[", "\\lbrack", true);
      defineSymbol(math, main, symbols_close, "]", "\\rbrack", true);
      defineSymbol(symbols_text, main, textord, "]", "\\rbrack", true);
      defineSymbol(math, main, symbols_open, "(", "\\lparen", true);
      defineSymbol(math, main, symbols_close, ")", "\\rparen", true);
      defineSymbol(symbols_text, main, textord, "<", "\\textless", true);
      defineSymbol(symbols_text, main, textord, ">", "\\textgreater", true);
      defineSymbol(math, main, symbols_open, "⌊", "\\lfloor", true);
      defineSymbol(math, main, symbols_close, "⌋", "\\rfloor", true);
      defineSymbol(math, main, symbols_open, "⌈", "\\lceil", true);
      defineSymbol(math, main, symbols_close, "⌉", "\\rceil", true);
      defineSymbol(math, main, textord, "\\", "\\backslash");
      defineSymbol(math, main, textord, "∣", "|");
      defineSymbol(math, main, textord, "∣", "\\vert");
      defineSymbol(symbols_text, main, textord, "|", "\\textbar", true);
      defineSymbol(math, main, textord, "∥", "\\|");
      defineSymbol(math, main, textord, "∥", "\\Vert");
      defineSymbol(symbols_text, main, textord, "∥", "\\textbardbl");
      defineSymbol(symbols_text, main, textord, "~", "\\textasciitilde");
      defineSymbol(symbols_text, main, textord, "\\", "\\textbackslash");
      defineSymbol(symbols_text, main, textord, "^", "\\textasciicircum");
      defineSymbol(math, main, rel, "↑", "\\uparrow", true);
      defineSymbol(math, main, rel, "⇑", "\\Uparrow", true);
      defineSymbol(math, main, rel, "↓", "\\downarrow", true);
      defineSymbol(math, main, rel, "⇓", "\\Downarrow", true);
      defineSymbol(math, main, rel, "↕", "\\updownarrow", true);
      defineSymbol(math, main, rel, "⇕", "\\Updownarrow", true);
      defineSymbol(math, main, op, "∐", "\\coprod");
      defineSymbol(math, main, op, "⋁", "\\bigvee");
      defineSymbol(math, main, op, "⋀", "\\bigwedge");
      defineSymbol(math, main, op, "⨄", "\\biguplus");
      defineSymbol(math, main, op, "⋂", "\\bigcap");
      defineSymbol(math, main, op, "⋃", "\\bigcup");
      defineSymbol(math, main, op, "∫", "\\int");
      defineSymbol(math, main, op, "∫", "\\intop");
      defineSymbol(math, main, op, "∬", "\\iint");
      defineSymbol(math, main, op, "∭", "\\iiint");
      defineSymbol(math, main, op, "∏", "\\prod");
      defineSymbol(math, main, op, "∑", "\\sum");
      defineSymbol(math, main, op, "⨂", "\\bigotimes");
      defineSymbol(math, main, op, "⨁", "\\bigoplus");
      defineSymbol(math, main, op, "⨀", "\\bigodot");
      defineSymbol(math, main, op, "∮", "\\oint");
      defineSymbol(math, main, op, "∯", "\\oiint");
      defineSymbol(math, main, op, "∰", "\\oiiint");
      defineSymbol(math, main, op, "⨆", "\\bigsqcup");
      defineSymbol(math, main, op, "∫", "\\smallint");
      defineSymbol(symbols_text, main, inner, "…", "\\textellipsis");
      defineSymbol(math, main, inner, "…", "\\mathellipsis");
      defineSymbol(symbols_text, main, inner, "…", "\\ldots", true);
      defineSymbol(math, main, inner, "…", "\\ldots", true);
      defineSymbol(math, main, inner, "⋯", "\\@cdots", true);
      defineSymbol(math, main, inner, "⋱", "\\ddots", true);
      defineSymbol(math, main, textord, "⋮", "\\varvdots");
      defineSymbol(symbols_text, main, textord, "⋮", "\\varvdots");
      defineSymbol(math, main, accent, "ˊ", "\\acute");
      defineSymbol(math, main, accent, "ˋ", "\\grave");
      defineSymbol(math, main, accent, "¨", "\\ddot");
      defineSymbol(math, main, accent, "~", "\\tilde");
      defineSymbol(math, main, accent, "ˉ", "\\bar");
      defineSymbol(math, main, accent, "˘", "\\breve");
      defineSymbol(math, main, accent, "ˇ", "\\check");
      defineSymbol(math, main, accent, "^", "\\hat");
      defineSymbol(math, main, accent, "⃗", "\\vec");
      defineSymbol(math, main, accent, "˙", "\\dot");
      defineSymbol(math, main, accent, "˚", "\\mathring");
      defineSymbol(math, main, mathord, "", "\\@imath");
      defineSymbol(math, main, mathord, "", "\\@jmath");
      defineSymbol(math, main, textord, "ı", "ı");
      defineSymbol(math, main, textord, "ȷ", "ȷ");
      defineSymbol(symbols_text, main, textord, "ı", "\\i", true);
      defineSymbol(symbols_text, main, textord, "ȷ", "\\j", true);
      defineSymbol(symbols_text, main, textord, "ß", "\\ss", true);
      defineSymbol(symbols_text, main, textord, "æ", "\\ae", true);
      defineSymbol(symbols_text, main, textord, "œ", "\\oe", true);
      defineSymbol(symbols_text, main, textord, "ø", "\\o", true);
      defineSymbol(symbols_text, main, textord, "Æ", "\\AE", true);
      defineSymbol(symbols_text, main, textord, "Œ", "\\OE", true);
      defineSymbol(symbols_text, main, textord, "Ø", "\\O", true);
      defineSymbol(symbols_text, main, accent, "ˊ", "\\'");
      defineSymbol(symbols_text, main, accent, "ˋ", "\\`");
      defineSymbol(symbols_text, main, accent, "ˆ", "\\^");
      defineSymbol(symbols_text, main, accent, "˜", "\\~");
      defineSymbol(symbols_text, main, accent, "ˉ", "\\=");
      defineSymbol(symbols_text, main, accent, "˘", "\\u");
      defineSymbol(symbols_text, main, accent, "˙", "\\.");
      defineSymbol(symbols_text, main, accent, "¸", "\\c");
      defineSymbol(symbols_text, main, accent, "˚", "\\r");
      defineSymbol(symbols_text, main, accent, "ˇ", "\\v");
      defineSymbol(symbols_text, main, accent, "¨", "\\\"");
      defineSymbol(symbols_text, main, accent, "˝", "\\H");
      defineSymbol(symbols_text, main, accent, "◯", "\\textcircled");
      const ligatures = {
        "--": true,
        "---": true,
        "``": true,
        "''": true
      };
      defineSymbol(symbols_text, main, textord, "–", "--", true);
      defineSymbol(symbols_text, main, textord, "–", "\\textendash");
      defineSymbol(symbols_text, main, textord, "—", "---", true);
      defineSymbol(symbols_text, main, textord, "—", "\\textemdash");
      defineSymbol(symbols_text, main, textord, "‘", "`", true);
      defineSymbol(symbols_text, main, textord, "‘", "\\textquoteleft");
      defineSymbol(symbols_text, main, textord, "’", "'", true);
      defineSymbol(symbols_text, main, textord, "’", "\\textquoteright");
      defineSymbol(symbols_text, main, textord, "“", "``", true);
      defineSymbol(symbols_text, main, textord, "“", "\\textquotedblleft");
      defineSymbol(symbols_text, main, textord, "”", "''", true);
      defineSymbol(symbols_text, main, textord, "”", "\\textquotedblright");
      defineSymbol(math, main, textord, "°", "\\degree", true);
      defineSymbol(symbols_text, main, textord, "°", "\\degree");
      defineSymbol(symbols_text, main, textord, "°", "\\textdegree", true);
      defineSymbol(math, main, textord, "£", "\\pounds");
      defineSymbol(math, main, textord, "£", "\\mathsterling", true);
      defineSymbol(symbols_text, main, textord, "£", "\\pounds");
      defineSymbol(symbols_text, main, textord, "£", "\\textsterling", true);
      defineSymbol(math, ams, textord, "✠", "\\maltese");
      defineSymbol(symbols_text, ams, textord, "✠", "\\maltese");
      const mathTextSymbols = '0123456789/@."';
      for (let i = 0;i < mathTextSymbols.length; i++) {
        const ch = mathTextSymbols.charAt(i);
        defineSymbol(math, main, textord, ch, ch);
      }
      const textSymbols = '0123456789!@*()-=+";:?/.,';
      for (let i = 0;i < textSymbols.length; i++) {
        const ch = textSymbols.charAt(i);
        defineSymbol(symbols_text, main, textord, ch, ch);
      }
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      for (let i = 0;i < letters.length; i++) {
        const ch = letters.charAt(i);
        defineSymbol(math, main, mathord, ch, ch);
        defineSymbol(symbols_text, main, textord, ch, ch);
      }
      defineSymbol(math, ams, textord, "C", "ℂ");
      defineSymbol(symbols_text, ams, textord, "C", "ℂ");
      defineSymbol(math, ams, textord, "H", "ℍ");
      defineSymbol(symbols_text, ams, textord, "H", "ℍ");
      defineSymbol(math, ams, textord, "N", "ℕ");
      defineSymbol(symbols_text, ams, textord, "N", "ℕ");
      defineSymbol(math, ams, textord, "P", "ℙ");
      defineSymbol(symbols_text, ams, textord, "P", "ℙ");
      defineSymbol(math, ams, textord, "Q", "ℚ");
      defineSymbol(symbols_text, ams, textord, "Q", "ℚ");
      defineSymbol(math, ams, textord, "R", "ℝ");
      defineSymbol(symbols_text, ams, textord, "R", "ℝ");
      defineSymbol(math, ams, textord, "Z", "ℤ");
      defineSymbol(symbols_text, ams, textord, "Z", "ℤ");
      defineSymbol(math, main, mathord, "h", "ℎ");
      defineSymbol(symbols_text, main, mathord, "h", "ℎ");
      let wideChar = "";
      for (let i = 0;i < letters.length; i++) {
        const ch = letters.charAt(i);
        wideChar = String.fromCharCode(55349, 56320 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
        wideChar = String.fromCharCode(55349, 56372 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
        wideChar = String.fromCharCode(55349, 56424 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
        wideChar = String.fromCharCode(55349, 56580 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
        wideChar = String.fromCharCode(55349, 56684 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
        wideChar = String.fromCharCode(55349, 56736 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
        wideChar = String.fromCharCode(55349, 56788 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
        wideChar = String.fromCharCode(55349, 56840 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
        wideChar = String.fromCharCode(55349, 56944 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
        if (i < 26) {
          wideChar = String.fromCharCode(55349, 56632 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56476 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
        }
      }
      wideChar = String.fromCharCode(55349, 56668);
      defineSymbol(math, main, mathord, "k", wideChar);
      defineSymbol(symbols_text, main, textord, "k", wideChar);
      for (let i = 0;i < 10; i++) {
        const ch = i.toString();
        wideChar = String.fromCharCode(55349, 57294 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
        wideChar = String.fromCharCode(55349, 57314 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
        wideChar = String.fromCharCode(55349, 57324 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
        wideChar = String.fromCharCode(55349, 57334 + i);
        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(symbols_text, main, textord, ch, wideChar);
      }
      const extraLatin = "ÐÞþ";
      for (let i = 0;i < extraLatin.length; i++) {
        const ch = extraLatin.charAt(i);
        defineSymbol(math, main, mathord, ch, ch);
        defineSymbol(symbols_text, main, textord, ch, ch);
      }
      const wideLatinLetterData = [
        ["mathbf", "textbf", "Main-Bold"],
        ["mathbf", "textbf", "Main-Bold"],
        ["mathnormal", "textit", "Math-Italic"],
        ["mathnormal", "textit", "Math-Italic"],
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        ["mathscr", "textscr", "Script-Regular"],
        ["", "", ""],
        ["", "", ""],
        ["", "", ""],
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        ["mathbb", "textbb", "AMS-Regular"],
        ["mathbb", "textbb", "AMS-Regular"],
        ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
        ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
        ["mathsf", "textsf", "SansSerif-Regular"],
        ["mathsf", "textsf", "SansSerif-Regular"],
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        ["", "", ""],
        ["", "", ""],
        ["mathtt", "texttt", "Typewriter-Regular"],
        ["mathtt", "texttt", "Typewriter-Regular"]
      ];
      const wideNumeralData = [
        ["mathbf", "textbf", "Main-Bold"],
        ["", "", ""],
        ["mathsf", "textsf", "SansSerif-Regular"],
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        ["mathtt", "texttt", "Typewriter-Regular"]
      ];
      const wideCharacterFont = function(wideChar2, mode) {
        const H4 = wideChar2.charCodeAt(0);
        const L5 = wideChar2.charCodeAt(1);
        const codePoint = (H4 - 55296) * 1024 + (L5 - 56320) + 65536;
        const j4 = mode === "math" ? 0 : 1;
        if (119808 <= codePoint && codePoint < 120484) {
          const i = Math.floor((codePoint - 119808) / 26);
          return [wideLatinLetterData[i][2], wideLatinLetterData[i][j4]];
        } else if (120782 <= codePoint && codePoint <= 120831) {
          const i = Math.floor((codePoint - 120782) / 10);
          return [wideNumeralData[i][2], wideNumeralData[i][j4]];
        } else if (codePoint === 120485 || codePoint === 120486) {
          return [wideLatinLetterData[0][2], wideLatinLetterData[0][j4]];
        } else if (120486 < codePoint && codePoint < 120782) {
          return ["", ""];
        } else {
          throw new src_ParseError("Unsupported character: " + wideChar2);
        }
      };
      const lookupSymbol = function(value, fontName, mode) {
        if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
          value = src_symbols[mode][value].replace;
        }
        return {
          value,
          metrics: getCharacterMetrics(value, fontName, mode)
        };
      };
      const makeSymbol = function(value, fontName, mode, options, classes) {
        const lookup = lookupSymbol(value, fontName, mode);
        const metrics = lookup.metrics;
        value = lookup.value;
        let symbolNode;
        if (metrics) {
          let italic = metrics.italic;
          if (mode === "text" || options && options.font === "mathit") {
            italic = 0;
          }
          symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
        } else {
          typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
          symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
        }
        if (options) {
          symbolNode.maxFontSize = options.sizeMultiplier;
          if (options.style.isTight()) {
            symbolNode.classes.push("mtight");
          }
          const color = options.getColor();
          if (color) {
            symbolNode.style.color = color;
          }
        }
        return symbolNode;
      };
      const mathsym = function(value, mode, options, classes) {
        if (classes === undefined) {
          classes = [];
        }
        if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
          return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
        } else if (value === "\\" || src_symbols[mode][value].font === "main") {
          return makeSymbol(value, "Main-Regular", mode, options, classes);
        } else {
          return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
        }
      };
      const boldsymbol = function(value, mode, options, classes, type) {
        if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
          return {
            fontName: "Math-BoldItalic",
            fontClass: "boldsymbol"
          };
        } else {
          return {
            fontName: "Main-Bold",
            fontClass: "mathbf"
          };
        }
      };
      const makeOrd = function(group, options, type) {
        const mode = group.mode;
        const text = group.text;
        const classes = ["mord"];
        const isFont = mode === "math" || mode === "text" && options.font;
        const fontOrFamily = isFont ? options.font : options.fontFamily;
        let wideFontName = "";
        let wideFontClass = "";
        if (text.charCodeAt(0) === 55349) {
          [wideFontName, wideFontClass] = wideCharacterFont(text, mode);
        }
        if (wideFontName.length > 0) {
          return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));
        } else if (fontOrFamily) {
          let fontName;
          let fontClasses;
          if (fontOrFamily === "boldsymbol") {
            const fontData = boldsymbol(text, mode, options, classes, type);
            fontName = fontData.fontName;
            fontClasses = [fontData.fontClass];
          } else if (isFont) {
            fontName = fontMap[fontOrFamily].fontName;
            fontClasses = [fontOrFamily];
          } else {
            fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
            fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
          }
          if (lookupSymbol(text, fontName, mode).metrics) {
            return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));
          } else if (ligatures.hasOwnProperty(text) && fontName.slice(0, 10) === "Typewriter") {
            const parts = [];
            for (let i = 0;i < text.length; i++) {
              parts.push(makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));
            }
            return makeFragment(parts);
          }
        }
        if (type === "mathord") {
          return makeSymbol(text, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
        } else if (type === "textord") {
          const font = src_symbols[mode][text] && src_symbols[mode][text].font;
          if (font === "ams") {
            const fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
            return makeSymbol(text, fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
          } else if (font === "main" || !font) {
            const fontName = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
            return makeSymbol(text, fontName, mode, options, classes.concat(options.fontWeight, options.fontShape));
          } else {
            const fontName = retrieveTextFontName(font, options.fontWeight, options.fontShape);
            return makeSymbol(text, fontName, mode, options, classes.concat(fontName, options.fontWeight, options.fontShape));
          }
        } else {
          throw new Error("unexpected type: " + type + " in makeOrd");
        }
      };
      const canCombine = (prev, next) => {
        if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
          return false;
        }
        if (prev.classes.length === 1) {
          const cls = prev.classes[0];
          if (cls === "mbin" || cls === "mord") {
            return false;
          }
        }
        for (const style in prev.style) {
          if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
            return false;
          }
        }
        for (const style in next.style) {
          if (next.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
            return false;
          }
        }
        return true;
      };
      const tryCombineChars = (chars) => {
        for (let i = 0;i < chars.length - 1; i++) {
          const prev = chars[i];
          const next = chars[i + 1];
          if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
            prev.text += next.text;
            prev.height = Math.max(prev.height, next.height);
            prev.depth = Math.max(prev.depth, next.depth);
            prev.italic = next.italic;
            chars.splice(i + 1, 1);
            i--;
          }
        }
        return chars;
      };
      const sizeElementFromChildren = function(elem) {
        let height = 0;
        let depth = 0;
        let maxFontSize = 0;
        for (let i = 0;i < elem.children.length; i++) {
          const child = elem.children[i];
          if (child.height > height) {
            height = child.height;
          }
          if (child.depth > depth) {
            depth = child.depth;
          }
          if (child.maxFontSize > maxFontSize) {
            maxFontSize = child.maxFontSize;
          }
        }
        elem.height = height;
        elem.depth = depth;
        elem.maxFontSize = maxFontSize;
      };
      const makeSpan = function(classes, children, options, style) {
        const span = new Span(classes, children, options, style);
        sizeElementFromChildren(span);
        return span;
      };
      const makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);
      const makeLineSpan = function(className, options, thickness) {
        const line = makeSpan([className], [], options);
        line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
        line.style.borderBottomWidth = makeEm(line.height);
        line.maxFontSize = 1;
        return line;
      };
      const makeAnchor = function(href, classes, children, options) {
        const anchor = new Anchor(href, classes, children, options);
        sizeElementFromChildren(anchor);
        return anchor;
      };
      const makeFragment = function(children) {
        const fragment = new DocumentFragment2(children);
        sizeElementFromChildren(fragment);
        return fragment;
      };
      const wrapFragment = function(group, options) {
        if (group instanceof DocumentFragment2) {
          return makeSpan([], [group], options);
        }
        return group;
      };
      const getVListChildrenAndDepth = function(params) {
        if (params.positionType === "individualShift") {
          const oldChildren = params.children;
          const children = [oldChildren[0]];
          const depth2 = -oldChildren[0].shift - oldChildren[0].elem.depth;
          let currPos = depth2;
          for (let i = 1;i < oldChildren.length; i++) {
            const diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
            const size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
            currPos = currPos + diff;
            children.push({
              type: "kern",
              size
            });
            children.push(oldChildren[i]);
          }
          return {
            children,
            depth: depth2
          };
        }
        let depth;
        if (params.positionType === "top") {
          let bottom = params.positionData;
          for (let i = 0;i < params.children.length; i++) {
            const child = params.children[i];
            bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
          }
          depth = bottom;
        } else if (params.positionType === "bottom") {
          depth = -params.positionData;
        } else {
          const firstChild = params.children[0];
          if (firstChild.type !== "elem") {
            throw new Error('First child must have type "elem".');
          }
          if (params.positionType === "shift") {
            depth = -firstChild.elem.depth - params.positionData;
          } else if (params.positionType === "firstBaseline") {
            depth = -firstChild.elem.depth;
          } else {
            throw new Error("Invalid positionType " + params.positionType + ".");
          }
        }
        return {
          children: params.children,
          depth
        };
      };
      const makeVList = function(params, options) {
        const {
          children,
          depth
        } = getVListChildrenAndDepth(params);
        let pstrutSize = 0;
        for (let i = 0;i < children.length; i++) {
          const child = children[i];
          if (child.type === "elem") {
            const elem = child.elem;
            pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
          }
        }
        pstrutSize += 2;
        const pstrut = makeSpan(["pstrut"], []);
        pstrut.style.height = makeEm(pstrutSize);
        const realChildren = [];
        let minPos = depth;
        let maxPos = depth;
        let currPos = depth;
        for (let i = 0;i < children.length; i++) {
          const child = children[i];
          if (child.type === "kern") {
            currPos += child.size;
          } else {
            const elem = child.elem;
            const classes = child.wrapperClasses || [];
            const style = child.wrapperStyle || {};
            const childWrap = makeSpan(classes, [pstrut, elem], undefined, style);
            childWrap.style.top = makeEm(-pstrutSize - currPos - elem.depth);
            if (child.marginLeft) {
              childWrap.style.marginLeft = child.marginLeft;
            }
            if (child.marginRight) {
              childWrap.style.marginRight = child.marginRight;
            }
            realChildren.push(childWrap);
            currPos += elem.height + elem.depth;
          }
          minPos = Math.min(minPos, currPos);
          maxPos = Math.max(maxPos, currPos);
        }
        const vlist = makeSpan(["vlist"], realChildren);
        vlist.style.height = makeEm(maxPos);
        let rows;
        if (minPos < 0) {
          const emptySpan = makeSpan([], []);
          const depthStrut = makeSpan(["vlist"], [emptySpan]);
          depthStrut.style.height = makeEm(-minPos);
          const topStrut = makeSpan(["vlist-s"], [new SymbolNode("​")]);
          rows = [makeSpan(["vlist-r"], [vlist, topStrut]), makeSpan(["vlist-r"], [depthStrut])];
        } else {
          rows = [makeSpan(["vlist-r"], [vlist])];
        }
        const vtable = makeSpan(["vlist-t"], rows);
        if (rows.length === 2) {
          vtable.classes.push("vlist-t2");
        }
        vtable.height = maxPos;
        vtable.depth = -minPos;
        return vtable;
      };
      const makeGlue = (measurement, options) => {
        const rule = makeSpan(["mspace"], [], options);
        const size = calculateSize(measurement, options);
        rule.style.marginRight = makeEm(size);
        return rule;
      };
      const retrieveTextFontName = function(fontFamily, fontWeight, fontShape) {
        let baseFontName = "";
        switch (fontFamily) {
          case "amsrm":
            baseFontName = "AMS";
            break;
          case "textrm":
            baseFontName = "Main";
            break;
          case "textsf":
            baseFontName = "SansSerif";
            break;
          case "texttt":
            baseFontName = "Typewriter";
            break;
          default:
            baseFontName = fontFamily;
        }
        let fontStylesName;
        if (fontWeight === "textbf" && fontShape === "textit") {
          fontStylesName = "BoldItalic";
        } else if (fontWeight === "textbf") {
          fontStylesName = "Bold";
        } else if (fontWeight === "textit") {
          fontStylesName = "Italic";
        } else {
          fontStylesName = "Regular";
        }
        return baseFontName + "-" + fontStylesName;
      };
      const fontMap = {
        mathbf: {
          variant: "bold",
          fontName: "Main-Bold"
        },
        mathrm: {
          variant: "normal",
          fontName: "Main-Regular"
        },
        textit: {
          variant: "italic",
          fontName: "Main-Italic"
        },
        mathit: {
          variant: "italic",
          fontName: "Main-Italic"
        },
        mathnormal: {
          variant: "italic",
          fontName: "Math-Italic"
        },
        mathsfit: {
          variant: "sans-serif-italic",
          fontName: "SansSerif-Italic"
        },
        mathbb: {
          variant: "double-struck",
          fontName: "AMS-Regular"
        },
        mathcal: {
          variant: "script",
          fontName: "Caligraphic-Regular"
        },
        mathfrak: {
          variant: "fraktur",
          fontName: "Fraktur-Regular"
        },
        mathscr: {
          variant: "script",
          fontName: "Script-Regular"
        },
        mathsf: {
          variant: "sans-serif",
          fontName: "SansSerif-Regular"
        },
        mathtt: {
          variant: "monospace",
          fontName: "Typewriter-Regular"
        }
      };
      const svgData = {
        vec: ["vec", 0.471, 0.714],
        oiintSize1: ["oiintSize1", 0.957, 0.499],
        oiintSize2: ["oiintSize2", 1.472, 0.659],
        oiiintSize1: ["oiiintSize1", 1.304, 0.499],
        oiiintSize2: ["oiiintSize2", 1.98, 0.659]
      };
      const staticSvg = function(value, options) {
        const [pathName, width, height] = svgData[value];
        const path2 = new PathNode(pathName);
        const svgNode = new SvgNode([path2], {
          width: makeEm(width),
          height: makeEm(height),
          style: "width:" + makeEm(width),
          viewBox: "0 0 " + 1000 * width + " " + 1000 * height,
          preserveAspectRatio: "xMinYMin"
        });
        const span = makeSvgSpan(["overlay"], [svgNode], options);
        span.height = height;
        span.style.height = makeEm(height);
        span.style.width = makeEm(width);
        return span;
      };
      var buildCommon = {
        fontMap,
        makeSymbol,
        mathsym,
        makeSpan,
        makeSvgSpan,
        makeLineSpan,
        makeAnchor,
        makeFragment,
        wrapFragment,
        makeVList,
        makeOrd,
        makeGlue,
        staticSvg,
        svgData,
        tryCombineChars
      };
      const thinspace = {
        number: 3,
        unit: "mu"
      };
      const mediumspace = {
        number: 4,
        unit: "mu"
      };
      const thickspace = {
        number: 5,
        unit: "mu"
      };
      const spacings = {
        mord: {
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          minner: thinspace
        },
        mop: {
          mord: thinspace,
          mop: thinspace,
          mrel: thickspace,
          minner: thinspace
        },
        mbin: {
          mord: mediumspace,
          mop: mediumspace,
          mopen: mediumspace,
          minner: mediumspace
        },
        mrel: {
          mord: thickspace,
          mop: thickspace,
          mopen: thickspace,
          minner: thickspace
        },
        mopen: {},
        mclose: {
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          minner: thinspace
        },
        mpunct: {
          mord: thinspace,
          mop: thinspace,
          mrel: thickspace,
          mopen: thinspace,
          mclose: thinspace,
          mpunct: thinspace,
          minner: thinspace
        },
        minner: {
          mord: thinspace,
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          mopen: thinspace,
          mpunct: thinspace,
          minner: thinspace
        }
      };
      const tightSpacings = {
        mord: {
          mop: thinspace
        },
        mop: {
          mord: thinspace,
          mop: thinspace
        },
        mbin: {},
        mrel: {},
        mopen: {},
        mclose: {
          mop: thinspace
        },
        mpunct: {},
        minner: {
          mop: thinspace
        }
      };
      const _functions = {};
      const _htmlGroupBuilders = {};
      const _mathmlGroupBuilders = {};
      function defineFunction(_ref) {
        let {
          type,
          names,
          props,
          handler,
          htmlBuilder: htmlBuilder2,
          mathmlBuilder: mathmlBuilder2
        } = _ref;
        const data = {
          type,
          numArgs: props.numArgs,
          argTypes: props.argTypes,
          allowedInArgument: !!props.allowedInArgument,
          allowedInText: !!props.allowedInText,
          allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,
          numOptionalArgs: props.numOptionalArgs || 0,
          infix: !!props.infix,
          primitive: !!props.primitive,
          handler
        };
        for (let i = 0;i < names.length; ++i) {
          _functions[names[i]] = data;
        }
        if (type) {
          if (htmlBuilder2) {
            _htmlGroupBuilders[type] = htmlBuilder2;
          }
          if (mathmlBuilder2) {
            _mathmlGroupBuilders[type] = mathmlBuilder2;
          }
        }
      }
      function defineFunctionBuilders(_ref2) {
        let {
          type,
          htmlBuilder: htmlBuilder2,
          mathmlBuilder: mathmlBuilder2
        } = _ref2;
        defineFunction({
          type,
          names: [],
          props: {
            numArgs: 0
          },
          handler() {
            throw new Error("Should never be called.");
          },
          htmlBuilder: htmlBuilder2,
          mathmlBuilder: mathmlBuilder2
        });
      }
      const normalizeArgument = function(arg) {
        return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
      };
      const ordargument = function(arg) {
        return arg.type === "ordgroup" ? arg.body : [arg];
      };
      const buildHTML_makeSpan = buildCommon.makeSpan;
      const binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
      const binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
      const styleMap = {
        display: src_Style.DISPLAY,
        text: src_Style.TEXT,
        script: src_Style.SCRIPT,
        scriptscript: src_Style.SCRIPTSCRIPT
      };
      const DomEnum = {
        mord: "mord",
        mop: "mop",
        mbin: "mbin",
        mrel: "mrel",
        mopen: "mopen",
        mclose: "mclose",
        mpunct: "mpunct",
        minner: "minner"
      };
      const buildExpression = function(expression, options, isRealGroup, surrounding) {
        if (surrounding === undefined) {
          surrounding = [null, null];
        }
        const groups = [];
        for (let i = 0;i < expression.length; i++) {
          const output = buildGroup(expression[i], options);
          if (output instanceof DocumentFragment2) {
            const children = output.children;
            groups.push(...children);
          } else {
            groups.push(output);
          }
        }
        buildCommon.tryCombineChars(groups);
        if (!isRealGroup) {
          return groups;
        }
        let glueOptions = options;
        if (expression.length === 1) {
          const node = expression[0];
          if (node.type === "sizing") {
            glueOptions = options.havingSize(node.size);
          } else if (node.type === "styling") {
            glueOptions = options.havingStyle(styleMap[node.style]);
          }
        }
        const dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
        const dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
        const isRoot = isRealGroup === "root";
        traverseNonSpaceNodes(groups, (node, prev) => {
          const prevType = prev.classes[0];
          const type = node.classes[0];
          if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
            prev.classes[0] = "mord";
          } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
            node.classes[0] = "mord";
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        traverseNonSpaceNodes(groups, (node, prev) => {
          const prevType = getTypeOfDomTree(prev);
          const type = getTypeOfDomTree(node);
          const space = prevType && type ? node.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
          if (space) {
            return buildCommon.makeGlue(space, glueOptions);
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        return groups;
      };
      const traverseNonSpaceNodes = function(nodes, callback, prev, next, isRoot) {
        if (next) {
          nodes.push(next);
        }
        let i = 0;
        for (;i < nodes.length; i++) {
          const node = nodes[i];
          const partialGroup = checkPartialGroup(node);
          if (partialGroup) {
            traverseNonSpaceNodes(partialGroup.children, callback, prev, null, isRoot);
            continue;
          }
          const nonspace = !node.hasClass("mspace");
          if (nonspace) {
            const result = callback(node, prev.node);
            if (result) {
              if (prev.insertAfter) {
                prev.insertAfter(result);
              } else {
                nodes.unshift(result);
                i++;
              }
            }
          }
          if (nonspace) {
            prev.node = node;
          } else if (isRoot && node.hasClass("newline")) {
            prev.node = buildHTML_makeSpan(["leftmost"]);
          }
          prev.insertAfter = ((index) => (n) => {
            nodes.splice(index + 1, 0, n);
            i++;
          })(i);
        }
        if (next) {
          nodes.pop();
        }
      };
      const checkPartialGroup = function(node) {
        if (node instanceof DocumentFragment2 || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
          return node;
        }
        return null;
      };
      const getOutermostNode = function(node, side) {
        const partialGroup = checkPartialGroup(node);
        if (partialGroup) {
          const children = partialGroup.children;
          if (children.length) {
            if (side === "right") {
              return getOutermostNode(children[children.length - 1], "right");
            } else if (side === "left") {
              return getOutermostNode(children[0], "left");
            }
          }
        }
        return node;
      };
      const getTypeOfDomTree = function(node, side) {
        if (!node) {
          return null;
        }
        if (side) {
          node = getOutermostNode(node, side);
        }
        return DomEnum[node.classes[0]] || null;
      };
      const makeNullDelimiter = function(options, classes) {
        const moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
        return buildHTML_makeSpan(classes.concat(moreClasses));
      };
      const buildGroup = function(group, options, baseOptions) {
        if (!group) {
          return buildHTML_makeSpan();
        }
        if (_htmlGroupBuilders[group.type]) {
          let groupNode = _htmlGroupBuilders[group.type](group, options);
          if (baseOptions && options.size !== baseOptions.size) {
            groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
            const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
          }
          return groupNode;
        } else {
          throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
        }
      };
      function buildHTMLUnbreakable(children, options) {
        const body = buildHTML_makeSpan(["base"], children, options);
        const strut = buildHTML_makeSpan(["strut"]);
        strut.style.height = makeEm(body.height + body.depth);
        if (body.depth) {
          strut.style.verticalAlign = makeEm(-body.depth);
        }
        body.children.unshift(strut);
        return body;
      }
      function buildHTML(tree, options) {
        let tag = null;
        if (tree.length === 1 && tree[0].type === "tag") {
          tag = tree[0].tag;
          tree = tree[0].body;
        }
        const expression = buildExpression(tree, options, "root");
        let eqnNum;
        if (expression.length === 2 && expression[1].hasClass("tag")) {
          eqnNum = expression.pop();
        }
        const children = [];
        let parts = [];
        for (let i = 0;i < expression.length; i++) {
          parts.push(expression[i]);
          if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
            let nobreak = false;
            while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
              i++;
              parts.push(expression[i]);
              if (expression[i].hasClass("nobreak")) {
                nobreak = true;
              }
            }
            if (!nobreak) {
              children.push(buildHTMLUnbreakable(parts, options));
              parts = [];
            }
          } else if (expression[i].hasClass("newline")) {
            parts.pop();
            if (parts.length > 0) {
              children.push(buildHTMLUnbreakable(parts, options));
              parts = [];
            }
            children.push(expression[i]);
          }
        }
        if (parts.length > 0) {
          children.push(buildHTMLUnbreakable(parts, options));
        }
        let tagChild;
        if (tag) {
          tagChild = buildHTMLUnbreakable(buildExpression(tag, options, true));
          tagChild.classes = ["tag"];
          children.push(tagChild);
        } else if (eqnNum) {
          children.push(eqnNum);
        }
        const htmlNode = buildHTML_makeSpan(["katex-html"], children);
        htmlNode.setAttribute("aria-hidden", "true");
        if (tagChild) {
          const strut = tagChild.children[0];
          strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
          if (htmlNode.depth) {
            strut.style.verticalAlign = makeEm(-htmlNode.depth);
          }
        }
        return htmlNode;
      }
      function newDocumentFragment(children) {
        return new DocumentFragment2(children);
      }

      class MathNode {
        constructor(type, children, classes) {
          this.type = undefined;
          this.attributes = undefined;
          this.children = undefined;
          this.classes = undefined;
          this.type = type;
          this.attributes = {};
          this.children = children || [];
          this.classes = classes || [];
        }
        setAttribute(name, value) {
          this.attributes[name] = value;
        }
        getAttribute(name) {
          return this.attributes[name];
        }
        toNode() {
          const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
          for (const attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          if (this.classes.length > 0) {
            node.className = createClass(this.classes);
          }
          for (let i = 0;i < this.children.length; i++) {
            if (this.children[i] instanceof TextNode && this.children[i + 1] instanceof TextNode) {
              let text = this.children[i].toText() + this.children[++i].toText();
              while (this.children[i + 1] instanceof TextNode) {
                text += this.children[++i].toText();
              }
              node.appendChild(new TextNode(text).toNode());
            } else {
              node.appendChild(this.children[i].toNode());
            }
          }
          return node;
        }
        toMarkup() {
          let markup = "<" + this.type;
          for (const attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="';
              markup += utils.escape(this.attributes[attr]);
              markup += '"';
            }
          }
          if (this.classes.length > 0) {
            markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
          }
          markup += ">";
          for (let i = 0;i < this.children.length; i++) {
            markup += this.children[i].toMarkup();
          }
          markup += "</" + this.type + ">";
          return markup;
        }
        toText() {
          return this.children.map((child) => child.toText()).join("");
        }
      }

      class TextNode {
        constructor(text) {
          this.text = undefined;
          this.text = text;
        }
        toNode() {
          return document.createTextNode(this.text);
        }
        toMarkup() {
          return utils.escape(this.toText());
        }
        toText() {
          return this.text;
        }
      }

      class SpaceNode {
        constructor(width) {
          this.width = undefined;
          this.character = undefined;
          this.width = width;
          if (width >= 0.05555 && width <= 0.05556) {
            this.character = " ";
          } else if (width >= 0.1666 && width <= 0.1667) {
            this.character = " ";
          } else if (width >= 0.2222 && width <= 0.2223) {
            this.character = " ";
          } else if (width >= 0.2777 && width <= 0.2778) {
            this.character = "  ";
          } else if (width >= -0.05556 && width <= -0.05555) {
            this.character = " ⁣";
          } else if (width >= -0.1667 && width <= -0.1666) {
            this.character = " ⁣";
          } else if (width >= -0.2223 && width <= -0.2222) {
            this.character = " ⁣";
          } else if (width >= -0.2778 && width <= -0.2777) {
            this.character = " ⁣";
          } else {
            this.character = null;
          }
        }
        toNode() {
          if (this.character) {
            return document.createTextNode(this.character);
          } else {
            const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
            node.setAttribute("width", makeEm(this.width));
            return node;
          }
        }
        toMarkup() {
          if (this.character) {
            return "<mtext>" + this.character + "</mtext>";
          } else {
            return '<mspace width="' + makeEm(this.width) + '"/>';
          }
        }
        toText() {
          if (this.character) {
            return this.character;
          } else {
            return " ";
          }
        }
      }
      var mathMLTree = {
        MathNode,
        TextNode,
        SpaceNode,
        newDocumentFragment
      };
      const makeText = function(text, mode, options) {
        if (src_symbols[mode][text] && src_symbols[mode][text].replace && text.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
          text = src_symbols[mode][text].replace;
        }
        return new mathMLTree.TextNode(text);
      };
      const makeRow = function(body) {
        if (body.length === 1) {
          return body[0];
        } else {
          return new mathMLTree.MathNode("mrow", body);
        }
      };
      const getVariant = function(group, options) {
        if (options.fontFamily === "texttt") {
          return "monospace";
        } else if (options.fontFamily === "textsf") {
          if (options.fontShape === "textit" && options.fontWeight === "textbf") {
            return "sans-serif-bold-italic";
          } else if (options.fontShape === "textit") {
            return "sans-serif-italic";
          } else if (options.fontWeight === "textbf") {
            return "bold-sans-serif";
          } else {
            return "sans-serif";
          }
        } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
          return "bold-italic";
        } else if (options.fontShape === "textit") {
          return "italic";
        } else if (options.fontWeight === "textbf") {
          return "bold";
        }
        const font = options.font;
        if (!font || font === "mathnormal") {
          return null;
        }
        const mode = group.mode;
        if (font === "mathit") {
          return "italic";
        } else if (font === "boldsymbol") {
          return group.type === "textord" ? "bold" : "bold-italic";
        } else if (font === "mathbf") {
          return "bold";
        } else if (font === "mathbb") {
          return "double-struck";
        } else if (font === "mathsfit") {
          return "sans-serif-italic";
        } else if (font === "mathfrak") {
          return "fraktur";
        } else if (font === "mathscr" || font === "mathcal") {
          return "script";
        } else if (font === "mathsf") {
          return "sans-serif";
        } else if (font === "mathtt") {
          return "monospace";
        }
        let text = group.text;
        if (utils.contains(["\\imath", "\\jmath"], text)) {
          return null;
        }
        if (src_symbols[mode][text] && src_symbols[mode][text].replace) {
          text = src_symbols[mode][text].replace;
        }
        const fontName = buildCommon.fontMap[font].fontName;
        if (getCharacterMetrics(text, fontName, mode)) {
          return buildCommon.fontMap[font].variant;
        }
        return null;
      };
      function isNumberPunctuation(group) {
        if (!group) {
          return false;
        }
        if (group.type === "mi" && group.children.length === 1) {
          const child = group.children[0];
          return child instanceof TextNode && child.text === ".";
        } else if (group.type === "mo" && group.children.length === 1 && group.getAttribute("separator") === "true" && group.getAttribute("lspace") === "0em" && group.getAttribute("rspace") === "0em") {
          const child = group.children[0];
          return child instanceof TextNode && child.text === ",";
        } else {
          return false;
        }
      }
      const buildMathML_buildExpression = function(expression, options, isOrdgroup) {
        if (expression.length === 1) {
          const group = buildMathML_buildGroup(expression[0], options);
          if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
            group.setAttribute("lspace", "0em");
            group.setAttribute("rspace", "0em");
          }
          return [group];
        }
        const groups = [];
        let lastGroup;
        for (let i = 0;i < expression.length; i++) {
          const group = buildMathML_buildGroup(expression[i], options);
          if (group instanceof MathNode && lastGroup instanceof MathNode) {
            if (group.type === "mtext" && lastGroup.type === "mtext" && group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
              lastGroup.children.push(...group.children);
              continue;
            } else if (group.type === "mn" && lastGroup.type === "mn") {
              lastGroup.children.push(...group.children);
              continue;
            } else if (isNumberPunctuation(group) && lastGroup.type === "mn") {
              lastGroup.children.push(...group.children);
              continue;
            } else if (group.type === "mn" && isNumberPunctuation(lastGroup)) {
              group.children = [...lastGroup.children, ...group.children];
              groups.pop();
            } else if ((group.type === "msup" || group.type === "msub") && group.children.length >= 1 && (lastGroup.type === "mn" || isNumberPunctuation(lastGroup))) {
              const base = group.children[0];
              if (base instanceof MathNode && base.type === "mn") {
                base.children = [...lastGroup.children, ...base.children];
                groups.pop();
              }
            } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
              const lastChild = lastGroup.children[0];
              if (lastChild instanceof TextNode && lastChild.text === "̸" && (group.type === "mo" || group.type === "mi" || group.type === "mn")) {
                const child = group.children[0];
                if (child instanceof TextNode && child.text.length > 0) {
                  child.text = child.text.slice(0, 1) + "̸" + child.text.slice(1);
                  groups.pop();
                }
              }
            }
          }
          groups.push(group);
          lastGroup = group;
        }
        return groups;
      };
      const buildExpressionRow = function(expression, options, isOrdgroup) {
        return makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));
      };
      const buildMathML_buildGroup = function(group, options) {
        if (!group) {
          return new mathMLTree.MathNode("mrow");
        }
        if (_mathmlGroupBuilders[group.type]) {
          const result = _mathmlGroupBuilders[group.type](group, options);
          return result;
        } else {
          throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
        }
      };
      function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
        const expression = buildMathML_buildExpression(tree, options);
        let wrapper;
        if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
          wrapper = expression[0];
        } else {
          wrapper = new mathMLTree.MathNode("mrow", expression);
        }
        const annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
        annotation.setAttribute("encoding", "application/x-tex");
        const semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
        const math2 = new mathMLTree.MathNode("math", [semantics]);
        math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
        if (isDisplayMode) {
          math2.setAttribute("display", "block");
        }
        const wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
        return buildCommon.makeSpan([wrapperClass], [math2]);
      }
      const optionsFromSettings = function(settings) {
        return new src_Options({
          style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
          maxSize: settings.maxSize,
          minRuleThickness: settings.minRuleThickness
        });
      };
      const displayWrap = function(node, settings) {
        if (settings.displayMode) {
          const classes = ["katex-display"];
          if (settings.leqno) {
            classes.push("leqno");
          }
          if (settings.fleqn) {
            classes.push("fleqn");
          }
          node = buildCommon.makeSpan(classes, [node]);
        }
        return node;
      };
      const buildTree = function(tree, expression, settings) {
        const options = optionsFromSettings(settings);
        let katexNode;
        if (settings.output === "mathml") {
          return buildMathML(tree, expression, options, settings.displayMode, true);
        } else if (settings.output === "html") {
          const htmlNode = buildHTML(tree, options);
          katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
        } else {
          const mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
          const htmlNode = buildHTML(tree, options);
          katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, htmlNode]);
        }
        return displayWrap(katexNode, settings);
      };
      const buildHTMLTree = function(tree, expression, settings) {
        const options = optionsFromSettings(settings);
        const htmlNode = buildHTML(tree, options);
        const katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
        return displayWrap(katexNode, settings);
      };
      var src_buildTree = null;
      const stretchyCodePoint = {
        widehat: "^",
        widecheck: "ˇ",
        widetilde: "~",
        utilde: "~",
        overleftarrow: "←",
        underleftarrow: "←",
        xleftarrow: "←",
        overrightarrow: "→",
        underrightarrow: "→",
        xrightarrow: "→",
        underbrace: "⏟",
        overbrace: "⏞",
        overgroup: "⏠",
        undergroup: "⏡",
        overleftrightarrow: "↔",
        underleftrightarrow: "↔",
        xleftrightarrow: "↔",
        Overrightarrow: "⇒",
        xRightarrow: "⇒",
        overleftharpoon: "↼",
        xleftharpoonup: "↼",
        overrightharpoon: "⇀",
        xrightharpoonup: "⇀",
        xLeftarrow: "⇐",
        xLeftrightarrow: "⇔",
        xhookleftarrow: "↩",
        xhookrightarrow: "↪",
        xmapsto: "↦",
        xrightharpoondown: "⇁",
        xleftharpoondown: "↽",
        xrightleftharpoons: "⇌",
        xleftrightharpoons: "⇋",
        xtwoheadleftarrow: "↞",
        xtwoheadrightarrow: "↠",
        xlongequal: "=",
        xtofrom: "⇄",
        xrightleftarrows: "⇄",
        xrightequilibrium: "⇌",
        xleftequilibrium: "⇋",
        "\\cdrightarrow": "→",
        "\\cdleftarrow": "←",
        "\\cdlongequal": "="
      };
      const mathMLnode = function(label) {
        const node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
        node.setAttribute("stretchy", "true");
        return node;
      };
      const katexImagesData = {
        overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
        "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
        xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
        "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
        Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
        xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
        xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
        overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
        overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
        xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
        "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
        xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
        xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
        overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
        underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
        underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
        xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
        xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
        xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
        xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
        xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
        overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
        undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
        xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
        xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
        xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
        xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
        xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
      };
      const groupLength = function(arg) {
        if (arg.type === "ordgroup") {
          return arg.body.length;
        } else {
          return 1;
        }
      };
      const svgSpan = function(group, options) {
        function buildSvgSpan_() {
          let viewBoxWidth = 400000;
          const label = group.label.slice(1);
          if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
            const grp = group;
            const numChars = groupLength(grp.base);
            let viewBoxHeight;
            let pathName;
            let height2;
            if (numChars > 5) {
              if (label === "widehat" || label === "widecheck") {
                viewBoxHeight = 420;
                viewBoxWidth = 2364;
                height2 = 0.42;
                pathName = label + "4";
              } else {
                viewBoxHeight = 312;
                viewBoxWidth = 2340;
                height2 = 0.34;
                pathName = "tilde4";
              }
            } else {
              const imgIndex = [1, 1, 2, 2, 3, 3][numChars];
              if (label === "widehat" || label === "widecheck") {
                viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                height2 = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                pathName = label + imgIndex;
              } else {
                viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                height2 = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                pathName = "tilde" + imgIndex;
              }
            }
            const path2 = new PathNode(pathName);
            const svgNode = new SvgNode([path2], {
              width: "100%",
              height: makeEm(height2),
              viewBox: "0 0 " + viewBoxWidth + " " + viewBoxHeight,
              preserveAspectRatio: "none"
            });
            return {
              span: buildCommon.makeSvgSpan([], [svgNode], options),
              minWidth: 0,
              height: height2
            };
          } else {
            const spans = [];
            const data = katexImagesData[label];
            const [paths, minWidth2, viewBoxHeight] = data;
            const height2 = viewBoxHeight / 1000;
            const numSvgChildren = paths.length;
            let widthClasses;
            let aligns;
            if (numSvgChildren === 1) {
              const align1 = data[3];
              widthClasses = ["hide-tail"];
              aligns = [align1];
            } else if (numSvgChildren === 2) {
              widthClasses = ["halfarrow-left", "halfarrow-right"];
              aligns = ["xMinYMin", "xMaxYMin"];
            } else if (numSvgChildren === 3) {
              widthClasses = ["brace-left", "brace-center", "brace-right"];
              aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
            } else {
              throw new Error(`Correct katexImagesData or update code here to support
                    ` + numSvgChildren + " children.");
            }
            for (let i = 0;i < numSvgChildren; i++) {
              const path2 = new PathNode(paths[i]);
              const svgNode = new SvgNode([path2], {
                width: "400em",
                height: makeEm(height2),
                viewBox: "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                preserveAspectRatio: aligns[i] + " slice"
              });
              const span2 = buildCommon.makeSvgSpan([widthClasses[i]], [svgNode], options);
              if (numSvgChildren === 1) {
                return {
                  span: span2,
                  minWidth: minWidth2,
                  height: height2
                };
              } else {
                span2.style.height = makeEm(height2);
                spans.push(span2);
              }
            }
            return {
              span: buildCommon.makeSpan(["stretchy"], spans, options),
              minWidth: minWidth2,
              height: height2
            };
          }
        }
        const {
          span,
          minWidth,
          height
        } = buildSvgSpan_();
        span.height = height;
        span.style.height = makeEm(height);
        if (minWidth > 0) {
          span.style.minWidth = makeEm(minWidth);
        }
        return span;
      };
      const encloseSpan = function(inner2, label, topPad, bottomPad, options) {
        let img;
        const totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
        if (/fbox|color|angl/.test(label)) {
          img = buildCommon.makeSpan(["stretchy", label], [], options);
          if (label === "fbox") {
            const color = options.color && options.getColor();
            if (color) {
              img.style.borderColor = color;
            }
          }
        } else {
          const lines = [];
          if (/^[bx]cancel$/.test(label)) {
            lines.push(new LineNode({
              x1: "0",
              y1: "0",
              x2: "100%",
              y2: "100%",
              "stroke-width": "0.046em"
            }));
          }
          if (/^x?cancel$/.test(label)) {
            lines.push(new LineNode({
              x1: "0",
              y1: "100%",
              x2: "100%",
              y2: "0",
              "stroke-width": "0.046em"
            }));
          }
          const svgNode = new SvgNode(lines, {
            width: "100%",
            height: makeEm(totalHeight)
          });
          img = buildCommon.makeSvgSpan([], [svgNode], options);
        }
        img.height = totalHeight;
        img.style.height = makeEm(totalHeight);
        return img;
      };
      var stretchy = {
        encloseSpan,
        mathMLnode,
        svgSpan
      };
      function assertNodeType(node, type) {
        if (!node || node.type !== type) {
          throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
        }
        return node;
      }
      function assertSymbolNodeType(node) {
        const typedNode = checkSymbolNodeType(node);
        if (!typedNode) {
          throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
        }
        return typedNode;
      }
      function checkSymbolNodeType(node) {
        if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
          return node;
        }
        return null;
      }
      const htmlBuilder = (grp, options) => {
        let base;
        let group;
        let supSubGroup;
        if (grp && grp.type === "supsub") {
          group = assertNodeType(grp.base, "accent");
          base = group.base;
          grp.base = base;
          supSubGroup = assertSpan(buildGroup(grp, options));
          grp.base = group;
        } else {
          group = assertNodeType(grp, "accent");
          base = group.base;
        }
        const body = buildGroup(base, options.havingCrampedStyle());
        const mustShift = group.isShifty && utils.isCharacterBox(base);
        let skew = 0;
        if (mustShift) {
          const baseChar = utils.getBaseElem(base);
          const baseGroup = buildGroup(baseChar, options.havingCrampedStyle());
          skew = assertSymbolDomNode(baseGroup).skew;
        }
        const accentBelow = group.label === "\\c";
        let clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
        let accentBody;
        if (!group.isStretchy) {
          let accent2;
          let width;
          if (group.label === "\\vec") {
            accent2 = buildCommon.staticSvg("vec", options);
            width = buildCommon.svgData.vec[1];
          } else {
            accent2 = buildCommon.makeOrd({
              mode: group.mode,
              text: group.label
            }, options, "textord");
            accent2 = assertSymbolDomNode(accent2);
            accent2.italic = 0;
            width = accent2.width;
            if (accentBelow) {
              clearance += accent2.depth;
            }
          }
          accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
          const accentFull = group.label === "\\textcircled";
          if (accentFull) {
            accentBody.classes.push("accent-full");
            clearance = body.height;
          }
          let left = skew;
          if (!accentFull) {
            left -= width / 2;
          }
          accentBody.style.left = makeEm(left);
          if (group.label === "\\textcircled") {
            accentBody.style.top = ".2em";
          }
          accentBody = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "kern",
              size: -clearance
            }, {
              type: "elem",
              elem: accentBody
            }]
          }, options);
        } else {
          accentBody = stretchy.svgSpan(group, options);
          accentBody = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"],
              wrapperStyle: skew > 0 ? {
                width: "calc(100% - " + makeEm(2 * skew) + ")",
                marginLeft: makeEm(2 * skew)
              } : undefined
            }]
          }, options);
        }
        const accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
        if (supSubGroup) {
          supSubGroup.children[0] = accentWrap;
          supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
          supSubGroup.classes[0] = "mord";
          return supSubGroup;
        } else {
          return accentWrap;
        }
      };
      const mathmlBuilder = (group, options) => {
        const accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
        const node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
        node.setAttribute("accent", "true");
        return node;
      };
      const NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
      defineFunction({
        type: "accent",
        names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
        props: {
          numArgs: 1
        },
        handler: (context, args) => {
          const base = normalizeArgument(args[0]);
          const isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
          const isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
          return {
            type: "accent",
            mode: context.parser.mode,
            label: context.funcName,
            isStretchy,
            isShifty,
            base
          };
        },
        htmlBuilder,
        mathmlBuilder
      });
      defineFunction({
        type: "accent",
        names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", "\\\"", "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
        props: {
          numArgs: 1,
          allowedInText: true,
          allowedInMath: true,
          argTypes: ["primitive"]
        },
        handler: (context, args) => {
          const base = args[0];
          let mode = context.parser.mode;
          if (mode === "math") {
            context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
            mode = "text";
          }
          return {
            type: "accent",
            mode,
            label: context.funcName,
            isStretchy: false,
            isShifty: true,
            base
          };
        },
        htmlBuilder,
        mathmlBuilder
      });
      defineFunction({
        type: "accentUnder",
        names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
        props: {
          numArgs: 1
        },
        handler: (_ref, args) => {
          let {
            parser,
            funcName
          } = _ref;
          const base = args[0];
          return {
            type: "accentUnder",
            mode: parser.mode,
            label: funcName,
            base
          };
        },
        htmlBuilder: (group, options) => {
          const innerGroup = buildGroup(group.base, options);
          const accentBody = stretchy.svgSpan(group, options);
          const kern = group.label === "\\utilde" ? 0.12 : 0;
          const vlist = buildCommon.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: kern
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options);
          return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
        },
        mathmlBuilder: (group, options) => {
          const accentNode = stretchy.mathMLnode(group.label);
          const node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
          node.setAttribute("accentunder", "true");
          return node;
        }
      });
      const paddedNode = (group) => {
        const node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
        node.setAttribute("width", "+0.6em");
        node.setAttribute("lspace", "0.3em");
        return node;
      };
      defineFunction({
        type: "xArrow",
        names: [
          "\\xleftarrow",
          "\\xrightarrow",
          "\\xLeftarrow",
          "\\xRightarrow",
          "\\xleftrightarrow",
          "\\xLeftrightarrow",
          "\\xhookleftarrow",
          "\\xhookrightarrow",
          "\\xmapsto",
          "\\xrightharpoondown",
          "\\xrightharpoonup",
          "\\xleftharpoondown",
          "\\xleftharpoonup",
          "\\xrightleftharpoons",
          "\\xleftrightharpoons",
          "\\xlongequal",
          "\\xtwoheadrightarrow",
          "\\xtwoheadleftarrow",
          "\\xtofrom",
          "\\xrightleftarrows",
          "\\xrightequilibrium",
          "\\xleftequilibrium",
          "\\\\cdrightarrow",
          "\\\\cdleftarrow",
          "\\\\cdlongequal"
        ],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler(_ref, args, optArgs) {
          let {
            parser,
            funcName
          } = _ref;
          return {
            type: "xArrow",
            mode: parser.mode,
            label: funcName,
            body: args[0],
            below: optArgs[0]
          };
        },
        htmlBuilder(group, options) {
          const style = options.style;
          let newOptions = options.havingStyle(style.sup());
          const upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options);
          const arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
          upperGroup.classes.push(arrowPrefix + "-arrow-pad");
          let lowerGroup;
          if (group.below) {
            newOptions = options.havingStyle(style.sub());
            lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options);
            lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
          }
          const arrowBody = stretchy.svgSpan(group, options);
          const arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
          let upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
          if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
            upperShift -= upperGroup.depth;
          }
          let vlist;
          if (lowerGroup) {
            const lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }, {
                type: "elem",
                elem: lowerGroup,
                shift: lowerShift
              }]
            }, options);
          } else {
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }]
            }, options);
          }
          vlist.children[0].children[0].children[1].classes.push("svg-align");
          return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
        },
        mathmlBuilder(group, options) {
          const arrowNode = stretchy.mathMLnode(group.label);
          arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
          let node;
          if (group.body) {
            const upperNode = paddedNode(buildMathML_buildGroup(group.body, options));
            if (group.below) {
              const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
              node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
            } else {
              node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
            }
          } else if (group.below) {
            const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
            node = new mathMLTree.MathNode("munder", [arrowNode, lowerNode]);
          } else {
            node = paddedNode();
            node = new mathMLTree.MathNode("mover", [arrowNode, node]);
          }
          return node;
        }
      });
      const mclass_makeSpan = buildCommon.makeSpan;
      function mclass_htmlBuilder(group, options) {
        const elements = buildExpression(group.body, options, true);
        return mclass_makeSpan([group.mclass], elements, options);
      }
      function mclass_mathmlBuilder(group, options) {
        let node;
        const inner2 = buildMathML_buildExpression(group.body, options);
        if (group.mclass === "minner") {
          node = new mathMLTree.MathNode("mpadded", inner2);
        } else if (group.mclass === "mord") {
          if (group.isCharacterBox) {
            node = inner2[0];
            node.type = "mi";
          } else {
            node = new mathMLTree.MathNode("mi", inner2);
          }
        } else {
          if (group.isCharacterBox) {
            node = inner2[0];
            node.type = "mo";
          } else {
            node = new mathMLTree.MathNode("mo", inner2);
          }
          if (group.mclass === "mbin") {
            node.attributes.lspace = "0.22em";
            node.attributes.rspace = "0.22em";
          } else if (group.mclass === "mpunct") {
            node.attributes.lspace = "0em";
            node.attributes.rspace = "0.17em";
          } else if (group.mclass === "mopen" || group.mclass === "mclose") {
            node.attributes.lspace = "0em";
            node.attributes.rspace = "0em";
          } else if (group.mclass === "minner") {
            node.attributes.lspace = "0.0556em";
            node.attributes.width = "+0.1111em";
          }
        }
        return node;
      }
      defineFunction({
        type: "mclass",
        names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler(_ref, args) {
          let {
            parser,
            funcName
          } = _ref;
          const body = args[0];
          return {
            type: "mclass",
            mode: parser.mode,
            mclass: "m" + funcName.slice(5),
            body: ordargument(body),
            isCharacterBox: utils.isCharacterBox(body)
          };
        },
        htmlBuilder: mclass_htmlBuilder,
        mathmlBuilder: mclass_mathmlBuilder
      });
      const binrelClass = (arg) => {
        const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
        if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
          return "m" + atom.family;
        } else {
          return "mord";
        }
      };
      defineFunction({
        type: "mclass",
        names: ["\\@binrel"],
        props: {
          numArgs: 2
        },
        handler(_ref2, args) {
          let {
            parser
          } = _ref2;
          return {
            type: "mclass",
            mode: parser.mode,
            mclass: binrelClass(args[0]),
            body: ordargument(args[1]),
            isCharacterBox: utils.isCharacterBox(args[1])
          };
        }
      });
      defineFunction({
        type: "mclass",
        names: ["\\stackrel", "\\overset", "\\underset"],
        props: {
          numArgs: 2
        },
        handler(_ref3, args) {
          let {
            parser,
            funcName
          } = _ref3;
          const baseArg = args[1];
          const shiftedArg = args[0];
          let mclass;
          if (funcName !== "\\stackrel") {
            mclass = binrelClass(baseArg);
          } else {
            mclass = "mrel";
          }
          const baseOp = {
            type: "op",
            mode: baseArg.mode,
            limits: true,
            alwaysHandleSupSub: true,
            parentIsSupSub: false,
            symbol: false,
            suppressBaseShift: funcName !== "\\stackrel",
            body: ordargument(baseArg)
          };
          const supsub = {
            type: "supsub",
            mode: shiftedArg.mode,
            base: baseOp,
            sup: funcName === "\\underset" ? null : shiftedArg,
            sub: funcName === "\\underset" ? shiftedArg : null
          };
          return {
            type: "mclass",
            mode: parser.mode,
            mclass,
            body: [supsub],
            isCharacterBox: utils.isCharacterBox(supsub)
          };
        },
        htmlBuilder: mclass_htmlBuilder,
        mathmlBuilder: mclass_mathmlBuilder
      });
      defineFunction({
        type: "pmb",
        names: ["\\pmb"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler(_ref, args) {
          let {
            parser
          } = _ref;
          return {
            type: "pmb",
            mode: parser.mode,
            mclass: binrelClass(args[0]),
            body: ordargument(args[0])
          };
        },
        htmlBuilder(group, options) {
          const elements = buildExpression(group.body, options, true);
          const node = buildCommon.makeSpan([group.mclass], elements, options);
          node.style.textShadow = "0.02em 0.01em 0.04px";
          return node;
        },
        mathmlBuilder(group, style) {
          const inner2 = buildMathML_buildExpression(group.body, style);
          const node = new mathMLTree.MathNode("mstyle", inner2);
          node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
          return node;
        }
      });
      const cdArrowFunctionName = {
        ">": "\\\\cdrightarrow",
        "<": "\\\\cdleftarrow",
        "=": "\\\\cdlongequal",
        A: "\\uparrow",
        V: "\\downarrow",
        "|": "\\Vert",
        ".": "no arrow"
      };
      const newCell = () => {
        return {
          type: "styling",
          body: [],
          mode: "math",
          style: "display"
        };
      };
      const isStartOfArrow = (node) => {
        return node.type === "textord" && node.text === "@";
      };
      const isLabelEnd = (node, endChar) => {
        return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
      };
      function cdArrow(arrowChar, labels, parser) {
        const funcName = cdArrowFunctionName[arrowChar];
        switch (funcName) {
          case "\\\\cdrightarrow":
          case "\\\\cdleftarrow":
            return parser.callFunction(funcName, [labels[0]], [labels[1]]);
          case "\\uparrow":
          case "\\downarrow": {
            const leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
            const bareArrow = {
              type: "atom",
              text: funcName,
              mode: "math",
              family: "rel"
            };
            const sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
            const rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
            const arrowGroup = {
              type: "ordgroup",
              mode: "math",
              body: [leftLabel, sizedArrow, rightLabel]
            };
            return parser.callFunction("\\\\cdparent", [arrowGroup], []);
          }
          case "\\\\cdlongequal":
            return parser.callFunction("\\\\cdlongequal", [], []);
          case "\\Vert": {
            const arrow = {
              type: "textord",
              text: "\\Vert",
              mode: "math"
            };
            return parser.callFunction("\\Big", [arrow], []);
          }
          default:
            return {
              type: "textord",
              text: " ",
              mode: "math"
            };
        }
      }
      function parseCD(parser) {
        const parsedRows = [];
        parser.gullet.beginGroup();
        parser.gullet.macros.set("\\cr", "\\\\\\relax");
        parser.gullet.beginGroup();
        while (true) {
          parsedRows.push(parser.parseExpression(false, "\\\\"));
          parser.gullet.endGroup();
          parser.gullet.beginGroup();
          const next = parser.fetch().text;
          if (next === "&" || next === "\\\\") {
            parser.consume();
          } else if (next === "\\end") {
            if (parsedRows[parsedRows.length - 1].length === 0) {
              parsedRows.pop();
            }
            break;
          } else {
            throw new src_ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
          }
        }
        let row = [];
        const body = [row];
        for (let i = 0;i < parsedRows.length; i++) {
          const rowNodes = parsedRows[i];
          let cell = newCell();
          for (let j4 = 0;j4 < rowNodes.length; j4++) {
            if (!isStartOfArrow(rowNodes[j4])) {
              cell.body.push(rowNodes[j4]);
            } else {
              row.push(cell);
              j4 += 1;
              const arrowChar = assertSymbolNodeType(rowNodes[j4]).text;
              const labels = new Array(2);
              labels[0] = {
                type: "ordgroup",
                mode: "math",
                body: []
              };
              labels[1] = {
                type: "ordgroup",
                mode: "math",
                body: []
              };
              if ("=|.".indexOf(arrowChar) > -1) {
              } else if ("<>AV".indexOf(arrowChar) > -1) {
                for (let labelNum = 0;labelNum < 2; labelNum++) {
                  let inLabel = true;
                  for (let k4 = j4 + 1;k4 < rowNodes.length; k4++) {
                    if (isLabelEnd(rowNodes[k4], arrowChar)) {
                      inLabel = false;
                      j4 = k4;
                      break;
                    }
                    if (isStartOfArrow(rowNodes[k4])) {
                      throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k4]);
                    }
                    labels[labelNum].body.push(rowNodes[k4]);
                  }
                  if (inLabel) {
                    throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j4]);
                  }
                }
              } else {
                throw new src_ParseError('Expected one of "<>AV=|." after @', rowNodes[j4]);
              }
              const arrow = cdArrow(arrowChar, labels, parser);
              const wrappedArrow = {
                type: "styling",
                body: [arrow],
                mode: "math",
                style: "display"
              };
              row.push(wrappedArrow);
              cell = newCell();
            }
          }
          if (i % 2 === 0) {
            row.push(cell);
          } else {
            row.shift();
          }
          row = [];
          body.push(row);
        }
        parser.gullet.endGroup();
        parser.gullet.endGroup();
        const cols = new Array(body[0].length).fill({
          type: "align",
          align: "c",
          pregap: 0.25,
          postgap: 0.25
        });
        return {
          type: "array",
          mode: "math",
          body,
          arraystretch: 1,
          addJot: true,
          rowGaps: [null],
          cols,
          colSeparationType: "CD",
          hLinesBeforeRow: new Array(body.length + 1).fill([])
        };
      }
      defineFunction({
        type: "cdlabel",
        names: ["\\\\cdleft", "\\\\cdright"],
        props: {
          numArgs: 1
        },
        handler(_ref, args) {
          let {
            parser,
            funcName
          } = _ref;
          return {
            type: "cdlabel",
            mode: parser.mode,
            side: funcName.slice(4),
            label: args[0]
          };
        },
        htmlBuilder(group, options) {
          const newOptions = options.havingStyle(options.style.sup());
          const label = buildCommon.wrapFragment(buildGroup(group.label, newOptions, options), options);
          label.classes.push("cd-label-" + group.side);
          label.style.bottom = makeEm(0.8 - label.depth);
          label.height = 0;
          label.depth = 0;
          return label;
        },
        mathmlBuilder(group, options) {
          let label = new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.label, options)]);
          label = new mathMLTree.MathNode("mpadded", [label]);
          label.setAttribute("width", "0");
          if (group.side === "left") {
            label.setAttribute("lspace", "-1width");
          }
          label.setAttribute("voffset", "0.7em");
          label = new mathMLTree.MathNode("mstyle", [label]);
          label.setAttribute("displaystyle", "false");
          label.setAttribute("scriptlevel", "1");
          return label;
        }
      });
      defineFunction({
        type: "cdlabelparent",
        names: ["\\\\cdparent"],
        props: {
          numArgs: 1
        },
        handler(_ref2, args) {
          let {
            parser
          } = _ref2;
          return {
            type: "cdlabelparent",
            mode: parser.mode,
            fragment: args[0]
          };
        },
        htmlBuilder(group, options) {
          const parent = buildCommon.wrapFragment(buildGroup(group.fragment, options), options);
          parent.classes.push("cd-vert-arrow");
          return parent;
        },
        mathmlBuilder(group, options) {
          return new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.fragment, options)]);
        }
      });
      defineFunction({
        type: "textord",
        names: ["\\@char"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler(_ref, args) {
          let {
            parser
          } = _ref;
          const arg = assertNodeType(args[0], "ordgroup");
          const group = arg.body;
          let number = "";
          for (let i = 0;i < group.length; i++) {
            const node = assertNodeType(group[i], "textord");
            number += node.text;
          }
          let code = parseInt(number);
          let text;
          if (isNaN(code)) {
            throw new src_ParseError("\\@char has non-numeric argument " + number);
          } else if (code < 0 || code >= 1114111) {
            throw new src_ParseError("\\@char with invalid code point " + number);
          } else if (code <= 65535) {
            text = String.fromCharCode(code);
          } else {
            code -= 65536;
            text = String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
          }
          return {
            type: "textord",
            mode: parser.mode,
            text
          };
        }
      });
      const color_htmlBuilder = (group, options) => {
        const elements = buildExpression(group.body, options.withColor(group.color), false);
        return buildCommon.makeFragment(elements);
      };
      const color_mathmlBuilder = (group, options) => {
        const inner2 = buildMathML_buildExpression(group.body, options.withColor(group.color));
        const node = new mathMLTree.MathNode("mstyle", inner2);
        node.setAttribute("mathcolor", group.color);
        return node;
      };
      defineFunction({
        type: "color",
        names: ["\\textcolor"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "original"]
        },
        handler(_ref, args) {
          let {
            parser
          } = _ref;
          const color = assertNodeType(args[0], "color-token").color;
          const body = args[1];
          return {
            type: "color",
            mode: parser.mode,
            color,
            body: ordargument(body)
          };
        },
        htmlBuilder: color_htmlBuilder,
        mathmlBuilder: color_mathmlBuilder
      });
      defineFunction({
        type: "color",
        names: ["\\color"],
        props: {
          numArgs: 1,
          allowedInText: true,
          argTypes: ["color"]
        },
        handler(_ref2, args) {
          let {
            parser,
            breakOnTokenText
          } = _ref2;
          const color = assertNodeType(args[0], "color-token").color;
          parser.gullet.macros.set("\\current@color", color);
          const body = parser.parseExpression(true, breakOnTokenText);
          return {
            type: "color",
            mode: parser.mode,
            color,
            body
          };
        },
        htmlBuilder: color_htmlBuilder,
        mathmlBuilder: color_mathmlBuilder
      });
      defineFunction({
        type: "cr",
        names: ["\\\\"],
        props: {
          numArgs: 0,
          numOptionalArgs: 0,
          allowedInText: true
        },
        handler(_ref, args, optArgs) {
          let {
            parser
          } = _ref;
          const size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
          const newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline " + "does nothing in display mode");
          return {
            type: "cr",
            mode: parser.mode,
            newLine,
            size: size && assertNodeType(size, "size").value
          };
        },
        htmlBuilder(group, options) {
          const span = buildCommon.makeSpan(["mspace"], [], options);
          if (group.newLine) {
            span.classes.push("newline");
            if (group.size) {
              span.style.marginTop = makeEm(calculateSize(group.size, options));
            }
          }
          return span;
        },
        mathmlBuilder(group, options) {
          const node = new mathMLTree.MathNode("mspace");
          if (group.newLine) {
            node.setAttribute("linebreak", "newline");
            if (group.size) {
              node.setAttribute("height", makeEm(calculateSize(group.size, options)));
            }
          }
          return node;
        }
      });
      const globalMap = {
        "\\global": "\\global",
        "\\long": "\\\\globallong",
        "\\\\globallong": "\\\\globallong",
        "\\def": "\\gdef",
        "\\gdef": "\\gdef",
        "\\edef": "\\xdef",
        "\\xdef": "\\xdef",
        "\\let": "\\\\globallet",
        "\\futurelet": "\\\\globalfuture"
      };
      const checkControlSequence = (tok) => {
        const name = tok.text;
        if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
          throw new src_ParseError("Expected a control sequence", tok);
        }
        return name;
      };
      const getRHS = (parser) => {
        let tok = parser.gullet.popToken();
        if (tok.text === "=") {
          tok = parser.gullet.popToken();
          if (tok.text === " ") {
            tok = parser.gullet.popToken();
          }
        }
        return tok;
      };
      const letCommand = (parser, name, tok, global2) => {
        let macro = parser.gullet.macros.get(tok.text);
        if (macro == null) {
          tok.noexpand = true;
          macro = {
            tokens: [tok],
            numArgs: 0,
            unexpandable: !parser.gullet.isExpandable(tok.text)
          };
        }
        parser.gullet.macros.set(name, macro, global2);
      };
      defineFunction({
        type: "internal",
        names: [
          "\\global",
          "\\long",
          "\\\\globallong"
        ],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler(_ref) {
          let {
            parser,
            funcName
          } = _ref;
          parser.consumeSpaces();
          const token = parser.fetch();
          if (globalMap[token.text]) {
            if (funcName === "\\global" || funcName === "\\\\globallong") {
              token.text = globalMap[token.text];
            }
            return assertNodeType(parser.parseFunction(), "internal");
          }
          throw new src_ParseError("Invalid token after macro prefix", token);
        }
      });
      defineFunction({
        type: "internal",
        names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref2) {
          let {
            parser,
            funcName
          } = _ref2;
          let tok = parser.gullet.popToken();
          const name = tok.text;
          if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
            throw new src_ParseError("Expected a control sequence", tok);
          }
          let numArgs = 0;
          let insert;
          const delimiters2 = [[]];
          while (parser.gullet.future().text !== "{") {
            tok = parser.gullet.popToken();
            if (tok.text === "#") {
              if (parser.gullet.future().text === "{") {
                insert = parser.gullet.future();
                delimiters2[numArgs].push("{");
                break;
              }
              tok = parser.gullet.popToken();
              if (!/^[1-9]$/.test(tok.text)) {
                throw new src_ParseError('Invalid argument number "' + tok.text + '"');
              }
              if (parseInt(tok.text) !== numArgs + 1) {
                throw new src_ParseError('Argument number "' + tok.text + '" out of order');
              }
              numArgs++;
              delimiters2.push([]);
            } else if (tok.text === "EOF") {
              throw new src_ParseError("Expected a macro definition");
            } else {
              delimiters2[numArgs].push(tok.text);
            }
          }
          let {
            tokens
          } = parser.gullet.consumeArg();
          if (insert) {
            tokens.unshift(insert);
          }
          if (funcName === "\\edef" || funcName === "\\xdef") {
            tokens = parser.gullet.expandTokens(tokens);
            tokens.reverse();
          }
          parser.gullet.macros.set(name, {
            tokens,
            numArgs,
            delimiters: delimiters2
          }, funcName === globalMap[funcName]);
          return {
            type: "internal",
            mode: parser.mode
          };
        }
      });
      defineFunction({
        type: "internal",
        names: [
          "\\let",
          "\\\\globallet"
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref3) {
          let {
            parser,
            funcName
          } = _ref3;
          const name = checkControlSequence(parser.gullet.popToken());
          parser.gullet.consumeSpaces();
          const tok = getRHS(parser);
          letCommand(parser, name, tok, funcName === "\\\\globallet");
          return {
            type: "internal",
            mode: parser.mode
          };
        }
      });
      defineFunction({
        type: "internal",
        names: [
          "\\futurelet",
          "\\\\globalfuture"
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref4) {
          let {
            parser,
            funcName
          } = _ref4;
          const name = checkControlSequence(parser.gullet.popToken());
          const middle = parser.gullet.popToken();
          const tok = parser.gullet.popToken();
          letCommand(parser, name, tok, funcName === "\\\\globalfuture");
          parser.gullet.pushToken(tok);
          parser.gullet.pushToken(middle);
          return {
            type: "internal",
            mode: parser.mode
          };
        }
      });
      const getMetrics = function(symbol, font, mode) {
        const replace = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
        const metrics = getCharacterMetrics(replace || symbol, font, mode);
        if (!metrics) {
          throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
        }
        return metrics;
      };
      const styleWrap = function(delim, toStyle, options, classes) {
        const newOptions = options.havingBaseStyle(toStyle);
        const span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
        const delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
        span.height *= delimSizeMultiplier;
        span.depth *= delimSizeMultiplier;
        span.maxFontSize = newOptions.sizeMultiplier;
        return span;
      };
      const centerSpan = function(span, options, style) {
        const newOptions = options.havingBaseStyle(style);
        const shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
        span.classes.push("delimcenter");
        span.style.top = makeEm(shift);
        span.height -= shift;
        span.depth += shift;
      };
      const makeSmallDelim = function(delim, style, center, options, mode, classes) {
        const text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
        const span = styleWrap(text, style, options, classes);
        if (center) {
          centerSpan(span, options, style);
        }
        return span;
      };
      const mathrmSize = function(value, size, mode, options) {
        return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
      };
      const makeLargeDelim = function(delim, size, center, options, mode, classes) {
        const inner2 = mathrmSize(delim, size, mode, options);
        const span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options), src_Style.TEXT, options, classes);
        if (center) {
          centerSpan(span, options, src_Style.TEXT);
        }
        return span;
      };
      const makeGlyphSpan = function(symbol, font, mode) {
        let sizeClass;
        if (font === "Size1-Regular") {
          sizeClass = "delim-size1";
        } else {
          sizeClass = "delim-size4";
        }
        const corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
        return {
          type: "elem",
          elem: corner
        };
      };
      const makeInner = function(ch, height, options) {
        const width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
        const path2 = new PathNode("inner", innerPath(ch, Math.round(1000 * height)));
        const svgNode = new SvgNode([path2], {
          width: makeEm(width),
          height: makeEm(height),
          style: "width:" + makeEm(width),
          viewBox: "0 0 " + 1000 * width + " " + Math.round(1000 * height),
          preserveAspectRatio: "xMinYMin"
        });
        const span = buildCommon.makeSvgSpan([], [svgNode], options);
        span.height = height;
        span.style.height = makeEm(height);
        span.style.width = makeEm(width);
        return {
          type: "elem",
          elem: span
        };
      };
      const lapInEms = 0.008;
      const lap = {
        type: "kern",
        size: -1 * lapInEms
      };
      const verts = ["|", "\\lvert", "\\rvert", "\\vert"];
      const doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
      const makeStackedDelim = function(delim, heightTotal, center, options, mode, classes) {
        let top;
        let middle;
        let repeat;
        let bottom;
        let svgLabel = "";
        let viewBoxWidth = 0;
        top = repeat = bottom = delim;
        middle = null;
        let font = "Size1-Regular";
        if (delim === "\\uparrow") {
          repeat = bottom = "⏐";
        } else if (delim === "\\Uparrow") {
          repeat = bottom = "‖";
        } else if (delim === "\\downarrow") {
          top = repeat = "⏐";
        } else if (delim === "\\Downarrow") {
          top = repeat = "‖";
        } else if (delim === "\\updownarrow") {
          top = "\\uparrow";
          repeat = "⏐";
          bottom = "\\downarrow";
        } else if (delim === "\\Updownarrow") {
          top = "\\Uparrow";
          repeat = "‖";
          bottom = "\\Downarrow";
        } else if (utils.contains(verts, delim)) {
          repeat = "∣";
          svgLabel = "vert";
          viewBoxWidth = 333;
        } else if (utils.contains(doubleVerts, delim)) {
          repeat = "∥";
          svgLabel = "doublevert";
          viewBoxWidth = 556;
        } else if (delim === "[" || delim === "\\lbrack") {
          top = "⎡";
          repeat = "⎢";
          bottom = "⎣";
          font = "Size4-Regular";
          svgLabel = "lbrack";
          viewBoxWidth = 667;
        } else if (delim === "]" || delim === "\\rbrack") {
          top = "⎤";
          repeat = "⎥";
          bottom = "⎦";
          font = "Size4-Regular";
          svgLabel = "rbrack";
          viewBoxWidth = 667;
        } else if (delim === "\\lfloor" || delim === "⌊") {
          repeat = top = "⎢";
          bottom = "⎣";
          font = "Size4-Regular";
          svgLabel = "lfloor";
          viewBoxWidth = 667;
        } else if (delim === "\\lceil" || delim === "⌈") {
          top = "⎡";
          repeat = bottom = "⎢";
          font = "Size4-Regular";
          svgLabel = "lceil";
          viewBoxWidth = 667;
        } else if (delim === "\\rfloor" || delim === "⌋") {
          repeat = top = "⎥";
          bottom = "⎦";
          font = "Size4-Regular";
          svgLabel = "rfloor";
          viewBoxWidth = 667;
        } else if (delim === "\\rceil" || delim === "⌉") {
          top = "⎤";
          repeat = bottom = "⎥";
          font = "Size4-Regular";
          svgLabel = "rceil";
          viewBoxWidth = 667;
        } else if (delim === "(" || delim === "\\lparen") {
          top = "⎛";
          repeat = "⎜";
          bottom = "⎝";
          font = "Size4-Regular";
          svgLabel = "lparen";
          viewBoxWidth = 875;
        } else if (delim === ")" || delim === "\\rparen") {
          top = "⎞";
          repeat = "⎟";
          bottom = "⎠";
          font = "Size4-Regular";
          svgLabel = "rparen";
          viewBoxWidth = 875;
        } else if (delim === "\\{" || delim === "\\lbrace") {
          top = "⎧";
          middle = "⎨";
          bottom = "⎩";
          repeat = "⎪";
          font = "Size4-Regular";
        } else if (delim === "\\}" || delim === "\\rbrace") {
          top = "⎫";
          middle = "⎬";
          bottom = "⎭";
          repeat = "⎪";
          font = "Size4-Regular";
        } else if (delim === "\\lgroup" || delim === "⟮") {
          top = "⎧";
          bottom = "⎩";
          repeat = "⎪";
          font = "Size4-Regular";
        } else if (delim === "\\rgroup" || delim === "⟯") {
          top = "⎫";
          bottom = "⎭";
          repeat = "⎪";
          font = "Size4-Regular";
        } else if (delim === "\\lmoustache" || delim === "⎰") {
          top = "⎧";
          bottom = "⎭";
          repeat = "⎪";
          font = "Size4-Regular";
        } else if (delim === "\\rmoustache" || delim === "⎱") {
          top = "⎫";
          bottom = "⎩";
          repeat = "⎪";
          font = "Size4-Regular";
        }
        const topMetrics = getMetrics(top, font, mode);
        const topHeightTotal = topMetrics.height + topMetrics.depth;
        const repeatMetrics = getMetrics(repeat, font, mode);
        const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
        const bottomMetrics = getMetrics(bottom, font, mode);
        const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
        let middleHeightTotal = 0;
        let middleFactor = 1;
        if (middle !== null) {
          const middleMetrics = getMetrics(middle, font, mode);
          middleHeightTotal = middleMetrics.height + middleMetrics.depth;
          middleFactor = 2;
        }
        const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
        const repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
        const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
        let axisHeight = options.fontMetrics().axisHeight;
        if (center) {
          axisHeight *= options.sizeMultiplier;
        }
        const depth = realHeightTotal / 2 - axisHeight;
        const stack = [];
        if (svgLabel.length > 0) {
          const midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
          const viewBoxHeight = Math.round(realHeightTotal * 1000);
          const pathStr = tallDelim(svgLabel, Math.round(midHeight * 1000));
          const path2 = new PathNode(svgLabel, pathStr);
          const width = (viewBoxWidth / 1000).toFixed(3) + "em";
          const height = (viewBoxHeight / 1000).toFixed(3) + "em";
          const svg = new SvgNode([path2], {
            width,
            height,
            viewBox: "0 0 " + viewBoxWidth + " " + viewBoxHeight
          });
          const wrapper = buildCommon.makeSvgSpan([], [svg], options);
          wrapper.height = viewBoxHeight / 1000;
          wrapper.style.width = width;
          wrapper.style.height = height;
          stack.push({
            type: "elem",
            elem: wrapper
          });
        } else {
          stack.push(makeGlyphSpan(bottom, font, mode));
          stack.push(lap);
          if (middle === null) {
            const innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
            stack.push(makeInner(repeat, innerHeight, options));
          } else {
            const innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
            stack.push(makeInner(repeat, innerHeight, options));
            stack.push(lap);
            stack.push(makeGlyphSpan(middle, font, mode));
            stack.push(lap);
            stack.push(makeInner(repeat, innerHeight, options));
          }
          stack.push(lap);
          stack.push(makeGlyphSpan(top, font, mode));
        }
        const newOptions = options.havingBaseStyle(src_Style.TEXT);
        const inner2 = buildCommon.makeVList({
          positionType: "bottom",
          positionData: depth,
          children: stack
        }, newOptions);
        return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), src_Style.TEXT, options, classes);
      };
      const vbPad = 80;
      const emPad = 0.08;
      const sqrtSvg = function(sqrtName, height, viewBoxHeight, extraVinculum, options) {
        const path2 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
        const pathNode = new PathNode(sqrtName, path2);
        const svg = new SvgNode([pathNode], {
          width: "400em",
          height: makeEm(height),
          viewBox: "0 0 400000 " + viewBoxHeight,
          preserveAspectRatio: "xMinYMin slice"
        });
        return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
      };
      const makeSqrtImage = function(height, options) {
        const newOptions = options.havingBaseSizing();
        const delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
        let sizeMultiplier = newOptions.sizeMultiplier;
        const extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
        let span;
        let spanHeight = 0;
        let texHeight = 0;
        let viewBoxHeight = 0;
        let advanceWidth;
        if (delim.type === "small") {
          viewBoxHeight = 1000 + 1000 * extraVinculum + vbPad;
          if (height < 1) {
            sizeMultiplier = 1;
          } else if (height < 1.4) {
            sizeMultiplier = 0.7;
          }
          spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
          texHeight = (1 + extraVinculum) / sizeMultiplier;
          span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
          span.style.minWidth = "0.853em";
          advanceWidth = 0.833 / sizeMultiplier;
        } else if (delim.type === "large") {
          viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];
          texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
          spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
          span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
          span.style.minWidth = "1.02em";
          advanceWidth = 1 / sizeMultiplier;
        } else {
          spanHeight = height + extraVinculum + emPad;
          texHeight = height + extraVinculum;
          viewBoxHeight = Math.floor(1000 * height + extraVinculum) + vbPad;
          span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
          span.style.minWidth = "0.742em";
          advanceWidth = 1.056;
        }
        span.height = texHeight;
        span.style.height = makeEm(spanHeight);
        return {
          span,
          advanceWidth,
          ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
        };
      };
      const stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"];
      const stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"];
      const stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
      const sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
      const makeSizedDelim = function(delim, size, options, mode, classes) {
        if (delim === "<" || delim === "\\lt" || delim === "⟨") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "⟩") {
          delim = "\\rangle";
        }
        if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
          return makeLargeDelim(delim, size, false, options, mode, classes);
        } else if (utils.contains(stackAlwaysDelimiters, delim)) {
          return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
        } else {
          throw new src_ParseError("Illegal delimiter: '" + delim + "'");
        }
      };
      const stackNeverDelimiterSequence = [{
        type: "small",
        style: src_Style.SCRIPTSCRIPT
      }, {
        type: "small",
        style: src_Style.SCRIPT
      }, {
        type: "small",
        style: src_Style.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }];
      const stackAlwaysDelimiterSequence = [{
        type: "small",
        style: src_Style.SCRIPTSCRIPT
      }, {
        type: "small",
        style: src_Style.SCRIPT
      }, {
        type: "small",
        style: src_Style.TEXT
      }, {
        type: "stack"
      }];
      const stackLargeDelimiterSequence = [{
        type: "small",
        style: src_Style.SCRIPTSCRIPT
      }, {
        type: "small",
        style: src_Style.SCRIPT
      }, {
        type: "small",
        style: src_Style.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }, {
        type: "stack"
      }];
      const delimTypeToFont = function(type) {
        if (type.type === "small") {
          return "Main-Regular";
        } else if (type.type === "large") {
          return "Size" + type.size + "-Regular";
        } else if (type.type === "stack") {
          return "Size4-Regular";
        } else {
          throw new Error("Add support for delim type '" + type.type + "' here.");
        }
      };
      const traverseSequence = function(delim, height, sequence, options) {
        const start = Math.min(2, 3 - options.style.size);
        for (let i = start;i < sequence.length; i++) {
          if (sequence[i].type === "stack") {
            break;
          }
          const metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
          let heightDepth = metrics.height + metrics.depth;
          if (sequence[i].type === "small") {
            const newOptions = options.havingBaseStyle(sequence[i].style);
            heightDepth *= newOptions.sizeMultiplier;
          }
          if (heightDepth > height) {
            return sequence[i];
          }
        }
        return sequence[sequence.length - 1];
      };
      const makeCustomSizedDelim = function(delim, height, center, options, mode, classes) {
        if (delim === "<" || delim === "\\lt" || delim === "⟨") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "⟩") {
          delim = "\\rangle";
        }
        let sequence;
        if (utils.contains(stackNeverDelimiters, delim)) {
          sequence = stackNeverDelimiterSequence;
        } else if (utils.contains(stackLargeDelimiters, delim)) {
          sequence = stackLargeDelimiterSequence;
        } else {
          sequence = stackAlwaysDelimiterSequence;
        }
        const delimType = traverseSequence(delim, height, sequence, options);
        if (delimType.type === "small") {
          return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
        } else if (delimType.type === "large") {
          return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
        } else {
          return makeStackedDelim(delim, height, center, options, mode, classes);
        }
      };
      const makeLeftRightDelim = function(delim, height, depth, options, mode, classes) {
        const axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
        const delimiterFactor = 901;
        const delimiterExtend = 5 / options.fontMetrics().ptPerEm;
        const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
        const totalHeight = Math.max(maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend);
        return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
      };
      var delimiter = {
        sqrtImage: makeSqrtImage,
        sizedDelim: makeSizedDelim,
        sizeToMaxHeight,
        customSizedDelim: makeCustomSizedDelim,
        leftRightDelim: makeLeftRightDelim
      };
      const delimiterSizes = {
        "\\bigl": {
          mclass: "mopen",
          size: 1
        },
        "\\Bigl": {
          mclass: "mopen",
          size: 2
        },
        "\\biggl": {
          mclass: "mopen",
          size: 3
        },
        "\\Biggl": {
          mclass: "mopen",
          size: 4
        },
        "\\bigr": {
          mclass: "mclose",
          size: 1
        },
        "\\Bigr": {
          mclass: "mclose",
          size: 2
        },
        "\\biggr": {
          mclass: "mclose",
          size: 3
        },
        "\\Biggr": {
          mclass: "mclose",
          size: 4
        },
        "\\bigm": {
          mclass: "mrel",
          size: 1
        },
        "\\Bigm": {
          mclass: "mrel",
          size: 2
        },
        "\\biggm": {
          mclass: "mrel",
          size: 3
        },
        "\\Biggm": {
          mclass: "mrel",
          size: 4
        },
        "\\big": {
          mclass: "mord",
          size: 1
        },
        "\\Big": {
          mclass: "mord",
          size: 2
        },
        "\\bigg": {
          mclass: "mord",
          size: 3
        },
        "\\Bigg": {
          mclass: "mord",
          size: 4
        }
      };
      const delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
      function checkDelimiter(delim, context) {
        const symDelim = checkSymbolNodeType(delim);
        if (symDelim && utils.contains(delimiters, symDelim.text)) {
          return symDelim;
        } else if (symDelim) {
          throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
        } else {
          throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
        }
      }
      defineFunction({
        type: "delimsizing",
        names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
        props: {
          numArgs: 1,
          argTypes: ["primitive"]
        },
        handler: (context, args) => {
          const delim = checkDelimiter(args[0], context);
          return {
            type: "delimsizing",
            mode: context.parser.mode,
            size: delimiterSizes[context.funcName].size,
            mclass: delimiterSizes[context.funcName].mclass,
            delim: delim.text
          };
        },
        htmlBuilder: (group, options) => {
          if (group.delim === ".") {
            return buildCommon.makeSpan([group.mclass]);
          }
          return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
        },
        mathmlBuilder: (group) => {
          const children = [];
          if (group.delim !== ".") {
            children.push(makeText(group.delim, group.mode));
          }
          const node = new mathMLTree.MathNode("mo", children);
          if (group.mclass === "mopen" || group.mclass === "mclose") {
            node.setAttribute("fence", "true");
          } else {
            node.setAttribute("fence", "false");
          }
          node.setAttribute("stretchy", "true");
          const size = makeEm(delimiter.sizeToMaxHeight[group.size]);
          node.setAttribute("minsize", size);
          node.setAttribute("maxsize", size);
          return node;
        }
      });
      function assertParsed(group) {
        if (!group.body) {
          throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
        }
      }
      defineFunction({
        type: "leftright-right",
        names: ["\\right"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: (context, args) => {
          const color = context.parser.gullet.macros.get("\\current@color");
          if (color && typeof color !== "string") {
            throw new src_ParseError("\\current@color set to non-string in \\right");
          }
          return {
            type: "leftright-right",
            mode: context.parser.mode,
            delim: checkDelimiter(args[0], context).text,
            color
          };
        }
      });
      defineFunction({
        type: "leftright",
        names: ["\\left"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: (context, args) => {
          const delim = checkDelimiter(args[0], context);
          const parser = context.parser;
          ++parser.leftrightDepth;
          const body = parser.parseExpression(false);
          --parser.leftrightDepth;
          parser.expect("\\right", false);
          const right = assertNodeType(parser.parseFunction(), "leftright-right");
          return {
            type: "leftright",
            mode: parser.mode,
            body,
            left: delim.text,
            right: right.delim,
            rightColor: right.color
          };
        },
        htmlBuilder: (group, options) => {
          assertParsed(group);
          const inner2 = buildExpression(group.body, options, true, ["mopen", "mclose"]);
          let innerHeight = 0;
          let innerDepth = 0;
          let hadMiddle = false;
          for (let i = 0;i < inner2.length; i++) {
            if (inner2[i].isMiddle) {
              hadMiddle = true;
            } else {
              innerHeight = Math.max(inner2[i].height, innerHeight);
              innerDepth = Math.max(inner2[i].depth, innerDepth);
            }
          }
          innerHeight *= options.sizeMultiplier;
          innerDepth *= options.sizeMultiplier;
          let leftDelim;
          if (group.left === ".") {
            leftDelim = makeNullDelimiter(options, ["mopen"]);
          } else {
            leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
          }
          inner2.unshift(leftDelim);
          if (hadMiddle) {
            for (let i = 1;i < inner2.length; i++) {
              const middleDelim = inner2[i];
              const isMiddle = middleDelim.isMiddle;
              if (isMiddle) {
                inner2[i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
              }
            }
          }
          let rightDelim;
          if (group.right === ".") {
            rightDelim = makeNullDelimiter(options, ["mclose"]);
          } else {
            const colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
            rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
          }
          inner2.push(rightDelim);
          return buildCommon.makeSpan(["minner"], inner2, options);
        },
        mathmlBuilder: (group, options) => {
          assertParsed(group);
          const inner2 = buildMathML_buildExpression(group.body, options);
          if (group.left !== ".") {
            const leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
            leftNode.setAttribute("fence", "true");
            inner2.unshift(leftNode);
          }
          if (group.right !== ".") {
            const rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
            rightNode.setAttribute("fence", "true");
            if (group.rightColor) {
              rightNode.setAttribute("mathcolor", group.rightColor);
            }
            inner2.push(rightNode);
          }
          return makeRow(inner2);
        }
      });
      defineFunction({
        type: "middle",
        names: ["\\middle"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: (context, args) => {
          const delim = checkDelimiter(args[0], context);
          if (!context.parser.leftrightDepth) {
            throw new src_ParseError("\\middle without preceding \\left", delim);
          }
          return {
            type: "middle",
            mode: context.parser.mode,
            delim: delim.text
          };
        },
        htmlBuilder: (group, options) => {
          let middleDelim;
          if (group.delim === ".") {
            middleDelim = makeNullDelimiter(options, []);
          } else {
            middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
            const isMiddle = {
              delim: group.delim,
              options
            };
            middleDelim.isMiddle = isMiddle;
          }
          return middleDelim;
        },
        mathmlBuilder: (group, options) => {
          const textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
          const middleNode = new mathMLTree.MathNode("mo", [textNode]);
          middleNode.setAttribute("fence", "true");
          middleNode.setAttribute("lspace", "0.05em");
          middleNode.setAttribute("rspace", "0.05em");
          return middleNode;
        }
      });
      const enclose_htmlBuilder = (group, options) => {
        const inner2 = buildCommon.wrapFragment(buildGroup(group.body, options), options);
        const label = group.label.slice(1);
        let scale = options.sizeMultiplier;
        let img;
        let imgShift = 0;
        const isSingleChar = utils.isCharacterBox(group.body);
        if (label === "sout") {
          img = buildCommon.makeSpan(["stretchy", "sout"]);
          img.height = options.fontMetrics().defaultRuleThickness / scale;
          imgShift = -0.5 * options.fontMetrics().xHeight;
        } else if (label === "phase") {
          const lineWeight = calculateSize({
            number: 0.6,
            unit: "pt"
          }, options);
          const clearance = calculateSize({
            number: 0.35,
            unit: "ex"
          }, options);
          const newOptions = options.havingBaseSizing();
          scale = scale / newOptions.sizeMultiplier;
          const angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
          inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
          const viewBoxHeight = Math.floor(1000 * angleHeight * scale);
          const path2 = phasePath(viewBoxHeight);
          const svgNode = new SvgNode([new PathNode("phase", path2)], {
            width: "400em",
            height: makeEm(viewBoxHeight / 1000),
            viewBox: "0 0 400000 " + viewBoxHeight,
            preserveAspectRatio: "xMinYMin slice"
          });
          img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
          img.style.height = makeEm(angleHeight);
          imgShift = inner2.depth + lineWeight + clearance;
        } else {
          if (/cancel/.test(label)) {
            if (!isSingleChar) {
              inner2.classes.push("cancel-pad");
            }
          } else if (label === "angl") {
            inner2.classes.push("anglpad");
          } else {
            inner2.classes.push("boxpad");
          }
          let topPad = 0;
          let bottomPad = 0;
          let ruleThickness = 0;
          if (/box/.test(label)) {
            ruleThickness = Math.max(options.fontMetrics().fboxrule, options.minRuleThickness);
            topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
            bottomPad = topPad;
          } else if (label === "angl") {
            ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
            topPad = 4 * ruleThickness;
            bottomPad = Math.max(0, 0.25 - inner2.depth);
          } else {
            topPad = isSingleChar ? 0.2 : 0;
            bottomPad = topPad;
          }
          img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
          if (/fbox|boxed|fcolorbox/.test(label)) {
            img.style.borderStyle = "solid";
            img.style.borderWidth = makeEm(ruleThickness);
          } else if (label === "angl" && ruleThickness !== 0.049) {
            img.style.borderTopWidth = makeEm(ruleThickness);
            img.style.borderRightWidth = makeEm(ruleThickness);
          }
          imgShift = inner2.depth + bottomPad;
          if (group.backgroundColor) {
            img.style.backgroundColor = group.backgroundColor;
            if (group.borderColor) {
              img.style.borderColor = group.borderColor;
            }
          }
        }
        let vlist;
        if (group.backgroundColor) {
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [
              {
                type: "elem",
                elem: img,
                shift: imgShift
              },
              {
                type: "elem",
                elem: inner2,
                shift: 0
              }
            ]
          }, options);
        } else {
          const classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [
              {
                type: "elem",
                elem: inner2,
                shift: 0
              },
              {
                type: "elem",
                elem: img,
                shift: imgShift,
                wrapperClasses: classes
              }
            ]
          }, options);
        }
        if (/cancel/.test(label)) {
          vlist.height = inner2.height;
          vlist.depth = inner2.depth;
        }
        if (/cancel/.test(label) && !isSingleChar) {
          return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
        } else {
          return buildCommon.makeSpan(["mord"], [vlist], options);
        }
      };
      const enclose_mathmlBuilder = (group, options) => {
        let fboxsep = 0;
        const node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
        switch (group.label) {
          case "\\cancel":
            node.setAttribute("notation", "updiagonalstrike");
            break;
          case "\\bcancel":
            node.setAttribute("notation", "downdiagonalstrike");
            break;
          case "\\phase":
            node.setAttribute("notation", "phasorangle");
            break;
          case "\\sout":
            node.setAttribute("notation", "horizontalstrike");
            break;
          case "\\fbox":
            node.setAttribute("notation", "box");
            break;
          case "\\angl":
            node.setAttribute("notation", "actuarial");
            break;
          case "\\fcolorbox":
          case "\\colorbox":
            fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
            node.setAttribute("width", "+" + 2 * fboxsep + "pt");
            node.setAttribute("height", "+" + 2 * fboxsep + "pt");
            node.setAttribute("lspace", fboxsep + "pt");
            node.setAttribute("voffset", fboxsep + "pt");
            if (group.label === "\\fcolorbox") {
              const thk = Math.max(options.fontMetrics().fboxrule, options.minRuleThickness);
              node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
            }
            break;
          case "\\xcancel":
            node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
            break;
        }
        if (group.backgroundColor) {
          node.setAttribute("mathbackground", group.backgroundColor);
        }
        return node;
      };
      defineFunction({
        type: "enclose",
        names: ["\\colorbox"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "text"]
        },
        handler(_ref, args, optArgs) {
          let {
            parser,
            funcName
          } = _ref;
          const color = assertNodeType(args[0], "color-token").color;
          const body = args[1];
          return {
            type: "enclose",
            mode: parser.mode,
            label: funcName,
            backgroundColor: color,
            body
          };
        },
        htmlBuilder: enclose_htmlBuilder,
        mathmlBuilder: enclose_mathmlBuilder
      });
      defineFunction({
        type: "enclose",
        names: ["\\fcolorbox"],
        props: {
          numArgs: 3,
          allowedInText: true,
          argTypes: ["color", "color", "text"]
        },
        handler(_ref2, args, optArgs) {
          let {
            parser,
            funcName
          } = _ref2;
          const borderColor = assertNodeType(args[0], "color-token").color;
          const backgroundColor = assertNodeType(args[1], "color-token").color;
          const body = args[2];
          return {
            type: "enclose",
            mode: parser.mode,
            label: funcName,
            backgroundColor,
            borderColor,
            body
          };
        },
        htmlBuilder: enclose_htmlBuilder,
        mathmlBuilder: enclose_mathmlBuilder
      });
      defineFunction({
        type: "enclose",
        names: ["\\fbox"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: true
        },
        handler(_ref3, args) {
          let {
            parser
          } = _ref3;
          return {
            type: "enclose",
            mode: parser.mode,
            label: "\\fbox",
            body: args[0]
          };
        }
      });
      defineFunction({
        type: "enclose",
        names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
        props: {
          numArgs: 1
        },
        handler(_ref4, args) {
          let {
            parser,
            funcName
          } = _ref4;
          const body = args[0];
          return {
            type: "enclose",
            mode: parser.mode,
            label: funcName,
            body
          };
        },
        htmlBuilder: enclose_htmlBuilder,
        mathmlBuilder: enclose_mathmlBuilder
      });
      defineFunction({
        type: "enclose",
        names: ["\\angl"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: false
        },
        handler(_ref5, args) {
          let {
            parser
          } = _ref5;
          return {
            type: "enclose",
            mode: parser.mode,
            label: "\\angl",
            body: args[0]
          };
        }
      });
      const _environments = {};
      function defineEnvironment(_ref) {
        let {
          type,
          names,
          props,
          handler,
          htmlBuilder: htmlBuilder2,
          mathmlBuilder: mathmlBuilder2
        } = _ref;
        const data = {
          type,
          numArgs: props.numArgs || 0,
          allowedInText: false,
          numOptionalArgs: 0,
          handler
        };
        for (let i = 0;i < names.length; ++i) {
          _environments[names[i]] = data;
        }
        if (htmlBuilder2) {
          _htmlGroupBuilders[type] = htmlBuilder2;
        }
        if (mathmlBuilder2) {
          _mathmlGroupBuilders[type] = mathmlBuilder2;
        }
      }
      const _macros = {};
      function defineMacro(name, body) {
        _macros[name] = body;
      }

      class SourceLocation {
        constructor(lexer, start, end) {
          this.lexer = undefined;
          this.start = undefined;
          this.end = undefined;
          this.lexer = lexer;
          this.start = start;
          this.end = end;
        }
        static range(first, second) {
          if (!second) {
            return first && first.loc;
          } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
            return null;
          } else {
            return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
          }
        }
      }

      class Token {
        constructor(text, loc) {
          this.text = undefined;
          this.loc = undefined;
          this.noexpand = undefined;
          this.treatAsRelax = undefined;
          this.text = text;
          this.loc = loc;
        }
        range(endToken, text) {
          return new Token(text, SourceLocation.range(this, endToken));
        }
      }
      function getHLines(parser) {
        const hlineInfo = [];
        parser.consumeSpaces();
        let nxt = parser.fetch().text;
        if (nxt === "\\relax") {
          parser.consume();
          parser.consumeSpaces();
          nxt = parser.fetch().text;
        }
        while (nxt === "\\hline" || nxt === "\\hdashline") {
          parser.consume();
          hlineInfo.push(nxt === "\\hdashline");
          parser.consumeSpaces();
          nxt = parser.fetch().text;
        }
        return hlineInfo;
      }
      const validateAmsEnvironmentContext = (context) => {
        const settings = context.parser.settings;
        if (!settings.displayMode) {
          throw new src_ParseError("{" + context.envName + "} can be used only in" + " display mode.");
        }
      };
      function getAutoTag(name) {
        if (name.indexOf("ed") === -1) {
          return name.indexOf("*") === -1;
        }
      }
      function parseArray(parser, _ref, style) {
        let {
          hskipBeforeAndAfter,
          addJot,
          cols,
          arraystretch,
          colSeparationType,
          autoTag,
          singleRow,
          emptySingleRow,
          maxNumCols,
          leqno
        } = _ref;
        parser.gullet.beginGroup();
        if (!singleRow) {
          parser.gullet.macros.set("\\cr", "\\\\\\relax");
        }
        if (!arraystretch) {
          const stretch = parser.gullet.expandMacroAsText("\\arraystretch");
          if (stretch == null) {
            arraystretch = 1;
          } else {
            arraystretch = parseFloat(stretch);
            if (!arraystretch || arraystretch < 0) {
              throw new src_ParseError("Invalid \\arraystretch: " + stretch);
            }
          }
        }
        parser.gullet.beginGroup();
        let row = [];
        const body = [row];
        const rowGaps = [];
        const hLinesBeforeRow = [];
        const tags = autoTag != null ? [] : undefined;
        function beginRow() {
          if (autoTag) {
            parser.gullet.macros.set("\\@eqnsw", "1", true);
          }
        }
        function endRow() {
          if (tags) {
            if (parser.gullet.macros.get("\\df@tag")) {
              tags.push(parser.subparse([new Token("\\df@tag")]));
              parser.gullet.macros.set("\\df@tag", undefined, true);
            } else {
              tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
            }
          }
        }
        beginRow();
        hLinesBeforeRow.push(getHLines(parser));
        while (true) {
          let cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
          parser.gullet.endGroup();
          parser.gullet.beginGroup();
          cell = {
            type: "ordgroup",
            mode: parser.mode,
            body: cell
          };
          if (style) {
            cell = {
              type: "styling",
              mode: parser.mode,
              style,
              body: [cell]
            };
          }
          row.push(cell);
          const next = parser.fetch().text;
          if (next === "&") {
            if (maxNumCols && row.length === maxNumCols) {
              if (singleRow || colSeparationType) {
                throw new src_ParseError("Too many tab characters: &", parser.nextToken);
              } else {
                parser.settings.reportNonstrict("textEnv", "Too few columns " + "specified in the {array} column argument.");
              }
            }
            parser.consume();
          } else if (next === "\\end") {
            endRow();
            if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
              body.pop();
            }
            if (hLinesBeforeRow.length < body.length + 1) {
              hLinesBeforeRow.push([]);
            }
            break;
          } else if (next === "\\\\") {
            parser.consume();
            let size;
            if (parser.gullet.future().text !== " ") {
              size = parser.parseSizeGroup(true);
            }
            rowGaps.push(size ? size.value : null);
            endRow();
            hLinesBeforeRow.push(getHLines(parser));
            row = [];
            body.push(row);
            beginRow();
          } else {
            throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
          }
        }
        parser.gullet.endGroup();
        parser.gullet.endGroup();
        return {
          type: "array",
          mode: parser.mode,
          addJot,
          arraystretch,
          body,
          cols,
          rowGaps,
          hskipBeforeAndAfter,
          hLinesBeforeRow,
          colSeparationType,
          tags,
          leqno
        };
      }
      function dCellStyle(envName) {
        if (envName.slice(0, 1) === "d") {
          return "display";
        } else {
          return "text";
        }
      }
      const array_htmlBuilder = function(group, options) {
        let r;
        let c4;
        const nr3 = group.body.length;
        const hLinesBeforeRow = group.hLinesBeforeRow;
        let nc = 0;
        let body = new Array(nr3);
        const hlines = [];
        const ruleThickness = Math.max(options.fontMetrics().arrayRuleWidth, options.minRuleThickness);
        const pt3 = 1 / options.fontMetrics().ptPerEm;
        let arraycolsep = 5 * pt3;
        if (group.colSeparationType && group.colSeparationType === "small") {
          const localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;
          arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
        }
        const baselineskip = group.colSeparationType === "CD" ? calculateSize({
          number: 3,
          unit: "ex"
        }, options) : 12 * pt3;
        const jot = 3 * pt3;
        const arrayskip = group.arraystretch * baselineskip;
        const arstrutHeight = 0.7 * arrayskip;
        const arstrutDepth = 0.3 * arrayskip;
        let totalHeight = 0;
        function setHLinePos(hlinesInGap) {
          for (let i = 0;i < hlinesInGap.length; ++i) {
            if (i > 0) {
              totalHeight += 0.25;
            }
            hlines.push({
              pos: totalHeight,
              isDashed: hlinesInGap[i]
            });
          }
        }
        setHLinePos(hLinesBeforeRow[0]);
        for (r = 0;r < group.body.length; ++r) {
          const inrow = group.body[r];
          let height = arstrutHeight;
          let depth = arstrutDepth;
          if (nc < inrow.length) {
            nc = inrow.length;
          }
          const outrow = new Array(inrow.length);
          for (c4 = 0;c4 < inrow.length; ++c4) {
            const elt = buildGroup(inrow[c4], options);
            if (depth < elt.depth) {
              depth = elt.depth;
            }
            if (height < elt.height) {
              height = elt.height;
            }
            outrow[c4] = elt;
          }
          const rowGap = group.rowGaps[r];
          let gap = 0;
          if (rowGap) {
            gap = calculateSize(rowGap, options);
            if (gap > 0) {
              gap += arstrutDepth;
              if (depth < gap) {
                depth = gap;
              }
              gap = 0;
            }
          }
          if (group.addJot) {
            depth += jot;
          }
          outrow.height = height;
          outrow.depth = depth;
          totalHeight += height;
          outrow.pos = totalHeight;
          totalHeight += depth + gap;
          body[r] = outrow;
          setHLinePos(hLinesBeforeRow[r + 1]);
        }
        const offset = totalHeight / 2 + options.fontMetrics().axisHeight;
        const colDescriptions = group.cols || [];
        const cols = [];
        let colSep;
        let colDescrNum;
        const tagSpans = [];
        if (group.tags && group.tags.some((tag) => tag)) {
          for (r = 0;r < nr3; ++r) {
            const rw = body[r];
            const shift = rw.pos - offset;
            const tag = group.tags[r];
            let tagSpan;
            if (tag === true) {
              tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
            } else if (tag === false) {
              tagSpan = buildCommon.makeSpan([], [], options);
            } else {
              tagSpan = buildCommon.makeSpan([], buildExpression(tag, options, true), options);
            }
            tagSpan.depth = rw.depth;
            tagSpan.height = rw.height;
            tagSpans.push({
              type: "elem",
              elem: tagSpan,
              shift
            });
          }
        }
        for (c4 = 0, colDescrNum = 0;c4 < nc || colDescrNum < colDescriptions.length; ++c4, ++colDescrNum) {
          let colDescr = colDescriptions[colDescrNum] || {};
          let firstSeparator = true;
          while (colDescr.type === "separator") {
            if (!firstSeparator) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
              cols.push(colSep);
            }
            if (colDescr.separator === "|" || colDescr.separator === ":") {
              const lineType = colDescr.separator === "|" ? "solid" : "dashed";
              const separator = buildCommon.makeSpan(["vertical-separator"], [], options);
              separator.style.height = makeEm(totalHeight);
              separator.style.borderRightWidth = makeEm(ruleThickness);
              separator.style.borderRightStyle = lineType;
              separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
              const shift = totalHeight - offset;
              if (shift) {
                separator.style.verticalAlign = makeEm(-shift);
              }
              cols.push(separator);
            } else {
              throw new src_ParseError("Invalid separator type: " + colDescr.separator);
            }
            colDescrNum++;
            colDescr = colDescriptions[colDescrNum] || {};
            firstSeparator = false;
          }
          if (c4 >= nc) {
            continue;
          }
          let sepwidth;
          if (c4 > 0 || group.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(sepwidth);
              cols.push(colSep);
            }
          }
          let col = [];
          for (r = 0;r < nr3; ++r) {
            const row = body[r];
            const elem = row[c4];
            if (!elem) {
              continue;
            }
            const shift = row.pos - offset;
            elem.depth = row.depth;
            elem.height = row.height;
            col.push({
              type: "elem",
              elem,
              shift
            });
          }
          col = buildCommon.makeVList({
            positionType: "individualShift",
            children: col
          }, options);
          col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
          cols.push(col);
          if (c4 < nc - 1 || group.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(sepwidth);
              cols.push(colSep);
            }
          }
        }
        body = buildCommon.makeSpan(["mtable"], cols);
        if (hlines.length > 0) {
          const line = buildCommon.makeLineSpan("hline", options, ruleThickness);
          const dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
          const vListElems = [{
            type: "elem",
            elem: body,
            shift: 0
          }];
          while (hlines.length > 0) {
            const hline = hlines.pop();
            const lineShift = hline.pos - offset;
            if (hline.isDashed) {
              vListElems.push({
                type: "elem",
                elem: dashes,
                shift: lineShift
              });
            } else {
              vListElems.push({
                type: "elem",
                elem: line,
                shift: lineShift
              });
            }
          }
          body = buildCommon.makeVList({
            positionType: "individualShift",
            children: vListElems
          }, options);
        }
        if (tagSpans.length === 0) {
          return buildCommon.makeSpan(["mord"], [body], options);
        } else {
          let eqnNumCol = buildCommon.makeVList({
            positionType: "individualShift",
            children: tagSpans
          }, options);
          eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
          return buildCommon.makeFragment([body, eqnNumCol]);
        }
      };
      const alignMap = {
        c: "center ",
        l: "left ",
        r: "right "
      };
      const array_mathmlBuilder = function(group, options) {
        const tbl = [];
        const glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
        const tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
        for (let i = 0;i < group.body.length; i++) {
          const rw = group.body[i];
          const row = [];
          for (let j4 = 0;j4 < rw.length; j4++) {
            row.push(new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(rw[j4], options)]));
          }
          if (group.tags && group.tags[i]) {
            row.unshift(glue);
            row.push(glue);
            if (group.leqno) {
              row.unshift(tag);
            } else {
              row.push(tag);
            }
          }
          tbl.push(new mathMLTree.MathNode("mtr", row));
        }
        let table = new mathMLTree.MathNode("mtable", tbl);
        const gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
        table.setAttribute("rowspacing", makeEm(gap));
        let menclose = "";
        let align = "";
        if (group.cols && group.cols.length > 0) {
          const cols = group.cols;
          let columnLines = "";
          let prevTypeWasAlign = false;
          let iStart = 0;
          let iEnd = cols.length;
          if (cols[0].type === "separator") {
            menclose += "top ";
            iStart = 1;
          }
          if (cols[cols.length - 1].type === "separator") {
            menclose += "bottom ";
            iEnd -= 1;
          }
          for (let i = iStart;i < iEnd; i++) {
            if (cols[i].type === "align") {
              align += alignMap[cols[i].align];
              if (prevTypeWasAlign) {
                columnLines += "none ";
              }
              prevTypeWasAlign = true;
            } else if (cols[i].type === "separator") {
              if (prevTypeWasAlign) {
                columnLines += cols[i].separator === "|" ? "solid " : "dashed ";
                prevTypeWasAlign = false;
              }
            }
          }
          table.setAttribute("columnalign", align.trim());
          if (/[sd]/.test(columnLines)) {
            table.setAttribute("columnlines", columnLines.trim());
          }
        }
        if (group.colSeparationType === "align") {
          const cols = group.cols || [];
          let spacing2 = "";
          for (let i = 1;i < cols.length; i++) {
            spacing2 += i % 2 ? "0em " : "1em ";
          }
          table.setAttribute("columnspacing", spacing2.trim());
        } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
          table.setAttribute("columnspacing", "0em");
        } else if (group.colSeparationType === "small") {
          table.setAttribute("columnspacing", "0.2778em");
        } else if (group.colSeparationType === "CD") {
          table.setAttribute("columnspacing", "0.5em");
        } else {
          table.setAttribute("columnspacing", "1em");
        }
        let rowLines = "";
        const hlines = group.hLinesBeforeRow;
        menclose += hlines[0].length > 0 ? "left " : "";
        menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
        for (let i = 1;i < hlines.length - 1; i++) {
          rowLines += hlines[i].length === 0 ? "none " : hlines[i][0] ? "dashed " : "solid ";
        }
        if (/[sd]/.test(rowLines)) {
          table.setAttribute("rowlines", rowLines.trim());
        }
        if (menclose !== "") {
          table = new mathMLTree.MathNode("menclose", [table]);
          table.setAttribute("notation", menclose.trim());
        }
        if (group.arraystretch && group.arraystretch < 1) {
          table = new mathMLTree.MathNode("mstyle", [table]);
          table.setAttribute("scriptlevel", "1");
        }
        return table;
      };
      const alignedHandler = function(context, args) {
        if (context.envName.indexOf("ed") === -1) {
          validateAmsEnvironmentContext(context);
        }
        const cols = [];
        const separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
        const isSplit = context.envName === "split";
        const res = parseArray(context.parser, {
          cols,
          addJot: true,
          autoTag: isSplit ? undefined : getAutoTag(context.envName),
          emptySingleRow: true,
          colSeparationType: separationType,
          maxNumCols: isSplit ? 2 : undefined,
          leqno: context.parser.settings.leqno
        }, "display");
        let numMaths;
        let numCols = 0;
        const emptyGroup = {
          type: "ordgroup",
          mode: context.mode,
          body: []
        };
        if (args[0] && args[0].type === "ordgroup") {
          let arg0 = "";
          for (let i = 0;i < args[0].body.length; i++) {
            const textord2 = assertNodeType(args[0].body[i], "textord");
            arg0 += textord2.text;
          }
          numMaths = Number(arg0);
          numCols = numMaths * 2;
        }
        const isAligned = !numCols;
        res.body.forEach(function(row) {
          for (let i = 1;i < row.length; i += 2) {
            const styling = assertNodeType(row[i], "styling");
            const ordgroup = assertNodeType(styling.body[0], "ordgroup");
            ordgroup.body.unshift(emptyGroup);
          }
          if (!isAligned) {
            const curMaths = row.length / 2;
            if (numMaths < curMaths) {
              throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
            }
          } else if (numCols < row.length) {
            numCols = row.length;
          }
        });
        for (let i = 0;i < numCols; ++i) {
          let align = "r";
          let pregap = 0;
          if (i % 2 === 1) {
            align = "l";
          } else if (i > 0 && isAligned) {
            pregap = 1;
          }
          cols[i] = {
            type: "align",
            align,
            pregap,
            postgap: 0
          };
        }
        res.colSeparationType = isAligned ? "align" : "alignat";
        return res;
      };
      defineEnvironment({
        type: "array",
        names: ["array", "darray"],
        props: {
          numArgs: 1
        },
        handler(context, args) {
          const symNode = checkSymbolNodeType(args[0]);
          const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
          const cols = colalign.map(function(nde) {
            const node = assertSymbolNodeType(nde);
            const ca2 = node.text;
            if ("lcr".indexOf(ca2) !== -1) {
              return {
                type: "align",
                align: ca2
              };
            } else if (ca2 === "|") {
              return {
                type: "separator",
                separator: "|"
              };
            } else if (ca2 === ":") {
              return {
                type: "separator",
                separator: ":"
              };
            }
            throw new src_ParseError("Unknown column alignment: " + ca2, nde);
          });
          const res = {
            cols,
            hskipBeforeAndAfter: true,
            maxNumCols: cols.length
          };
          return parseArray(context.parser, res, dCellStyle(context.envName));
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
        props: {
          numArgs: 0
        },
        handler(context) {
          const delimiters2 = {
            matrix: null,
            pmatrix: ["(", ")"],
            bmatrix: ["[", "]"],
            Bmatrix: ["\\{", "\\}"],
            vmatrix: ["|", "|"],
            Vmatrix: ["\\Vert", "\\Vert"]
          }[context.envName.replace("*", "")];
          let colAlign = "c";
          const payload = {
            hskipBeforeAndAfter: false,
            cols: [{
              type: "align",
              align: colAlign
            }]
          };
          if (context.envName.charAt(context.envName.length - 1) === "*") {
            const parser = context.parser;
            parser.consumeSpaces();
            if (parser.fetch().text === "[") {
              parser.consume();
              parser.consumeSpaces();
              colAlign = parser.fetch().text;
              if ("lcr".indexOf(colAlign) === -1) {
                throw new src_ParseError("Expected l or c or r", parser.nextToken);
              }
              parser.consume();
              parser.consumeSpaces();
              parser.expect("]");
              parser.consume();
              payload.cols = [{
                type: "align",
                align: colAlign
              }];
            }
          }
          const res = parseArray(context.parser, payload, dCellStyle(context.envName));
          const numCols = Math.max(0, ...res.body.map((row) => row.length));
          res.cols = new Array(numCols).fill({
            type: "align",
            align: colAlign
          });
          return delimiters2 ? {
            type: "leftright",
            mode: context.mode,
            body: [res],
            left: delimiters2[0],
            right: delimiters2[1],
            rightColor: undefined
          } : res;
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["smallmatrix"],
        props: {
          numArgs: 0
        },
        handler(context) {
          const payload = {
            arraystretch: 0.5
          };
          const res = parseArray(context.parser, payload, "script");
          res.colSeparationType = "small";
          return res;
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["subarray"],
        props: {
          numArgs: 1
        },
        handler(context, args) {
          const symNode = checkSymbolNodeType(args[0]);
          const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
          const cols = colalign.map(function(nde) {
            const node = assertSymbolNodeType(nde);
            const ca2 = node.text;
            if ("lc".indexOf(ca2) !== -1) {
              return {
                type: "align",
                align: ca2
              };
            }
            throw new src_ParseError("Unknown column alignment: " + ca2, nde);
          });
          if (cols.length > 1) {
            throw new src_ParseError("{subarray} can contain only one column");
          }
          let res = {
            cols,
            hskipBeforeAndAfter: false,
            arraystretch: 0.5
          };
          res = parseArray(context.parser, res, "script");
          if (res.body.length > 0 && res.body[0].length > 1) {
            throw new src_ParseError("{subarray} can contain only one column");
          }
          return res;
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["cases", "dcases", "rcases", "drcases"],
        props: {
          numArgs: 0
        },
        handler(context) {
          const payload = {
            arraystretch: 1.2,
            cols: [{
              type: "align",
              align: "l",
              pregap: 0,
              postgap: 1
            }, {
              type: "align",
              align: "l",
              pregap: 0,
              postgap: 0
            }]
          };
          const res = parseArray(context.parser, payload, dCellStyle(context.envName));
          return {
            type: "leftright",
            mode: context.mode,
            body: [res],
            left: context.envName.indexOf("r") > -1 ? "." : "\\{",
            right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
            rightColor: undefined
          };
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["align", "align*", "aligned", "split"],
        props: {
          numArgs: 0
        },
        handler: alignedHandler,
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["gathered", "gather", "gather*"],
        props: {
          numArgs: 0
        },
        handler(context) {
          if (utils.contains(["gather", "gather*"], context.envName)) {
            validateAmsEnvironmentContext(context);
          }
          const res = {
            cols: [{
              type: "align",
              align: "c"
            }],
            addJot: true,
            colSeparationType: "gather",
            autoTag: getAutoTag(context.envName),
            emptySingleRow: true,
            leqno: context.parser.settings.leqno
          };
          return parseArray(context.parser, res, "display");
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["alignat", "alignat*", "alignedat"],
        props: {
          numArgs: 1
        },
        handler: alignedHandler,
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["equation", "equation*"],
        props: {
          numArgs: 0
        },
        handler(context) {
          validateAmsEnvironmentContext(context);
          const res = {
            autoTag: getAutoTag(context.envName),
            emptySingleRow: true,
            singleRow: true,
            maxNumCols: 1,
            leqno: context.parser.settings.leqno
          };
          return parseArray(context.parser, res, "display");
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["CD"],
        props: {
          numArgs: 0
        },
        handler(context) {
          validateAmsEnvironmentContext(context);
          return parseCD(context.parser);
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
      defineMacro("\\notag", "\\nonumber");
      defineFunction({
        type: "text",
        names: ["\\hline", "\\hdashline"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: true
        },
        handler(context, args) {
          throw new src_ParseError(context.funcName + " valid only within array environment");
        }
      });
      const environments = _environments;
      var src_environments = environments;
      defineFunction({
        type: "environment",
        names: ["\\begin", "\\end"],
        props: {
          numArgs: 1,
          argTypes: ["text"]
        },
        handler(_ref, args) {
          let {
            parser,
            funcName
          } = _ref;
          const nameGroup = args[0];
          if (nameGroup.type !== "ordgroup") {
            throw new src_ParseError("Invalid environment name", nameGroup);
          }
          let envName = "";
          for (let i = 0;i < nameGroup.body.length; ++i) {
            envName += assertNodeType(nameGroup.body[i], "textord").text;
          }
          if (funcName === "\\begin") {
            if (!src_environments.hasOwnProperty(envName)) {
              throw new src_ParseError("No such environment: " + envName, nameGroup);
            }
            const env = src_environments[envName];
            const {
              args: args2,
              optArgs
            } = parser.parseArguments("\\begin{" + envName + "}", env);
            const context = {
              mode: parser.mode,
              envName,
              parser
            };
            const result = env.handler(context, args2, optArgs);
            parser.expect("\\end", false);
            const endNameToken = parser.nextToken;
            const end = assertNodeType(parser.parseFunction(), "environment");
            if (end.name !== envName) {
              throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
            }
            return result;
          }
          return {
            type: "environment",
            mode: parser.mode,
            name: envName,
            nameGroup
          };
        }
      });
      const font_htmlBuilder = (group, options) => {
        const font = group.font;
        const newOptions = options.withFont(font);
        return buildGroup(group.body, newOptions);
      };
      const font_mathmlBuilder = (group, options) => {
        const font = group.font;
        const newOptions = options.withFont(font);
        return buildMathML_buildGroup(group.body, newOptions);
      };
      const fontAliases = {
        "\\Bbb": "\\mathbb",
        "\\bold": "\\mathbf",
        "\\frak": "\\mathfrak",
        "\\bm": "\\boldsymbol"
      };
      defineFunction({
        type: "font",
        names: [
          "\\mathrm",
          "\\mathit",
          "\\mathbf",
          "\\mathnormal",
          "\\mathsfit",
          "\\mathbb",
          "\\mathcal",
          "\\mathfrak",
          "\\mathscr",
          "\\mathsf",
          "\\mathtt",
          "\\Bbb",
          "\\bold",
          "\\frak"
        ],
        props: {
          numArgs: 1,
          allowedInArgument: true
        },
        handler: (_ref, args) => {
          let {
            parser,
            funcName
          } = _ref;
          const body = normalizeArgument(args[0]);
          let func = funcName;
          if (func in fontAliases) {
            func = fontAliases[func];
          }
          return {
            type: "font",
            mode: parser.mode,
            font: func.slice(1),
            body
          };
        },
        htmlBuilder: font_htmlBuilder,
        mathmlBuilder: font_mathmlBuilder
      });
      defineFunction({
        type: "mclass",
        names: ["\\boldsymbol", "\\bm"],
        props: {
          numArgs: 1
        },
        handler: (_ref2, args) => {
          let {
            parser
          } = _ref2;
          const body = args[0];
          const isCharacterBox2 = utils.isCharacterBox(body);
          return {
            type: "mclass",
            mode: parser.mode,
            mclass: binrelClass(body),
            body: [{
              type: "font",
              mode: parser.mode,
              font: "boldsymbol",
              body
            }],
            isCharacterBox: isCharacterBox2
          };
        }
      });
      defineFunction({
        type: "font",
        names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: (_ref3, args) => {
          let {
            parser,
            funcName,
            breakOnTokenText
          } = _ref3;
          const {
            mode
          } = parser;
          const body = parser.parseExpression(true, breakOnTokenText);
          const style = "math" + funcName.slice(1);
          return {
            type: "font",
            mode,
            font: style,
            body: {
              type: "ordgroup",
              mode: parser.mode,
              body
            }
          };
        },
        htmlBuilder: font_htmlBuilder,
        mathmlBuilder: font_mathmlBuilder
      });
      const adjustStyle = (size, originalStyle) => {
        let style = originalStyle;
        if (size === "display") {
          style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
        } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
          style = src_Style.TEXT;
        } else if (size === "script") {
          style = src_Style.SCRIPT;
        } else if (size === "scriptscript") {
          style = src_Style.SCRIPTSCRIPT;
        }
        return style;
      };
      const genfrac_htmlBuilder = (group, options) => {
        const style = adjustStyle(group.size, options.style);
        const nstyle = style.fracNum();
        const dstyle = style.fracDen();
        let newOptions;
        newOptions = options.havingStyle(nstyle);
        const numerm = buildGroup(group.numer, newOptions, options);
        if (group.continued) {
          const hStrut = 8.5 / options.fontMetrics().ptPerEm;
          const dStrut = 3.5 / options.fontMetrics().ptPerEm;
          numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
          numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
        }
        newOptions = options.havingStyle(dstyle);
        const denomm = buildGroup(group.denom, newOptions, options);
        let rule;
        let ruleWidth;
        let ruleSpacing;
        if (group.hasBarLine) {
          if (group.barSize) {
            ruleWidth = calculateSize(group.barSize, options);
            rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
          } else {
            rule = buildCommon.makeLineSpan("frac-line", options);
          }
          ruleWidth = rule.height;
          ruleSpacing = rule.height;
        } else {
          rule = null;
          ruleWidth = 0;
          ruleSpacing = options.fontMetrics().defaultRuleThickness;
        }
        let numShift;
        let clearance;
        let denomShift;
        if (style.size === src_Style.DISPLAY.size || group.size === "display") {
          numShift = options.fontMetrics().num1;
          if (ruleWidth > 0) {
            clearance = 3 * ruleSpacing;
          } else {
            clearance = 7 * ruleSpacing;
          }
          denomShift = options.fontMetrics().denom1;
        } else {
          if (ruleWidth > 0) {
            numShift = options.fontMetrics().num2;
            clearance = ruleSpacing;
          } else {
            numShift = options.fontMetrics().num3;
            clearance = 3 * ruleSpacing;
          }
          denomShift = options.fontMetrics().denom2;
        }
        let frac;
        if (!rule) {
          const candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
          if (candidateClearance < clearance) {
            numShift += 0.5 * (clearance - candidateClearance);
            denomShift += 0.5 * (clearance - candidateClearance);
          }
          frac = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options);
        } else {
          const axisHeight = options.fontMetrics().axisHeight;
          if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
            numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
          }
          if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
            denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
          }
          const midShift = -(axisHeight - 0.5 * ruleWidth);
          frac = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: rule,
              shift: midShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options);
        }
        newOptions = options.havingStyle(style);
        frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
        frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
        let delimSize;
        if (style.size === src_Style.DISPLAY.size) {
          delimSize = options.fontMetrics().delim1;
        } else if (style.size === src_Style.SCRIPTSCRIPT.size) {
          delimSize = options.havingStyle(src_Style.SCRIPT).fontMetrics().delim2;
        } else {
          delimSize = options.fontMetrics().delim2;
        }
        let leftDelim;
        let rightDelim;
        if (group.leftDelim == null) {
          leftDelim = makeNullDelimiter(options, ["mopen"]);
        } else {
          leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
        }
        if (group.continued) {
          rightDelim = buildCommon.makeSpan([]);
        } else if (group.rightDelim == null) {
          rightDelim = makeNullDelimiter(options, ["mclose"]);
        } else {
          rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
        }
        return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
      };
      const genfrac_mathmlBuilder = (group, options) => {
        let node = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
        if (!group.hasBarLine) {
          node.setAttribute("linethickness", "0px");
        } else if (group.barSize) {
          const ruleWidth = calculateSize(group.barSize, options);
          node.setAttribute("linethickness", makeEm(ruleWidth));
        }
        const style = adjustStyle(group.size, options.style);
        if (style.size !== options.style.size) {
          node = new mathMLTree.MathNode("mstyle", [node]);
          const isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
          node.setAttribute("displaystyle", isDisplay);
          node.setAttribute("scriptlevel", "0");
        }
        if (group.leftDelim != null || group.rightDelim != null) {
          const withDelims = [];
          if (group.leftDelim != null) {
            const leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
            leftOp.setAttribute("fence", "true");
            withDelims.push(leftOp);
          }
          withDelims.push(node);
          if (group.rightDelim != null) {
            const rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
            rightOp.setAttribute("fence", "true");
            withDelims.push(rightOp);
          }
          return makeRow(withDelims);
        }
        return node;
      };
      defineFunction({
        type: "genfrac",
        names: [
          "\\dfrac",
          "\\frac",
          "\\tfrac",
          "\\dbinom",
          "\\binom",
          "\\tbinom",
          "\\\\atopfrac",
          "\\\\bracefrac",
          "\\\\brackfrac"
        ],
        props: {
          numArgs: 2,
          allowedInArgument: true
        },
        handler: (_ref, args) => {
          let {
            parser,
            funcName
          } = _ref;
          const numer = args[0];
          const denom = args[1];
          let hasBarLine;
          let leftDelim = null;
          let rightDelim = null;
          let size = "auto";
          switch (funcName) {
            case "\\dfrac":
            case "\\frac":
            case "\\tfrac":
              hasBarLine = true;
              break;
            case "\\\\atopfrac":
              hasBarLine = false;
              break;
            case "\\dbinom":
            case "\\binom":
            case "\\tbinom":
              hasBarLine = false;
              leftDelim = "(";
              rightDelim = ")";
              break;
            case "\\\\bracefrac":
              hasBarLine = false;
              leftDelim = "\\{";
              rightDelim = "\\}";
              break;
            case "\\\\brackfrac":
              hasBarLine = false;
              leftDelim = "[";
              rightDelim = "]";
              break;
            default:
              throw new Error("Unrecognized genfrac command");
          }
          switch (funcName) {
            case "\\dfrac":
            case "\\dbinom":
              size = "display";
              break;
            case "\\tfrac":
            case "\\tbinom":
              size = "text";
              break;
          }
          return {
            type: "genfrac",
            mode: parser.mode,
            continued: false,
            numer,
            denom,
            hasBarLine,
            leftDelim,
            rightDelim,
            size,
            barSize: null
          };
        },
        htmlBuilder: genfrac_htmlBuilder,
        mathmlBuilder: genfrac_mathmlBuilder
      });
      defineFunction({
        type: "genfrac",
        names: ["\\cfrac"],
        props: {
          numArgs: 2
        },
        handler: (_ref2, args) => {
          let {
            parser,
            funcName
          } = _ref2;
          const numer = args[0];
          const denom = args[1];
          return {
            type: "genfrac",
            mode: parser.mode,
            continued: true,
            numer,
            denom,
            hasBarLine: true,
            leftDelim: null,
            rightDelim: null,
            size: "display",
            barSize: null
          };
        }
      });
      defineFunction({
        type: "infix",
        names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
        props: {
          numArgs: 0,
          infix: true
        },
        handler(_ref3) {
          let {
            parser,
            funcName,
            token
          } = _ref3;
          let replaceWith;
          switch (funcName) {
            case "\\over":
              replaceWith = "\\frac";
              break;
            case "\\choose":
              replaceWith = "\\binom";
              break;
            case "\\atop":
              replaceWith = "\\\\atopfrac";
              break;
            case "\\brace":
              replaceWith = "\\\\bracefrac";
              break;
            case "\\brack":
              replaceWith = "\\\\brackfrac";
              break;
            default:
              throw new Error("Unrecognized infix genfrac command");
          }
          return {
            type: "infix",
            mode: parser.mode,
            replaceWith,
            token
          };
        }
      });
      const stylArray = ["display", "text", "script", "scriptscript"];
      const delimFromValue = function(delimString) {
        let delim = null;
        if (delimString.length > 0) {
          delim = delimString;
          delim = delim === "." ? null : delim;
        }
        return delim;
      };
      defineFunction({
        type: "genfrac",
        names: ["\\genfrac"],
        props: {
          numArgs: 6,
          allowedInArgument: true,
          argTypes: ["math", "math", "size", "text", "math", "math"]
        },
        handler(_ref4, args) {
          let {
            parser
          } = _ref4;
          const numer = args[4];
          const denom = args[5];
          const leftNode = normalizeArgument(args[0]);
          const leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
          const rightNode = normalizeArgument(args[1]);
          const rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
          const barNode = assertNodeType(args[2], "size");
          let hasBarLine;
          let barSize = null;
          if (barNode.isBlank) {
            hasBarLine = true;
          } else {
            barSize = barNode.value;
            hasBarLine = barSize.number > 0;
          }
          let size = "auto";
          let styl = args[3];
          if (styl.type === "ordgroup") {
            if (styl.body.length > 0) {
              const textOrd = assertNodeType(styl.body[0], "textord");
              size = stylArray[Number(textOrd.text)];
            }
          } else {
            styl = assertNodeType(styl, "textord");
            size = stylArray[Number(styl.text)];
          }
          return {
            type: "genfrac",
            mode: parser.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim,
            rightDelim,
            size
          };
        },
        htmlBuilder: genfrac_htmlBuilder,
        mathmlBuilder: genfrac_mathmlBuilder
      });
      defineFunction({
        type: "infix",
        names: ["\\above"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          infix: true
        },
        handler(_ref5, args) {
          let {
            parser,
            funcName,
            token
          } = _ref5;
          return {
            type: "infix",
            mode: parser.mode,
            replaceWith: "\\\\abovefrac",
            size: assertNodeType(args[0], "size").value,
            token
          };
        }
      });
      defineFunction({
        type: "genfrac",
        names: ["\\\\abovefrac"],
        props: {
          numArgs: 3,
          argTypes: ["math", "size", "math"]
        },
        handler: (_ref6, args) => {
          let {
            parser,
            funcName
          } = _ref6;
          const numer = args[0];
          const barSize = assert(assertNodeType(args[1], "infix").size);
          const denom = args[2];
          const hasBarLine = barSize.number > 0;
          return {
            type: "genfrac",
            mode: parser.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim: null,
            rightDelim: null,
            size: "auto"
          };
        },
        htmlBuilder: genfrac_htmlBuilder,
        mathmlBuilder: genfrac_mathmlBuilder
      });
      const horizBrace_htmlBuilder = (grp, options) => {
        const style = options.style;
        let supSubGroup;
        let group;
        if (grp.type === "supsub") {
          supSubGroup = grp.sup ? buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildGroup(grp.sub, options.havingStyle(style.sub()), options);
          group = assertNodeType(grp.base, "horizBrace");
        } else {
          group = assertNodeType(grp, "horizBrace");
        }
        const body = buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY));
        const braceBody = stretchy.svgSpan(group, options);
        let vlist;
        if (group.isOver) {
          vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: braceBody
            }]
          }, options);
          vlist.children[0].children[0].children[1].classes.push("svg-align");
        } else {
          vlist = buildCommon.makeVList({
            positionType: "bottom",
            positionData: body.depth + 0.1 + braceBody.height,
            children: [{
              type: "elem",
              elem: braceBody
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: body
            }]
          }, options);
          vlist.children[0].children[0].children[0].classes.push("svg-align");
        }
        if (supSubGroup) {
          const vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
          if (group.isOver) {
            vlist = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: vSpan
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: supSubGroup
              }]
            }, options);
          } else {
            vlist = buildCommon.makeVList({
              positionType: "bottom",
              positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
              children: [{
                type: "elem",
                elem: supSubGroup
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: vSpan
              }]
            }, options);
          }
        }
        return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
      };
      const horizBrace_mathmlBuilder = (group, options) => {
        const accentNode = stretchy.mathMLnode(group.label);
        return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
      };
      defineFunction({
        type: "horizBrace",
        names: ["\\overbrace", "\\underbrace"],
        props: {
          numArgs: 1
        },
        handler(_ref, args) {
          let {
            parser,
            funcName
          } = _ref;
          return {
            type: "horizBrace",
            mode: parser.mode,
            label: funcName,
            isOver: /^\\over/.test(funcName),
            base: args[0]
          };
        },
        htmlBuilder: horizBrace_htmlBuilder,
        mathmlBuilder: horizBrace_mathmlBuilder
      });
      defineFunction({
        type: "href",
        names: ["\\href"],
        props: {
          numArgs: 2,
          argTypes: ["url", "original"],
          allowedInText: true
        },
        handler: (_ref, args) => {
          let {
            parser
          } = _ref;
          const body = args[1];
          const href = assertNodeType(args[0], "url").url;
          if (!parser.settings.isTrusted({
            command: "\\href",
            url: href
          })) {
            return parser.formatUnsupportedCmd("\\href");
          }
          return {
            type: "href",
            mode: parser.mode,
            href,
            body: ordargument(body)
          };
        },
        htmlBuilder: (group, options) => {
          const elements = buildExpression(group.body, options, false);
          return buildCommon.makeAnchor(group.href, [], elements, options);
        },
        mathmlBuilder: (group, options) => {
          let math2 = buildExpressionRow(group.body, options);
          if (!(math2 instanceof MathNode)) {
            math2 = new MathNode("mrow", [math2]);
          }
          math2.setAttribute("href", group.href);
          return math2;
        }
      });
      defineFunction({
        type: "href",
        names: ["\\url"],
        props: {
          numArgs: 1,
          argTypes: ["url"],
          allowedInText: true
        },
        handler: (_ref2, args) => {
          let {
            parser
          } = _ref2;
          const href = assertNodeType(args[0], "url").url;
          if (!parser.settings.isTrusted({
            command: "\\url",
            url: href
          })) {
            return parser.formatUnsupportedCmd("\\url");
          }
          const chars = [];
          for (let i = 0;i < href.length; i++) {
            let c4 = href[i];
            if (c4 === "~") {
              c4 = "\\textasciitilde";
            }
            chars.push({
              type: "textord",
              mode: "text",
              text: c4
            });
          }
          const body = {
            type: "text",
            mode: parser.mode,
            font: "\\texttt",
            body: chars
          };
          return {
            type: "href",
            mode: parser.mode,
            href,
            body: ordargument(body)
          };
        }
      });
      defineFunction({
        type: "hbox",
        names: ["\\hbox"],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInText: true,
          primitive: true
        },
        handler(_ref, args) {
          let {
            parser
          } = _ref;
          return {
            type: "hbox",
            mode: parser.mode,
            body: ordargument(args[0])
          };
        },
        htmlBuilder(group, options) {
          const elements = buildExpression(group.body, options, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder(group, options) {
          return new mathMLTree.MathNode("mrow", buildMathML_buildExpression(group.body, options));
        }
      });
      defineFunction({
        type: "html",
        names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
        props: {
          numArgs: 2,
          argTypes: ["raw", "original"],
          allowedInText: true
        },
        handler: (_ref, args) => {
          let {
            parser,
            funcName,
            token
          } = _ref;
          const value = assertNodeType(args[0], "raw").string;
          const body = args[1];
          if (parser.settings.strict) {
            parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
          }
          let trustContext;
          const attributes = {};
          switch (funcName) {
            case "\\htmlClass":
              attributes.class = value;
              trustContext = {
                command: "\\htmlClass",
                class: value
              };
              break;
            case "\\htmlId":
              attributes.id = value;
              trustContext = {
                command: "\\htmlId",
                id: value
              };
              break;
            case "\\htmlStyle":
              attributes.style = value;
              trustContext = {
                command: "\\htmlStyle",
                style: value
              };
              break;
            case "\\htmlData": {
              const data = value.split(",");
              for (let i = 0;i < data.length; i++) {
                const keyVal = data[i].split("=");
                if (keyVal.length !== 2) {
                  throw new src_ParseError("Error parsing key-value for \\htmlData");
                }
                attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
              }
              trustContext = {
                command: "\\htmlData",
                attributes
              };
              break;
            }
            default:
              throw new Error("Unrecognized html command");
          }
          if (!parser.settings.isTrusted(trustContext)) {
            return parser.formatUnsupportedCmd(funcName);
          }
          return {
            type: "html",
            mode: parser.mode,
            attributes,
            body: ordargument(body)
          };
        },
        htmlBuilder: (group, options) => {
          const elements = buildExpression(group.body, options, false);
          const classes = ["enclosing"];
          if (group.attributes.class) {
            classes.push(...group.attributes.class.trim().split(/\s+/));
          }
          const span = buildCommon.makeSpan(classes, elements, options);
          for (const attr in group.attributes) {
            if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
              span.setAttribute(attr, group.attributes[attr]);
            }
          }
          return span;
        },
        mathmlBuilder: (group, options) => {
          return buildExpressionRow(group.body, options);
        }
      });
      defineFunction({
        type: "htmlmathml",
        names: ["\\html@mathml"],
        props: {
          numArgs: 2,
          allowedInText: true
        },
        handler: (_ref, args) => {
          let {
            parser
          } = _ref;
          return {
            type: "htmlmathml",
            mode: parser.mode,
            html: ordargument(args[0]),
            mathml: ordargument(args[1])
          };
        },
        htmlBuilder: (group, options) => {
          const elements = buildExpression(group.html, options, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: (group, options) => {
          return buildExpressionRow(group.mathml, options);
        }
      });
      const sizeData = function(str) {
        if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
          return {
            number: +str,
            unit: "bp"
          };
        } else {
          const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
          if (!match) {
            throw new src_ParseError("Invalid size: '" + str + "' in \\includegraphics");
          }
          const data = {
            number: +(match[1] + match[2]),
            unit: match[3]
          };
          if (!validUnit(data)) {
            throw new src_ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
          }
          return data;
        }
      };
      defineFunction({
        type: "includegraphics",
        names: ["\\includegraphics"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          argTypes: ["raw", "url"],
          allowedInText: false
        },
        handler: (_ref, args, optArgs) => {
          let {
            parser
          } = _ref;
          let width = {
            number: 0,
            unit: "em"
          };
          let height = {
            number: 0.9,
            unit: "em"
          };
          let totalheight = {
            number: 0,
            unit: "em"
          };
          let alt = "";
          if (optArgs[0]) {
            const attributeStr = assertNodeType(optArgs[0], "raw").string;
            const attributes = attributeStr.split(",");
            for (let i = 0;i < attributes.length; i++) {
              const keyVal = attributes[i].split("=");
              if (keyVal.length === 2) {
                const str = keyVal[1].trim();
                switch (keyVal[0].trim()) {
                  case "alt":
                    alt = str;
                    break;
                  case "width":
                    width = sizeData(str);
                    break;
                  case "height":
                    height = sizeData(str);
                    break;
                  case "totalheight":
                    totalheight = sizeData(str);
                    break;
                  default:
                    throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                }
              }
            }
          }
          const src = assertNodeType(args[0], "url").url;
          if (alt === "") {
            alt = src;
            alt = alt.replace(/^.*[\\/]/, "");
            alt = alt.substring(0, alt.lastIndexOf("."));
          }
          if (!parser.settings.isTrusted({
            command: "\\includegraphics",
            url: src
          })) {
            return parser.formatUnsupportedCmd("\\includegraphics");
          }
          return {
            type: "includegraphics",
            mode: parser.mode,
            alt,
            width,
            height,
            totalheight,
            src
          };
        },
        htmlBuilder: (group, options) => {
          const height = calculateSize(group.height, options);
          let depth = 0;
          if (group.totalheight.number > 0) {
            depth = calculateSize(group.totalheight, options) - height;
          }
          let width = 0;
          if (group.width.number > 0) {
            width = calculateSize(group.width, options);
          }
          const style = {
            height: makeEm(height + depth)
          };
          if (width > 0) {
            style.width = makeEm(width);
          }
          if (depth > 0) {
            style.verticalAlign = makeEm(-depth);
          }
          const node = new Img(group.src, group.alt, style);
          node.height = height;
          node.depth = depth;
          return node;
        },
        mathmlBuilder: (group, options) => {
          const node = new mathMLTree.MathNode("mglyph", []);
          node.setAttribute("alt", group.alt);
          const height = calculateSize(group.height, options);
          let depth = 0;
          if (group.totalheight.number > 0) {
            depth = calculateSize(group.totalheight, options) - height;
            node.setAttribute("valign", makeEm(-depth));
          }
          node.setAttribute("height", makeEm(height + depth));
          if (group.width.number > 0) {
            const width = calculateSize(group.width, options);
            node.setAttribute("width", makeEm(width));
          }
          node.setAttribute("src", group.src);
          return node;
        }
      });
      defineFunction({
        type: "kern",
        names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          primitive: true,
          allowedInText: true
        },
        handler(_ref, args) {
          let {
            parser,
            funcName
          } = _ref;
          const size = assertNodeType(args[0], "size");
          if (parser.settings.strict) {
            const mathFunction = funcName[1] === "m";
            const muUnit = size.value.unit === "mu";
            if (mathFunction) {
              if (!muUnit) {
                parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
              }
              if (parser.mode !== "math") {
                parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
              }
            } else {
              if (muUnit) {
                parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
              }
            }
          }
          return {
            type: "kern",
            mode: parser.mode,
            dimension: size.value
          };
        },
        htmlBuilder(group, options) {
          return buildCommon.makeGlue(group.dimension, options);
        },
        mathmlBuilder(group, options) {
          const dimension = calculateSize(group.dimension, options);
          return new mathMLTree.SpaceNode(dimension);
        }
      });
      defineFunction({
        type: "lap",
        names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: (_ref, args) => {
          let {
            parser,
            funcName
          } = _ref;
          const body = args[0];
          return {
            type: "lap",
            mode: parser.mode,
            alignment: funcName.slice(5),
            body
          };
        },
        htmlBuilder: (group, options) => {
          let inner2;
          if (group.alignment === "clap") {
            inner2 = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
            inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
          } else {
            inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options)]);
          }
          const fix = buildCommon.makeSpan(["fix"], []);
          let node = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
          const strut = buildCommon.makeSpan(["strut"]);
          strut.style.height = makeEm(node.height + node.depth);
          if (node.depth) {
            strut.style.verticalAlign = makeEm(-node.depth);
          }
          node.children.unshift(strut);
          node = buildCommon.makeSpan(["thinbox"], [node], options);
          return buildCommon.makeSpan(["mord", "vbox"], [node], options);
        },
        mathmlBuilder: (group, options) => {
          const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
          if (group.alignment !== "rlap") {
            const offset = group.alignment === "llap" ? "-1" : "-0.5";
            node.setAttribute("lspace", offset + "width");
          }
          node.setAttribute("width", "0px");
          return node;
        }
      });
      defineFunction({
        type: "styling",
        names: ["\\(", "$"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler(_ref, args) {
          let {
            funcName,
            parser
          } = _ref;
          const outerMode = parser.mode;
          parser.switchMode("math");
          const close = funcName === "\\(" ? "\\)" : "$";
          const body = parser.parseExpression(false, close);
          parser.expect(close);
          parser.switchMode(outerMode);
          return {
            type: "styling",
            mode: parser.mode,
            style: "text",
            body
          };
        }
      });
      defineFunction({
        type: "text",
        names: ["\\)", "\\]"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler(context, args) {
          throw new src_ParseError("Mismatched " + context.funcName);
        }
      });
      const chooseMathStyle = (group, options) => {
        switch (options.style.size) {
          case src_Style.DISPLAY.size:
            return group.display;
          case src_Style.TEXT.size:
            return group.text;
          case src_Style.SCRIPT.size:
            return group.script;
          case src_Style.SCRIPTSCRIPT.size:
            return group.scriptscript;
          default:
            return group.text;
        }
      };
      defineFunction({
        type: "mathchoice",
        names: ["\\mathchoice"],
        props: {
          numArgs: 4,
          primitive: true
        },
        handler: (_ref, args) => {
          let {
            parser
          } = _ref;
          return {
            type: "mathchoice",
            mode: parser.mode,
            display: ordargument(args[0]),
            text: ordargument(args[1]),
            script: ordargument(args[2]),
            scriptscript: ordargument(args[3])
          };
        },
        htmlBuilder: (group, options) => {
          const body = chooseMathStyle(group, options);
          const elements = buildExpression(body, options, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: (group, options) => {
          const body = chooseMathStyle(group, options);
          return buildExpressionRow(body, options);
        }
      });
      const assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {
        base = buildCommon.makeSpan([], [base]);
        const subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
        let sub2;
        let sup2;
        if (supGroup) {
          const elem = buildGroup(supGroup, options.havingStyle(style.sup()), options);
          sup2 = {
            elem,
            kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
          };
        }
        if (subGroup) {
          const elem = buildGroup(subGroup, options.havingStyle(style.sub()), options);
          sub2 = {
            elem,
            kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - elem.height)
          };
        }
        let finalGroup;
        if (sup2 && sub2) {
          const bottom = options.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: bottom,
            children: [{
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub2.elem,
              marginLeft: makeEm(-slant)
            }, {
              type: "kern",
              size: sub2.kern
            }, {
              type: "elem",
              elem: base
            }, {
              type: "kern",
              size: sup2.kern
            }, {
              type: "elem",
              elem: sup2.elem,
              marginLeft: makeEm(slant)
            }, {
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }]
          }, options);
        } else if (sub2) {
          const top = base.height - baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "top",
            positionData: top,
            children: [{
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub2.elem,
              marginLeft: makeEm(-slant)
            }, {
              type: "kern",
              size: sub2.kern
            }, {
              type: "elem",
              elem: base
            }]
          }, options);
        } else if (sup2) {
          const bottom = base.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: bottom,
            children: [{
              type: "elem",
              elem: base
            }, {
              type: "kern",
              size: sup2.kern
            }, {
              type: "elem",
              elem: sup2.elem,
              marginLeft: makeEm(slant)
            }, {
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }]
          }, options);
        } else {
          return base;
        }
        const parts = [finalGroup];
        if (sub2 && slant !== 0 && !subIsSingleCharacter) {
          const spacer = buildCommon.makeSpan(["mspace"], [], options);
          spacer.style.marginRight = makeEm(slant);
          parts.unshift(spacer);
        }
        return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
      };
      const noSuccessor = ["\\smallint"];
      const op_htmlBuilder = (grp, options) => {
        let supGroup;
        let subGroup;
        let hasLimits = false;
        let group;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group = assertNodeType(grp.base, "op");
          hasLimits = true;
        } else {
          group = assertNodeType(grp, "op");
        }
        const style = options.style;
        let large = false;
        if (style.size === src_Style.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
          large = true;
        }
        let base;
        if (group.symbol) {
          const fontName = large ? "Size2-Regular" : "Size1-Regular";
          let stash = "";
          if (group.name === "\\oiint" || group.name === "\\oiiint") {
            stash = group.name.slice(1);
            group.name = stash === "oiint" ? "\\iint" : "\\iiint";
          }
          base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
          if (stash.length > 0) {
            const italic = base.italic;
            const oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
            base = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: base,
                shift: 0
              }, {
                type: "elem",
                elem: oval,
                shift: large ? 0.08 : 0
              }]
            }, options);
            group.name = "\\" + stash;
            base.classes.unshift("mop");
            base.italic = italic;
          }
        } else if (group.body) {
          const inner2 = buildExpression(group.body, options, true);
          if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
            base = inner2[0];
            base.classes[0] = "mop";
          } else {
            base = buildCommon.makeSpan(["mop"], inner2, options);
          }
        } else {
          const output = [];
          for (let i = 1;i < group.name.length; i++) {
            output.push(buildCommon.mathsym(group.name[i], group.mode, options));
          }
          base = buildCommon.makeSpan(["mop"], output, options);
        }
        let baseShift = 0;
        let slant = 0;
        if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
          baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight;
          slant = base.italic;
        }
        if (hasLimits) {
          return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);
        } else {
          if (baseShift) {
            base.style.position = "relative";
            base.style.top = makeEm(baseShift);
          }
          return base;
        }
      };
      const op_mathmlBuilder = (group, options) => {
        let node;
        if (group.symbol) {
          node = new MathNode("mo", [makeText(group.name, group.mode)]);
          if (utils.contains(noSuccessor, group.name)) {
            node.setAttribute("largeop", "false");
          }
        } else if (group.body) {
          node = new MathNode("mo", buildMathML_buildExpression(group.body, options));
        } else {
          node = new MathNode("mi", [new TextNode(group.name.slice(1))]);
          const operator = new MathNode("mo", [makeText("⁡", "text")]);
          if (group.parentIsSupSub) {
            node = new MathNode("mrow", [node, operator]);
          } else {
            node = newDocumentFragment([node, operator]);
          }
        }
        return node;
      };
      const singleCharBigOps = {
        "∏": "\\prod",
        "∐": "\\coprod",
        "∑": "\\sum",
        "⋀": "\\bigwedge",
        "⋁": "\\bigvee",
        "⋂": "\\bigcap",
        "⋃": "\\bigcup",
        "⨀": "\\bigodot",
        "⨁": "\\bigoplus",
        "⨂": "\\bigotimes",
        "⨄": "\\biguplus",
        "⨆": "\\bigsqcup"
      };
      defineFunction({
        type: "op",
        names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
        props: {
          numArgs: 0
        },
        handler: (_ref, args) => {
          let {
            parser,
            funcName
          } = _ref;
          let fName = funcName;
          if (fName.length === 1) {
            fName = singleCharBigOps[fName];
          }
          return {
            type: "op",
            mode: parser.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      defineFunction({
        type: "op",
        names: ["\\mathop"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: (_ref2, args) => {
          let {
            parser
          } = _ref2;
          const body = args[0];
          return {
            type: "op",
            mode: parser.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            body: ordargument(body)
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      const singleCharIntegrals = {
        "∫": "\\int",
        "∬": "\\iint",
        "∭": "\\iiint",
        "∮": "\\oint",
        "∯": "\\oiint",
        "∰": "\\oiiint"
      };
      defineFunction({
        type: "op",
        names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
        props: {
          numArgs: 0
        },
        handler(_ref3) {
          let {
            parser,
            funcName
          } = _ref3;
          return {
            type: "op",
            mode: parser.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      defineFunction({
        type: "op",
        names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
        props: {
          numArgs: 0
        },
        handler(_ref4) {
          let {
            parser,
            funcName
          } = _ref4;
          return {
            type: "op",
            mode: parser.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      defineFunction({
        type: "op",
        names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
        props: {
          numArgs: 0
        },
        handler(_ref5) {
          let {
            parser,
            funcName
          } = _ref5;
          let fName = funcName;
          if (fName.length === 1) {
            fName = singleCharIntegrals[fName];
          }
          return {
            type: "op",
            mode: parser.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      const operatorname_htmlBuilder = (grp, options) => {
        let supGroup;
        let subGroup;
        let hasLimits = false;
        let group;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group = assertNodeType(grp.base, "operatorname");
          hasLimits = true;
        } else {
          group = assertNodeType(grp, "operatorname");
        }
        let base;
        if (group.body.length > 0) {
          const body = group.body.map((child) => {
            const childText = child.text;
            if (typeof childText === "string") {
              return {
                type: "textord",
                mode: child.mode,
                text: childText
              };
            } else {
              return child;
            }
          });
          const expression = buildExpression(body, options.withFont("mathrm"), true);
          for (let i = 0;i < expression.length; i++) {
            const child = expression[i];
            if (child instanceof SymbolNode) {
              child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
            }
          }
          base = buildCommon.makeSpan(["mop"], expression, options);
        } else {
          base = buildCommon.makeSpan(["mop"], [], options);
        }
        if (hasLimits) {
          return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
        } else {
          return base;
        }
      };
      const operatorname_mathmlBuilder = (group, options) => {
        let expression = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
        let isAllString = true;
        for (let i = 0;i < expression.length; i++) {
          const node = expression[i];
          if (node instanceof mathMLTree.SpaceNode) {
          } else if (node instanceof mathMLTree.MathNode) {
            switch (node.type) {
              case "mi":
              case "mn":
              case "ms":
              case "mspace":
              case "mtext":
                break;
              case "mo": {
                const child = node.children[0];
                if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                  child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                } else {
                  isAllString = false;
                }
                break;
              }
              default:
                isAllString = false;
            }
          } else {
            isAllString = false;
          }
        }
        if (isAllString) {
          const word = expression.map((node) => node.toText()).join("");
          expression = [new mathMLTree.TextNode(word)];
        }
        const identifier = new mathMLTree.MathNode("mi", expression);
        identifier.setAttribute("mathvariant", "normal");
        const operator = new mathMLTree.MathNode("mo", [makeText("⁡", "text")]);
        if (group.parentIsSupSub) {
          return new mathMLTree.MathNode("mrow", [identifier, operator]);
        } else {
          return mathMLTree.newDocumentFragment([identifier, operator]);
        }
      };
      defineFunction({
        type: "operatorname",
        names: ["\\operatorname@", "\\operatornamewithlimits"],
        props: {
          numArgs: 1
        },
        handler: (_ref, args) => {
          let {
            parser,
            funcName
          } = _ref;
          const body = args[0];
          return {
            type: "operatorname",
            mode: parser.mode,
            body: ordargument(body),
            alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
            limits: false,
            parentIsSupSub: false
          };
        },
        htmlBuilder: operatorname_htmlBuilder,
        mathmlBuilder: operatorname_mathmlBuilder
      });
      defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
      defineFunctionBuilders({
        type: "ordgroup",
        htmlBuilder(group, options) {
          if (group.semisimple) {
            return buildCommon.makeFragment(buildExpression(group.body, options, false));
          }
          return buildCommon.makeSpan(["mord"], buildExpression(group.body, options, true), options);
        },
        mathmlBuilder(group, options) {
          return buildExpressionRow(group.body, options, true);
        }
      });
      defineFunction({
        type: "overline",
        names: ["\\overline"],
        props: {
          numArgs: 1
        },
        handler(_ref, args) {
          let {
            parser
          } = _ref;
          const body = args[0];
          return {
            type: "overline",
            mode: parser.mode,
            body
          };
        },
        htmlBuilder(group, options) {
          const innerGroup = buildGroup(group.body, options.havingCrampedStyle());
          const line = buildCommon.makeLineSpan("overline-line", options);
          const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
          const vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: innerGroup
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: line
            }, {
              type: "kern",
              size: defaultRuleThickness
            }]
          }, options);
          return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
        },
        mathmlBuilder(group, options) {
          const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
          operator.setAttribute("stretchy", "true");
          const node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
          node.setAttribute("accent", "true");
          return node;
        }
      });
      defineFunction({
        type: "phantom",
        names: ["\\phantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: (_ref, args) => {
          let {
            parser
          } = _ref;
          const body = args[0];
          return {
            type: "phantom",
            mode: parser.mode,
            body: ordargument(body)
          };
        },
        htmlBuilder: (group, options) => {
          const elements = buildExpression(group.body, options.withPhantom(), false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: (group, options) => {
          const inner2 = buildMathML_buildExpression(group.body, options);
          return new mathMLTree.MathNode("mphantom", inner2);
        }
      });
      defineFunction({
        type: "hphantom",
        names: ["\\hphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: (_ref2, args) => {
          let {
            parser
          } = _ref2;
          const body = args[0];
          return {
            type: "hphantom",
            mode: parser.mode,
            body
          };
        },
        htmlBuilder: (group, options) => {
          let node = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);
          node.height = 0;
          node.depth = 0;
          if (node.children) {
            for (let i = 0;i < node.children.length; i++) {
              node.children[i].height = 0;
              node.children[i].depth = 0;
            }
          }
          node = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node
            }]
          }, options);
          return buildCommon.makeSpan(["mord"], [node], options);
        },
        mathmlBuilder: (group, options) => {
          const inner2 = buildMathML_buildExpression(ordargument(group.body), options);
          const phantom = new mathMLTree.MathNode("mphantom", inner2);
          const node = new mathMLTree.MathNode("mpadded", [phantom]);
          node.setAttribute("height", "0px");
          node.setAttribute("depth", "0px");
          return node;
        }
      });
      defineFunction({
        type: "vphantom",
        names: ["\\vphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: (_ref3, args) => {
          let {
            parser
          } = _ref3;
          const body = args[0];
          return {
            type: "vphantom",
            mode: parser.mode,
            body
          };
        },
        htmlBuilder: (group, options) => {
          const inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options.withPhantom())]);
          const fix = buildCommon.makeSpan(["fix"], []);
          return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
        },
        mathmlBuilder: (group, options) => {
          const inner2 = buildMathML_buildExpression(ordargument(group.body), options);
          const phantom = new mathMLTree.MathNode("mphantom", inner2);
          const node = new mathMLTree.MathNode("mpadded", [phantom]);
          node.setAttribute("width", "0px");
          return node;
        }
      });
      defineFunction({
        type: "raisebox",
        names: ["\\raisebox"],
        props: {
          numArgs: 2,
          argTypes: ["size", "hbox"],
          allowedInText: true
        },
        handler(_ref, args) {
          let {
            parser
          } = _ref;
          const amount = assertNodeType(args[0], "size").value;
          const body = args[1];
          return {
            type: "raisebox",
            mode: parser.mode,
            dy: amount,
            body
          };
        },
        htmlBuilder(group, options) {
          const body = buildGroup(group.body, options);
          const dy = calculateSize(group.dy, options);
          return buildCommon.makeVList({
            positionType: "shift",
            positionData: -dy,
            children: [{
              type: "elem",
              elem: body
            }]
          }, options);
        },
        mathmlBuilder(group, options) {
          const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
          const dy = group.dy.number + group.dy.unit;
          node.setAttribute("voffset", dy);
          return node;
        }
      });
      defineFunction({
        type: "internal",
        names: ["\\relax"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler(_ref) {
          let {
            parser
          } = _ref;
          return {
            type: "internal",
            mode: parser.mode
          };
        }
      });
      defineFunction({
        type: "rule",
        names: ["\\rule"],
        props: {
          numArgs: 2,
          numOptionalArgs: 1,
          allowedInText: true,
          allowedInMath: true,
          argTypes: ["size", "size", "size"]
        },
        handler(_ref, args, optArgs) {
          let {
            parser
          } = _ref;
          const shift = optArgs[0];
          const width = assertNodeType(args[0], "size");
          const height = assertNodeType(args[1], "size");
          return {
            type: "rule",
            mode: parser.mode,
            shift: shift && assertNodeType(shift, "size").value,
            width: width.value,
            height: height.value
          };
        },
        htmlBuilder(group, options) {
          const rule = buildCommon.makeSpan(["mord", "rule"], [], options);
          const width = calculateSize(group.width, options);
          const height = calculateSize(group.height, options);
          const shift = group.shift ? calculateSize(group.shift, options) : 0;
          rule.style.borderRightWidth = makeEm(width);
          rule.style.borderTopWidth = makeEm(height);
          rule.style.bottom = makeEm(shift);
          rule.width = width;
          rule.height = height + shift;
          rule.depth = -shift;
          rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
          return rule;
        },
        mathmlBuilder(group, options) {
          const width = calculateSize(group.width, options);
          const height = calculateSize(group.height, options);
          const shift = group.shift ? calculateSize(group.shift, options) : 0;
          const color = options.color && options.getColor() || "black";
          const rule = new mathMLTree.MathNode("mspace");
          rule.setAttribute("mathbackground", color);
          rule.setAttribute("width", makeEm(width));
          rule.setAttribute("height", makeEm(height));
          const wrapper = new mathMLTree.MathNode("mpadded", [rule]);
          if (shift >= 0) {
            wrapper.setAttribute("height", makeEm(shift));
          } else {
            wrapper.setAttribute("height", makeEm(shift));
            wrapper.setAttribute("depth", makeEm(-shift));
          }
          wrapper.setAttribute("voffset", makeEm(shift));
          return wrapper;
        }
      });
      function sizingGroup(value, options, baseOptions) {
        const inner2 = buildExpression(value, options, false);
        const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
        for (let i = 0;i < inner2.length; i++) {
          const pos = inner2[i].classes.indexOf("sizing");
          if (pos < 0) {
            Array.prototype.push.apply(inner2[i].classes, options.sizingClasses(baseOptions));
          } else if (inner2[i].classes[pos + 1] === "reset-size" + options.size) {
            inner2[i].classes[pos + 1] = "reset-size" + baseOptions.size;
          }
          inner2[i].height *= multiplier;
          inner2[i].depth *= multiplier;
        }
        return buildCommon.makeFragment(inner2);
      }
      const sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
      const sizing_htmlBuilder = (group, options) => {
        const newOptions = options.havingSize(group.size);
        return sizingGroup(group.body, newOptions, options);
      };
      defineFunction({
        type: "sizing",
        names: sizeFuncs,
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: (_ref, args) => {
          let {
            breakOnTokenText,
            funcName,
            parser
          } = _ref;
          const body = parser.parseExpression(false, breakOnTokenText);
          return {
            type: "sizing",
            mode: parser.mode,
            size: sizeFuncs.indexOf(funcName) + 1,
            body
          };
        },
        htmlBuilder: sizing_htmlBuilder,
        mathmlBuilder: (group, options) => {
          const newOptions = options.havingSize(group.size);
          const inner2 = buildMathML_buildExpression(group.body, newOptions);
          const node = new mathMLTree.MathNode("mstyle", inner2);
          node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
          return node;
        }
      });
      defineFunction({
        type: "smash",
        names: ["\\smash"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          allowedInText: true
        },
        handler: (_ref, args, optArgs) => {
          let {
            parser
          } = _ref;
          let smashHeight = false;
          let smashDepth = false;
          const tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
          if (tbArg) {
            let letter = "";
            for (let i = 0;i < tbArg.body.length; ++i) {
              const node = tbArg.body[i];
              letter = node.text;
              if (letter === "t") {
                smashHeight = true;
              } else if (letter === "b") {
                smashDepth = true;
              } else {
                smashHeight = false;
                smashDepth = false;
                break;
              }
            }
          } else {
            smashHeight = true;
            smashDepth = true;
          }
          const body = args[0];
          return {
            type: "smash",
            mode: parser.mode,
            body,
            smashHeight,
            smashDepth
          };
        },
        htmlBuilder: (group, options) => {
          const node = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
          if (!group.smashHeight && !group.smashDepth) {
            return node;
          }
          if (group.smashHeight) {
            node.height = 0;
            if (node.children) {
              for (let i = 0;i < node.children.length; i++) {
                node.children[i].height = 0;
              }
            }
          }
          if (group.smashDepth) {
            node.depth = 0;
            if (node.children) {
              for (let i = 0;i < node.children.length; i++) {
                node.children[i].depth = 0;
              }
            }
          }
          const smashedNode = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node
            }]
          }, options);
          return buildCommon.makeSpan(["mord"], [smashedNode], options);
        },
        mathmlBuilder: (group, options) => {
          const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
          if (group.smashHeight) {
            node.setAttribute("height", "0px");
          }
          if (group.smashDepth) {
            node.setAttribute("depth", "0px");
          }
          return node;
        }
      });
      defineFunction({
        type: "sqrt",
        names: ["\\sqrt"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler(_ref, args, optArgs) {
          let {
            parser
          } = _ref;
          const index = optArgs[0];
          const body = args[0];
          return {
            type: "sqrt",
            mode: parser.mode,
            body,
            index
          };
        },
        htmlBuilder(group, options) {
          let inner2 = buildGroup(group.body, options.havingCrampedStyle());
          if (inner2.height === 0) {
            inner2.height = options.fontMetrics().xHeight;
          }
          inner2 = buildCommon.wrapFragment(inner2, options);
          const metrics = options.fontMetrics();
          const theta = metrics.defaultRuleThickness;
          let phi = theta;
          if (options.style.id < src_Style.TEXT.id) {
            phi = options.fontMetrics().xHeight;
          }
          let lineClearance = theta + phi / 4;
          const minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
          const {
            span: img,
            ruleWidth,
            advanceWidth
          } = delimiter.sqrtImage(minDelimiterHeight, options);
          const delimDepth = img.height - ruleWidth;
          if (delimDepth > inner2.height + inner2.depth + lineClearance) {
            lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
          }
          const imgShift = img.height - inner2.height - lineClearance - ruleWidth;
          inner2.style.paddingLeft = makeEm(advanceWidth);
          const body = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: inner2,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: -(inner2.height + imgShift)
            }, {
              type: "elem",
              elem: img
            }, {
              type: "kern",
              size: ruleWidth
            }]
          }, options);
          if (!group.index) {
            return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
          } else {
            const newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
            const rootm = buildGroup(group.index, newOptions, options);
            const toShift = 0.6 * (body.height - body.depth);
            const rootVList = buildCommon.makeVList({
              positionType: "shift",
              positionData: -toShift,
              children: [{
                type: "elem",
                elem: rootm
              }]
            }, options);
            const rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
            return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
          }
        },
        mathmlBuilder(group, options) {
          const {
            body,
            index
          } = group;
          return index ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
        }
      });
      const styling_styleMap = {
        display: src_Style.DISPLAY,
        text: src_Style.TEXT,
        script: src_Style.SCRIPT,
        scriptscript: src_Style.SCRIPTSCRIPT
      };
      defineFunction({
        type: "styling",
        names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref, args) {
          let {
            breakOnTokenText,
            funcName,
            parser
          } = _ref;
          const body = parser.parseExpression(true, breakOnTokenText);
          const style = funcName.slice(1, funcName.length - 5);
          return {
            type: "styling",
            mode: parser.mode,
            style,
            body
          };
        },
        htmlBuilder(group, options) {
          const newStyle = styling_styleMap[group.style];
          const newOptions = options.havingStyle(newStyle).withFont("");
          return sizingGroup(group.body, newOptions, options);
        },
        mathmlBuilder(group, options) {
          const newStyle = styling_styleMap[group.style];
          const newOptions = options.havingStyle(newStyle);
          const inner2 = buildMathML_buildExpression(group.body, newOptions);
          const node = new mathMLTree.MathNode("mstyle", inner2);
          const styleAttributes = {
            display: ["0", "true"],
            text: ["0", "false"],
            script: ["1", "false"],
            scriptscript: ["2", "false"]
          };
          const attr = styleAttributes[group.style];
          node.setAttribute("scriptlevel", attr[0]);
          node.setAttribute("displaystyle", attr[1]);
          return node;
        }
      });
      const htmlBuilderDelegate = function(group, options) {
        const base = group.base;
        if (!base) {
          return null;
        } else if (base.type === "op") {
          const delegate = base.limits && (options.style.size === src_Style.DISPLAY.size || base.alwaysHandleSupSub);
          return delegate ? op_htmlBuilder : null;
        } else if (base.type === "operatorname") {
          const delegate = base.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base.limits);
          return delegate ? operatorname_htmlBuilder : null;
        } else if (base.type === "accent") {
          return utils.isCharacterBox(base.base) ? htmlBuilder : null;
        } else if (base.type === "horizBrace") {
          const isSup = !group.sub;
          return isSup === base.isOver ? horizBrace_htmlBuilder : null;
        } else {
          return null;
        }
      };
      defineFunctionBuilders({
        type: "supsub",
        htmlBuilder(group, options) {
          const builderDelegate = htmlBuilderDelegate(group, options);
          if (builderDelegate) {
            return builderDelegate(group, options);
          }
          const {
            base: valueBase,
            sup: valueSup,
            sub: valueSub
          } = group;
          const base = buildGroup(valueBase, options);
          let supm;
          let subm;
          const metrics = options.fontMetrics();
          let supShift = 0;
          let subShift = 0;
          const isCharacterBox2 = valueBase && utils.isCharacterBox(valueBase);
          if (valueSup) {
            const newOptions = options.havingStyle(options.style.sup());
            supm = buildGroup(valueSup, newOptions, options);
            if (!isCharacterBox2) {
              supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
            }
          }
          if (valueSub) {
            const newOptions = options.havingStyle(options.style.sub());
            subm = buildGroup(valueSub, newOptions, options);
            if (!isCharacterBox2) {
              subShift = base.depth + newOptions.fontMetrics().subDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
            }
          }
          let minSupShift;
          if (options.style === src_Style.DISPLAY) {
            minSupShift = metrics.sup1;
          } else if (options.style.cramped) {
            minSupShift = metrics.sup3;
          } else {
            minSupShift = metrics.sup2;
          }
          const multiplier = options.sizeMultiplier;
          const marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
          let marginLeft = null;
          if (subm) {
            const isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
            if (base instanceof SymbolNode || isOiint) {
              marginLeft = makeEm(-base.italic);
            }
          }
          let supsub;
          if (supm && subm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            subShift = Math.max(subShift, metrics.sub2);
            const ruleWidth = metrics.defaultRuleThickness;
            const maxWidth = 4 * ruleWidth;
            if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
              subShift = maxWidth - (supShift - supm.depth) + subm.height;
              const psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
              if (psi > 0) {
                supShift += psi;
                subShift -= psi;
              }
            }
            const vlistElem = [{
              type: "elem",
              elem: subm,
              shift: subShift,
              marginRight,
              marginLeft
            }, {
              type: "elem",
              elem: supm,
              shift: -supShift,
              marginRight
            }];
            supsub = buildCommon.makeVList({
              positionType: "individualShift",
              children: vlistElem
            }, options);
          } else if (subm) {
            subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
            const vlistElem = [{
              type: "elem",
              elem: subm,
              marginLeft,
              marginRight
            }];
            supsub = buildCommon.makeVList({
              positionType: "shift",
              positionData: subShift,
              children: vlistElem
            }, options);
          } else if (supm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            supsub = buildCommon.makeVList({
              positionType: "shift",
              positionData: -supShift,
              children: [{
                type: "elem",
                elem: supm,
                marginRight
              }]
            }, options);
          } else {
            throw new Error("supsub must have either sup or sub.");
          }
          const mclass = getTypeOfDomTree(base, "right") || "mord";
          return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
        },
        mathmlBuilder(group, options) {
          let isBrace = false;
          let isOver;
          let isSup;
          if (group.base && group.base.type === "horizBrace") {
            isSup = !!group.sup;
            if (isSup === group.base.isOver) {
              isBrace = true;
              isOver = group.base.isOver;
            }
          }
          if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
            group.base.parentIsSupSub = true;
          }
          const children = [buildMathML_buildGroup(group.base, options)];
          if (group.sub) {
            children.push(buildMathML_buildGroup(group.sub, options));
          }
          if (group.sup) {
            children.push(buildMathML_buildGroup(group.sup, options));
          }
          let nodeType;
          if (isBrace) {
            nodeType = isOver ? "mover" : "munder";
          } else if (!group.sub) {
            const base = group.base;
            if (base && base.type === "op" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {
              nodeType = "mover";
            } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === src_Style.DISPLAY)) {
              nodeType = "mover";
            } else {
              nodeType = "msup";
            }
          } else if (!group.sup) {
            const base = group.base;
            if (base && base.type === "op" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {
              nodeType = "munder";
            } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === src_Style.DISPLAY)) {
              nodeType = "munder";
            } else {
              nodeType = "msub";
            }
          } else {
            const base = group.base;
            if (base && base.type === "op" && base.limits && options.style === src_Style.DISPLAY) {
              nodeType = "munderover";
            } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || base.limits)) {
              nodeType = "munderover";
            } else {
              nodeType = "msubsup";
            }
          }
          return new mathMLTree.MathNode(nodeType, children);
        }
      });
      defineFunctionBuilders({
        type: "atom",
        htmlBuilder(group, options) {
          return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
        },
        mathmlBuilder(group, options) {
          const node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
          if (group.family === "bin") {
            const variant = getVariant(group, options);
            if (variant === "bold-italic") {
              node.setAttribute("mathvariant", variant);
            }
          } else if (group.family === "punct") {
            node.setAttribute("separator", "true");
          } else if (group.family === "open" || group.family === "close") {
            node.setAttribute("stretchy", "false");
          }
          return node;
        }
      });
      const defaultVariant = {
        mi: "italic",
        mn: "normal",
        mtext: "normal"
      };
      defineFunctionBuilders({
        type: "mathord",
        htmlBuilder(group, options) {
          return buildCommon.makeOrd(group, options, "mathord");
        },
        mathmlBuilder(group, options) {
          const node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
          const variant = getVariant(group, options) || "italic";
          if (variant !== defaultVariant[node.type]) {
            node.setAttribute("mathvariant", variant);
          }
          return node;
        }
      });
      defineFunctionBuilders({
        type: "textord",
        htmlBuilder(group, options) {
          return buildCommon.makeOrd(group, options, "textord");
        },
        mathmlBuilder(group, options) {
          const text = makeText(group.text, group.mode, options);
          const variant = getVariant(group, options) || "normal";
          let node;
          if (group.mode === "text") {
            node = new mathMLTree.MathNode("mtext", [text]);
          } else if (/[0-9]/.test(group.text)) {
            node = new mathMLTree.MathNode("mn", [text]);
          } else if (group.text === "\\prime") {
            node = new mathMLTree.MathNode("mo", [text]);
          } else {
            node = new mathMLTree.MathNode("mi", [text]);
          }
          if (variant !== defaultVariant[node.type]) {
            node.setAttribute("mathvariant", variant);
          }
          return node;
        }
      });
      const cssSpace = {
        "\\nobreak": "nobreak",
        "\\allowbreak": "allowbreak"
      };
      const regularSpace = {
        " ": {},
        "\\ ": {},
        "~": {
          className: "nobreak"
        },
        "\\space": {},
        "\\nobreakspace": {
          className: "nobreak"
        }
      };
      defineFunctionBuilders({
        type: "spacing",
        htmlBuilder(group, options) {
          if (regularSpace.hasOwnProperty(group.text)) {
            const className = regularSpace[group.text].className || "";
            if (group.mode === "text") {
              const ord = buildCommon.makeOrd(group, options, "textord");
              ord.classes.push(className);
              return ord;
            } else {
              return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
            }
          } else if (cssSpace.hasOwnProperty(group.text)) {
            return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
          } else {
            throw new src_ParseError('Unknown type of space "' + group.text + '"');
          }
        },
        mathmlBuilder(group, options) {
          let node;
          if (regularSpace.hasOwnProperty(group.text)) {
            node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode(" ")]);
          } else if (cssSpace.hasOwnProperty(group.text)) {
            return new mathMLTree.MathNode("mspace");
          } else {
            throw new src_ParseError('Unknown type of space "' + group.text + '"');
          }
          return node;
        }
      });
      const pad = () => {
        const padNode = new mathMLTree.MathNode("mtd", []);
        padNode.setAttribute("width", "50%");
        return padNode;
      };
      defineFunctionBuilders({
        type: "tag",
        mathmlBuilder(group, options) {
          const table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
          table.setAttribute("width", "100%");
          return table;
        }
      });
      const textFontFamilies = {
        "\\text": undefined,
        "\\textrm": "textrm",
        "\\textsf": "textsf",
        "\\texttt": "texttt",
        "\\textnormal": "textrm"
      };
      const textFontWeights = {
        "\\textbf": "textbf",
        "\\textmd": "textmd"
      };
      const textFontShapes = {
        "\\textit": "textit",
        "\\textup": "textup"
      };
      const optionsWithFont = (group, options) => {
        const font = group.font;
        if (!font) {
          return options;
        } else if (textFontFamilies[font]) {
          return options.withTextFontFamily(textFontFamilies[font]);
        } else if (textFontWeights[font]) {
          return options.withTextFontWeight(textFontWeights[font]);
        } else if (font === "\\emph") {
          return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
        }
        return options.withTextFontShape(textFontShapes[font]);
      };
      defineFunction({
        type: "text",
        names: [
          "\\text",
          "\\textrm",
          "\\textsf",
          "\\texttt",
          "\\textnormal",
          "\\textbf",
          "\\textmd",
          "\\textit",
          "\\textup",
          "\\emph"
        ],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInArgument: true,
          allowedInText: true
        },
        handler(_ref, args) {
          let {
            parser,
            funcName
          } = _ref;
          const body = args[0];
          return {
            type: "text",
            mode: parser.mode,
            body: ordargument(body),
            font: funcName
          };
        },
        htmlBuilder(group, options) {
          const newOptions = optionsWithFont(group, options);
          const inner2 = buildExpression(group.body, newOptions, true);
          return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
        },
        mathmlBuilder(group, options) {
          const newOptions = optionsWithFont(group, options);
          return buildExpressionRow(group.body, newOptions);
        }
      });
      defineFunction({
        type: "underline",
        names: ["\\underline"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler(_ref, args) {
          let {
            parser
          } = _ref;
          return {
            type: "underline",
            mode: parser.mode,
            body: args[0]
          };
        },
        htmlBuilder(group, options) {
          const innerGroup = buildGroup(group.body, options);
          const line = buildCommon.makeLineSpan("underline-line", options);
          const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
          const vlist = buildCommon.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "kern",
              size: defaultRuleThickness
            }, {
              type: "elem",
              elem: line
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options);
          return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
        },
        mathmlBuilder(group, options) {
          const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
          operator.setAttribute("stretchy", "true");
          const node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
          node.setAttribute("accentunder", "true");
          return node;
        }
      });
      defineFunction({
        type: "vcenter",
        names: ["\\vcenter"],
        props: {
          numArgs: 1,
          argTypes: ["original"],
          allowedInText: false
        },
        handler(_ref, args) {
          let {
            parser
          } = _ref;
          return {
            type: "vcenter",
            mode: parser.mode,
            body: args[0]
          };
        },
        htmlBuilder(group, options) {
          const body = buildGroup(group.body, options);
          const axisHeight = options.fontMetrics().axisHeight;
          const dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
          return buildCommon.makeVList({
            positionType: "shift",
            positionData: dy,
            children: [{
              type: "elem",
              elem: body
            }]
          }, options);
        },
        mathmlBuilder(group, options) {
          return new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)], ["vcenter"]);
        }
      });
      defineFunction({
        type: "verb",
        names: ["\\verb"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler(context, args, optArgs) {
          throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
        },
        htmlBuilder(group, options) {
          const text = makeVerb(group);
          const body = [];
          const newOptions = options.havingStyle(options.style.text());
          for (let i = 0;i < text.length; i++) {
            let c4 = text[i];
            if (c4 === "~") {
              c4 = "\\textasciitilde";
            }
            body.push(buildCommon.makeSymbol(c4, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
          }
          return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
        },
        mathmlBuilder(group, options) {
          const text = new mathMLTree.TextNode(makeVerb(group));
          const node = new mathMLTree.MathNode("mtext", [text]);
          node.setAttribute("mathvariant", "monospace");
          return node;
        }
      });
      const makeVerb = (group) => group.body.replace(/ /g, group.star ? "␣" : " ");
      const functions = _functions;
      var src_functions = functions;
      const spaceRegexString = `[ \r
\t]`;
      const controlWordRegexString = "\\\\[a-zA-Z@]+";
      const controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
      const controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
      const controlSpaceRegexString = `\\\\(
|[ \r\t]+
?)[ \r\t]*`;
      const combiningDiacriticalMarkString = "[̀-ͯ]";
      const combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
      const tokenRegexString = "(" + spaceRegexString + "+)|" + (controlSpaceRegexString + "|") + "([!-\\[\\]-‧‪-퟿豈-￿]" + (combiningDiacriticalMarkString + "*") + "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + (combiningDiacriticalMarkString + "*") + "|\\\\verb\\*([^]).*?\\4" + "|\\\\verb([^*a-zA-Z]).*?\\5" + ("|" + controlWordWhitespaceRegexString) + ("|" + controlSymbolRegexString + ")");

      class Lexer {
        constructor(input, settings) {
          this.input = undefined;
          this.settings = undefined;
          this.tokenRegex = undefined;
          this.catcodes = undefined;
          this.input = input;
          this.settings = settings;
          this.tokenRegex = new RegExp(tokenRegexString, "g");
          this.catcodes = {
            "%": 14,
            "~": 13
          };
        }
        setCatcode(char, code) {
          this.catcodes[char] = code;
        }
        lex() {
          const input = this.input;
          const pos = this.tokenRegex.lastIndex;
          if (pos === input.length) {
            return new Token("EOF", new SourceLocation(this, pos, pos));
          }
          const match = this.tokenRegex.exec(input);
          if (match === null || match.index !== pos) {
            throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
          }
          const text = match[6] || match[3] || (match[2] ? "\\ " : " ");
          if (this.catcodes[text] === 14) {
            const nlIndex = input.indexOf(`
`, this.tokenRegex.lastIndex);
            if (nlIndex === -1) {
              this.tokenRegex.lastIndex = input.length;
              this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would " + "fail because of commenting the end of math mode (e.g. $)");
            } else {
              this.tokenRegex.lastIndex = nlIndex + 1;
            }
            return this.lex();
          }
          return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
        }
      }

      class Namespace {
        constructor(builtins, globalMacros) {
          if (builtins === undefined) {
            builtins = {};
          }
          if (globalMacros === undefined) {
            globalMacros = {};
          }
          this.current = undefined;
          this.builtins = undefined;
          this.undefStack = undefined;
          this.current = globalMacros;
          this.builtins = builtins;
          this.undefStack = [];
        }
        beginGroup() {
          this.undefStack.push({});
        }
        endGroup() {
          if (this.undefStack.length === 0) {
            throw new src_ParseError("Unbalanced namespace destruction: attempt " + "to pop global namespace; please report this as a bug");
          }
          const undefs = this.undefStack.pop();
          for (const undef in undefs) {
            if (undefs.hasOwnProperty(undef)) {
              if (undefs[undef] == null) {
                delete this.current[undef];
              } else {
                this.current[undef] = undefs[undef];
              }
            }
          }
        }
        endGroups() {
          while (this.undefStack.length > 0) {
            this.endGroup();
          }
        }
        has(name) {
          return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
        }
        get(name) {
          if (this.current.hasOwnProperty(name)) {
            return this.current[name];
          } else {
            return this.builtins[name];
          }
        }
        set(name, value, global2) {
          if (global2 === undefined) {
            global2 = false;
          }
          if (global2) {
            for (let i = 0;i < this.undefStack.length; i++) {
              delete this.undefStack[i][name];
            }
            if (this.undefStack.length > 0) {
              this.undefStack[this.undefStack.length - 1][name] = value;
            }
          } else {
            const top = this.undefStack[this.undefStack.length - 1];
            if (top && !top.hasOwnProperty(name)) {
              top[name] = this.current[name];
            }
          }
          if (value == null) {
            delete this.current[name];
          } else {
            this.current[name] = value;
          }
        }
      }
      const macros = _macros;
      var src_macros = macros;
      defineMacro("\\noexpand", function(context) {
        const t = context.popToken();
        if (context.isExpandable(t.text)) {
          t.noexpand = true;
          t.treatAsRelax = true;
        }
        return {
          tokens: [t],
          numArgs: 0
        };
      });
      defineMacro("\\expandafter", function(context) {
        const t = context.popToken();
        context.expandOnce(true);
        return {
          tokens: [t],
          numArgs: 0
        };
      });
      defineMacro("\\@firstoftwo", function(context) {
        const args = context.consumeArgs(2);
        return {
          tokens: args[0],
          numArgs: 0
        };
      });
      defineMacro("\\@secondoftwo", function(context) {
        const args = context.consumeArgs(2);
        return {
          tokens: args[1],
          numArgs: 0
        };
      });
      defineMacro("\\@ifnextchar", function(context) {
        const args = context.consumeArgs(3);
        context.consumeSpaces();
        const nextToken = context.future();
        if (args[0].length === 1 && args[0][0].text === nextToken.text) {
          return {
            tokens: args[1],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[2],
            numArgs: 0
          };
        }
      });
      defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
      defineMacro("\\TextOrMath", function(context) {
        const args = context.consumeArgs(2);
        if (context.mode === "text") {
          return {
            tokens: args[0],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[1],
            numArgs: 0
          };
        }
      });
      const digitToNumber = {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15
      };
      defineMacro("\\char", function(context) {
        let token = context.popToken();
        let base;
        let number = "";
        if (token.text === "'") {
          base = 8;
          token = context.popToken();
        } else if (token.text === '"') {
          base = 16;
          token = context.popToken();
        } else if (token.text === "`") {
          token = context.popToken();
          if (token.text[0] === "\\") {
            number = token.text.charCodeAt(1);
          } else if (token.text === "EOF") {
            throw new src_ParseError("\\char` missing argument");
          } else {
            number = token.text.charCodeAt(0);
          }
        } else {
          base = 10;
        }
        if (base) {
          number = digitToNumber[token.text];
          if (number == null || number >= base) {
            throw new src_ParseError("Invalid base-" + base + " digit " + token.text);
          }
          let digit;
          while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
            number *= base;
            number += digit;
            context.popToken();
          }
        }
        return "\\@char{" + number + "}";
      });
      const newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {
        let arg = context.consumeArg().tokens;
        if (arg.length !== 1) {
          throw new src_ParseError("\\newcommand's first argument must be a macro name");
        }
        const name = arg[0].text;
        const exists = context.isDefined(name);
        if (exists && !existsOK) {
          throw new src_ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
        }
        if (!exists && !nonexistsOK) {
          throw new src_ParseError("\\renewcommand{" + name + "} when command " + name + " " + "does not yet exist; use \\newcommand");
        }
        let numArgs = 0;
        arg = context.consumeArg().tokens;
        if (arg.length === 1 && arg[0].text === "[") {
          let argText = "";
          let token = context.expandNextToken();
          while (token.text !== "]" && token.text !== "EOF") {
            argText += token.text;
            token = context.expandNextToken();
          }
          if (!argText.match(/^\s*[0-9]+\s*$/)) {
            throw new src_ParseError("Invalid number of arguments: " + argText);
          }
          numArgs = parseInt(argText);
          arg = context.consumeArg().tokens;
        }
        if (!(exists && skipIfExists)) {
          context.macros.set(name, {
            tokens: arg,
            numArgs
          });
        }
        return "";
      };
      defineMacro("\\newcommand", (context) => newcommand(context, false, true, false));
      defineMacro("\\renewcommand", (context) => newcommand(context, true, false, false));
      defineMacro("\\providecommand", (context) => newcommand(context, true, true, true));
      defineMacro("\\message", (context) => {
        const arg = context.consumeArgs(1)[0];
        console.log(arg.reverse().map((token) => token.text).join(""));
        return "";
      });
      defineMacro("\\errmessage", (context) => {
        const arg = context.consumeArgs(1)[0];
        console.error(arg.reverse().map((token) => token.text).join(""));
        return "";
      });
      defineMacro("\\show", (context) => {
        const tok = context.popToken();
        const name = tok.text;
        console.log(tok, context.macros.get(name), src_functions[name], src_symbols.math[name], src_symbols.text[name]);
        return "";
      });
      defineMacro("\\bgroup", "{");
      defineMacro("\\egroup", "}");
      defineMacro("~", "\\nobreakspace");
      defineMacro("\\lq", "`");
      defineMacro("\\rq", "'");
      defineMacro("\\aa", "\\r a");
      defineMacro("\\AA", "\\r A");
      defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
      defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
      defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}");
      defineMacro("ℬ", "\\mathscr{B}");
      defineMacro("ℰ", "\\mathscr{E}");
      defineMacro("ℱ", "\\mathscr{F}");
      defineMacro("ℋ", "\\mathscr{H}");
      defineMacro("ℐ", "\\mathscr{I}");
      defineMacro("ℒ", "\\mathscr{L}");
      defineMacro("ℳ", "\\mathscr{M}");
      defineMacro("ℛ", "\\mathscr{R}");
      defineMacro("ℭ", "\\mathfrak{C}");
      defineMacro("ℌ", "\\mathfrak{H}");
      defineMacro("ℨ", "\\mathfrak{Z}");
      defineMacro("\\Bbbk", "\\Bbb{k}");
      defineMacro("·", "\\cdotp");
      defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
      defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
      defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
      defineMacro("\\mathstrut", "\\vphantom{(}");
      defineMacro("\\underbar", "\\underline{\\text{#1}}");
      defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
      defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
      defineMacro("\\ne", "\\neq");
      defineMacro("≠", "\\neq");
      defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}" + "{\\mathrel{\\char`∉}}");
      defineMacro("∉", "\\notin");
      defineMacro("≘", "\\html@mathml{" + "\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}" + "}{\\mathrel{\\char`≘}}");
      defineMacro("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}");
      defineMacro("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}");
      defineMacro("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}" + "{\\mathrel{\\char`≛}}");
      defineMacro("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}" + "{\\mathrel{\\char`≝}}");
      defineMacro("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}" + "{\\mathrel{\\char`≞}}");
      defineMacro("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}");
      defineMacro("⟂", "\\perp");
      defineMacro("‼", "\\mathclose{!\\mkern-0.8mu!}");
      defineMacro("∌", "\\notni");
      defineMacro("⌜", "\\ulcorner");
      defineMacro("⌝", "\\urcorner");
      defineMacro("⌞", "\\llcorner");
      defineMacro("⌟", "\\lrcorner");
      defineMacro("©", "\\copyright");
      defineMacro("®", "\\textregistered");
      defineMacro("️", "\\textregistered");
      defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
      defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
      defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
      defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
      defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
      defineMacro("⋮", "\\vdots");
      defineMacro("\\varGamma", "\\mathit{\\Gamma}");
      defineMacro("\\varDelta", "\\mathit{\\Delta}");
      defineMacro("\\varTheta", "\\mathit{\\Theta}");
      defineMacro("\\varLambda", "\\mathit{\\Lambda}");
      defineMacro("\\varXi", "\\mathit{\\Xi}");
      defineMacro("\\varPi", "\\mathit{\\Pi}");
      defineMacro("\\varSigma", "\\mathit{\\Sigma}");
      defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
      defineMacro("\\varPhi", "\\mathit{\\Phi}");
      defineMacro("\\varPsi", "\\mathit{\\Psi}");
      defineMacro("\\varOmega", "\\mathit{\\Omega}");
      defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
      defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}" + "\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
      defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
      defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
      defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
      defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
      defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
      defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
      const dotsByToken = {
        ",": "\\dotsc",
        "\\not": "\\dotsb",
        "+": "\\dotsb",
        "=": "\\dotsb",
        "<": "\\dotsb",
        ">": "\\dotsb",
        "-": "\\dotsb",
        "*": "\\dotsb",
        ":": "\\dotsb",
        "\\DOTSB": "\\dotsb",
        "\\coprod": "\\dotsb",
        "\\bigvee": "\\dotsb",
        "\\bigwedge": "\\dotsb",
        "\\biguplus": "\\dotsb",
        "\\bigcap": "\\dotsb",
        "\\bigcup": "\\dotsb",
        "\\prod": "\\dotsb",
        "\\sum": "\\dotsb",
        "\\bigotimes": "\\dotsb",
        "\\bigoplus": "\\dotsb",
        "\\bigodot": "\\dotsb",
        "\\bigsqcup": "\\dotsb",
        "\\And": "\\dotsb",
        "\\longrightarrow": "\\dotsb",
        "\\Longrightarrow": "\\dotsb",
        "\\longleftarrow": "\\dotsb",
        "\\Longleftarrow": "\\dotsb",
        "\\longleftrightarrow": "\\dotsb",
        "\\Longleftrightarrow": "\\dotsb",
        "\\mapsto": "\\dotsb",
        "\\longmapsto": "\\dotsb",
        "\\hookrightarrow": "\\dotsb",
        "\\doteq": "\\dotsb",
        "\\mathbin": "\\dotsb",
        "\\mathrel": "\\dotsb",
        "\\relbar": "\\dotsb",
        "\\Relbar": "\\dotsb",
        "\\xrightarrow": "\\dotsb",
        "\\xleftarrow": "\\dotsb",
        "\\DOTSI": "\\dotsi",
        "\\int": "\\dotsi",
        "\\oint": "\\dotsi",
        "\\iint": "\\dotsi",
        "\\iiint": "\\dotsi",
        "\\iiiint": "\\dotsi",
        "\\idotsint": "\\dotsi",
        "\\DOTSX": "\\dotsx"
      };
      defineMacro("\\dots", function(context) {
        let thedots = "\\dotso";
        const next = context.expandAfterFuture().text;
        if (next in dotsByToken) {
          thedots = dotsByToken[next];
        } else if (next.slice(0, 4) === "\\not") {
          thedots = "\\dotsb";
        } else if (next in src_symbols.math) {
          if (utils.contains(["bin", "rel"], src_symbols.math[next].group)) {
            thedots = "\\dotsb";
          }
        }
        return thedots;
      });
      const spaceAfterDots = {
        ")": true,
        "]": true,
        "\\rbrack": true,
        "\\}": true,
        "\\rbrace": true,
        "\\rangle": true,
        "\\rceil": true,
        "\\rfloor": true,
        "\\rgroup": true,
        "\\rmoustache": true,
        "\\right": true,
        "\\bigr": true,
        "\\biggr": true,
        "\\Bigr": true,
        "\\Biggr": true,
        $: true,
        ";": true,
        ".": true,
        ",": true
      };
      defineMacro("\\dotso", function(context) {
        const next = context.future().text;
        if (next in spaceAfterDots) {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro("\\dotsc", function(context) {
        const next = context.future().text;
        if (next in spaceAfterDots && next !== ",") {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro("\\cdots", function(context) {
        const next = context.future().text;
        if (next in spaceAfterDots) {
          return "\\@cdots\\,";
        } else {
          return "\\@cdots";
        }
      });
      defineMacro("\\dotsb", "\\cdots");
      defineMacro("\\dotsm", "\\cdots");
      defineMacro("\\dotsi", "\\!\\cdots");
      defineMacro("\\dotsx", "\\ldots\\,");
      defineMacro("\\DOTSI", "\\relax");
      defineMacro("\\DOTSB", "\\relax");
      defineMacro("\\DOTSX", "\\relax");
      defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
      defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
      defineMacro("\\thinspace", "\\,");
      defineMacro("\\>", "\\mskip{4mu}");
      defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
      defineMacro("\\medspace", "\\:");
      defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
      defineMacro("\\thickspace", "\\;");
      defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
      defineMacro("\\negthinspace", "\\!");
      defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
      defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
      defineMacro("\\enspace", "\\kern.5em ");
      defineMacro("\\enskip", "\\hskip.5em\\relax");
      defineMacro("\\quad", "\\hskip1em\\relax");
      defineMacro("\\qquad", "\\hskip2em\\relax");
      defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
      defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
      defineMacro("\\tag@literal", (context) => {
        if (context.macros.get("\\df@tag")) {
          throw new src_ParseError("Multiple \\tag");
        }
        return "\\gdef\\df@tag{\\text{#1}}";
      });
      defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}" + "\\mathbin{\\rm mod}" + "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
      defineMacro("\\pod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
      defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
      defineMacro("\\mod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}" + "{\\rm mod}\\,\\,#1");
      defineMacro("\\newline", "\\\\\\relax");
      defineMacro("\\TeX", "\\textrm{\\html@mathml{" + "T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX" + "}{TeX}}");
      const latexRaiseA = makeEm(fontMetricsData["Main-Regular"][84][1] - 0.7 * fontMetricsData["Main-Regular"][65][1]);
      defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
      defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
      defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
      defineMacro("\\@hspace", "\\hskip #1\\relax");
      defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
      defineMacro("\\ordinarycolon", ":");
      defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
      defineMacro("\\dblcolon", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}" + '{\\mathop{\\char"2237}}');
      defineMacro("\\coloneqq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}" + '{\\mathop{\\char"2254}}');
      defineMacro("\\Coloneqq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}" + '{\\mathop{\\char"2237\\char"3d}}');
      defineMacro("\\coloneq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + '{\\mathop{\\char"3a\\char"2212}}');
      defineMacro("\\Coloneq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + '{\\mathop{\\char"2237\\char"2212}}');
      defineMacro("\\eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + '{\\mathop{\\char"2255}}');
      defineMacro("\\Eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + '{\\mathop{\\char"3d\\char"2237}}');
      defineMacro("\\eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + '{\\mathop{\\char"2239}}');
      defineMacro("\\Eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + '{\\mathop{\\char"2212\\char"2237}}');
      defineMacro("\\colonapprox", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + '{\\mathop{\\char"3a\\char"2248}}');
      defineMacro("\\Colonapprox", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + '{\\mathop{\\char"2237\\char"2248}}');
      defineMacro("\\colonsim", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + '{\\mathop{\\char"3a\\char"223c}}');
      defineMacro("\\Colonsim", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + '{\\mathop{\\char"2237\\char"223c}}');
      defineMacro("∷", "\\dblcolon");
      defineMacro("∹", "\\eqcolon");
      defineMacro("≔", "\\coloneqq");
      defineMacro("≕", "\\eqqcolon");
      defineMacro("⩴", "\\Coloneqq");
      defineMacro("\\ratio", "\\vcentcolon");
      defineMacro("\\coloncolon", "\\dblcolon");
      defineMacro("\\colonequals", "\\coloneqq");
      defineMacro("\\coloncolonequals", "\\Coloneqq");
      defineMacro("\\equalscolon", "\\eqqcolon");
      defineMacro("\\equalscoloncolon", "\\Eqqcolon");
      defineMacro("\\colonminus", "\\coloneq");
      defineMacro("\\coloncolonminus", "\\Coloneq");
      defineMacro("\\minuscolon", "\\eqcolon");
      defineMacro("\\minuscoloncolon", "\\Eqcolon");
      defineMacro("\\coloncolonapprox", "\\Colonapprox");
      defineMacro("\\coloncolonsim", "\\Colonsim");
      defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}");
      defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
      defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
      defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
      defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
      defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
      defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
      defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
      defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
      defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}");
      defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}");
      defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}");
      defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}");
      defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{≰}");
      defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}");
      defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
      defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
      defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}");
      defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}");
      defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
      defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
      defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
      defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
      defineMacro("\\imath", "\\html@mathml{\\@imath}{ı}");
      defineMacro("\\jmath", "\\html@mathml{\\@jmath}{ȷ}");
      defineMacro("\\llbracket", "\\html@mathml{" + "\\mathopen{[\\mkern-3.2mu[}}" + "{\\mathopen{\\char`⟦}}");
      defineMacro("\\rrbracket", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu]}}" + "{\\mathclose{\\char`⟧}}");
      defineMacro("⟦", "\\llbracket");
      defineMacro("⟧", "\\rrbracket");
      defineMacro("\\lBrace", "\\html@mathml{" + "\\mathopen{\\{\\mkern-3.2mu[}}" + "{\\mathopen{\\char`⦃}}");
      defineMacro("\\rBrace", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu\\}}}" + "{\\mathclose{\\char`⦄}}");
      defineMacro("⦃", "\\lBrace");
      defineMacro("⦄", "\\rBrace");
      defineMacro("\\minuso", "\\mathbin{\\html@mathml{" + "{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}" + "{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}" + "{\\char`⦵}}");
      defineMacro("⦵", "\\minuso");
      defineMacro("\\darr", "\\downarrow");
      defineMacro("\\dArr", "\\Downarrow");
      defineMacro("\\Darr", "\\Downarrow");
      defineMacro("\\lang", "\\langle");
      defineMacro("\\rang", "\\rangle");
      defineMacro("\\uarr", "\\uparrow");
      defineMacro("\\uArr", "\\Uparrow");
      defineMacro("\\Uarr", "\\Uparrow");
      defineMacro("\\N", "\\mathbb{N}");
      defineMacro("\\R", "\\mathbb{R}");
      defineMacro("\\Z", "\\mathbb{Z}");
      defineMacro("\\alef", "\\aleph");
      defineMacro("\\alefsym", "\\aleph");
      defineMacro("\\Alpha", "\\mathrm{A}");
      defineMacro("\\Beta", "\\mathrm{B}");
      defineMacro("\\bull", "\\bullet");
      defineMacro("\\Chi", "\\mathrm{X}");
      defineMacro("\\clubs", "\\clubsuit");
      defineMacro("\\cnums", "\\mathbb{C}");
      defineMacro("\\Complex", "\\mathbb{C}");
      defineMacro("\\Dagger", "\\ddagger");
      defineMacro("\\diamonds", "\\diamondsuit");
      defineMacro("\\empty", "\\emptyset");
      defineMacro("\\Epsilon", "\\mathrm{E}");
      defineMacro("\\Eta", "\\mathrm{H}");
      defineMacro("\\exist", "\\exists");
      defineMacro("\\harr", "\\leftrightarrow");
      defineMacro("\\hArr", "\\Leftrightarrow");
      defineMacro("\\Harr", "\\Leftrightarrow");
      defineMacro("\\hearts", "\\heartsuit");
      defineMacro("\\image", "\\Im");
      defineMacro("\\infin", "\\infty");
      defineMacro("\\Iota", "\\mathrm{I}");
      defineMacro("\\isin", "\\in");
      defineMacro("\\Kappa", "\\mathrm{K}");
      defineMacro("\\larr", "\\leftarrow");
      defineMacro("\\lArr", "\\Leftarrow");
      defineMacro("\\Larr", "\\Leftarrow");
      defineMacro("\\lrarr", "\\leftrightarrow");
      defineMacro("\\lrArr", "\\Leftrightarrow");
      defineMacro("\\Lrarr", "\\Leftrightarrow");
      defineMacro("\\Mu", "\\mathrm{M}");
      defineMacro("\\natnums", "\\mathbb{N}");
      defineMacro("\\Nu", "\\mathrm{N}");
      defineMacro("\\Omicron", "\\mathrm{O}");
      defineMacro("\\plusmn", "\\pm");
      defineMacro("\\rarr", "\\rightarrow");
      defineMacro("\\rArr", "\\Rightarrow");
      defineMacro("\\Rarr", "\\Rightarrow");
      defineMacro("\\real", "\\Re");
      defineMacro("\\reals", "\\mathbb{R}");
      defineMacro("\\Reals", "\\mathbb{R}");
      defineMacro("\\Rho", "\\mathrm{P}");
      defineMacro("\\sdot", "\\cdot");
      defineMacro("\\sect", "\\S");
      defineMacro("\\spades", "\\spadesuit");
      defineMacro("\\sub", "\\subset");
      defineMacro("\\sube", "\\subseteq");
      defineMacro("\\supe", "\\supseteq");
      defineMacro("\\Tau", "\\mathrm{T}");
      defineMacro("\\thetasym", "\\vartheta");
      defineMacro("\\weierp", "\\wp");
      defineMacro("\\Zeta", "\\mathrm{Z}");
      defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
      defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
      defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
      defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
      defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
      defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
      defineMacro("\\Bra", "\\left\\langle#1\\right|");
      defineMacro("\\Ket", "\\left|#1\\right\\rangle");
      const braketHelper = (one) => (context) => {
        const left = context.consumeArg().tokens;
        const middle = context.consumeArg().tokens;
        const middleDouble = context.consumeArg().tokens;
        const right = context.consumeArg().tokens;
        const oldMiddle = context.macros.get("|");
        const oldMiddleDouble = context.macros.get("\\|");
        context.macros.beginGroup();
        const midMacro = (double) => (context2) => {
          if (one) {
            context2.macros.set("|", oldMiddle);
            if (middleDouble.length) {
              context2.macros.set("\\|", oldMiddleDouble);
            }
          }
          let doubled = double;
          if (!double && middleDouble.length) {
            const nextToken = context2.future();
            if (nextToken.text === "|") {
              context2.popToken();
              doubled = true;
            }
          }
          return {
            tokens: doubled ? middleDouble : middle,
            numArgs: 0
          };
        };
        context.macros.set("|", midMacro(false));
        if (middleDouble.length) {
          context.macros.set("\\|", midMacro(true));
        }
        const arg = context.consumeArg().tokens;
        const expanded = context.expandTokens([
          ...right,
          ...arg,
          ...left
        ]);
        context.macros.endGroup();
        return {
          tokens: expanded.reverse(),
          numArgs: 0
        };
      };
      defineMacro("\\bra@ket", braketHelper(false));
      defineMacro("\\bra@set", braketHelper(true));
      defineMacro("\\Braket", "\\bra@ket{\\left\\langle}" + "{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
      defineMacro("\\Set", "\\bra@set{\\left\\{\\:}" + "{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
      defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
      defineMacro("\\angln", "{\\angl n}");
      defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
      defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
      defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
      defineMacro("\\red", "\\textcolor{##df0030}{#1}");
      defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
      defineMacro("\\gray", "\\textcolor{gray}{#1}");
      defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
      defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
      defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
      defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
      defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
      defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
      defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
      defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
      defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
      defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
      defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
      defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
      defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
      defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
      defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
      defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
      defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
      defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
      defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
      defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
      defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
      defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
      defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
      defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
      defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
      defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
      defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
      defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
      defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
      defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
      defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
      defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
      defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
      defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
      defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
      defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
      defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
      defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
      defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
      defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
      defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
      defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
      defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
      defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
      defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
      defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
      defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
      defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
      defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
      defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
      const implicitCommands = {
        "^": true,
        _: true,
        "\\limits": true,
        "\\nolimits": true
      };

      class MacroExpander {
        constructor(input, settings, mode) {
          this.settings = undefined;
          this.expansionCount = undefined;
          this.lexer = undefined;
          this.macros = undefined;
          this.stack = undefined;
          this.mode = undefined;
          this.settings = settings;
          this.expansionCount = 0;
          this.feed(input);
          this.macros = new Namespace(src_macros, settings.macros);
          this.mode = mode;
          this.stack = [];
        }
        feed(input) {
          this.lexer = new Lexer(input, this.settings);
        }
        switchMode(newMode) {
          this.mode = newMode;
        }
        beginGroup() {
          this.macros.beginGroup();
        }
        endGroup() {
          this.macros.endGroup();
        }
        endGroups() {
          this.macros.endGroups();
        }
        future() {
          if (this.stack.length === 0) {
            this.pushToken(this.lexer.lex());
          }
          return this.stack[this.stack.length - 1];
        }
        popToken() {
          this.future();
          return this.stack.pop();
        }
        pushToken(token) {
          this.stack.push(token);
        }
        pushTokens(tokens) {
          this.stack.push(...tokens);
        }
        scanArgument(isOptional) {
          let start;
          let end;
          let tokens;
          if (isOptional) {
            this.consumeSpaces();
            if (this.future().text !== "[") {
              return null;
            }
            start = this.popToken();
            ({
              tokens,
              end
            } = this.consumeArg(["]"]));
          } else {
            ({
              tokens,
              start,
              end
            } = this.consumeArg());
          }
          this.pushToken(new Token("EOF", end.loc));
          this.pushTokens(tokens);
          return start.range(end, "");
        }
        consumeSpaces() {
          for (;; ) {
            const token = this.future();
            if (token.text === " ") {
              this.stack.pop();
            } else {
              break;
            }
          }
        }
        consumeArg(delims) {
          const tokens = [];
          const isDelimited = delims && delims.length > 0;
          if (!isDelimited) {
            this.consumeSpaces();
          }
          const start = this.future();
          let tok;
          let depth = 0;
          let match = 0;
          do {
            tok = this.popToken();
            tokens.push(tok);
            if (tok.text === "{") {
              ++depth;
            } else if (tok.text === "}") {
              --depth;
              if (depth === -1) {
                throw new src_ParseError("Extra }", tok);
              }
            } else if (tok.text === "EOF") {
              throw new src_ParseError("Unexpected end of input in a macro argument" + ", expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
            }
            if (delims && isDelimited) {
              if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
                ++match;
                if (match === delims.length) {
                  tokens.splice(-match, match);
                  break;
                }
              } else {
                match = 0;
              }
            }
          } while (depth !== 0 || isDelimited);
          if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
            tokens.pop();
            tokens.shift();
          }
          tokens.reverse();
          return {
            tokens,
            start,
            end: tok
          };
        }
        consumeArgs(numArgs, delimiters2) {
          if (delimiters2) {
            if (delimiters2.length !== numArgs + 1) {
              throw new src_ParseError("The length of delimiters doesn't match the number of args!");
            }
            const delims = delimiters2[0];
            for (let i = 0;i < delims.length; i++) {
              const tok = this.popToken();
              if (delims[i] !== tok.text) {
                throw new src_ParseError("Use of the macro doesn't match its definition", tok);
              }
            }
          }
          const args = [];
          for (let i = 0;i < numArgs; i++) {
            args.push(this.consumeArg(delimiters2 && delimiters2[i + 1]).tokens);
          }
          return args;
        }
        countExpansion(amount) {
          this.expansionCount += amount;
          if (this.expansionCount > this.settings.maxExpand) {
            throw new src_ParseError("Too many expansions: infinite loop or " + "need to increase maxExpand setting");
          }
        }
        expandOnce(expandableOnly) {
          const topToken = this.popToken();
          const name = topToken.text;
          const expansion = !topToken.noexpand ? this._getExpansion(name) : null;
          if (expansion == null || expandableOnly && expansion.unexpandable) {
            if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
              throw new src_ParseError("Undefined control sequence: " + name);
            }
            this.pushToken(topToken);
            return false;
          }
          this.countExpansion(1);
          let tokens = expansion.tokens;
          const args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
          if (expansion.numArgs) {
            tokens = tokens.slice();
            for (let i = tokens.length - 1;i >= 0; --i) {
              let tok = tokens[i];
              if (tok.text === "#") {
                if (i === 0) {
                  throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                }
                tok = tokens[--i];
                if (tok.text === "#") {
                  tokens.splice(i + 1, 1);
                } else if (/^[1-9]$/.test(tok.text)) {
                  tokens.splice(i, 2, ...args[+tok.text - 1]);
                } else {
                  throw new src_ParseError("Not a valid argument number", tok);
                }
              }
            }
          }
          this.pushTokens(tokens);
          return tokens.length;
        }
        expandAfterFuture() {
          this.expandOnce();
          return this.future();
        }
        expandNextToken() {
          for (;; ) {
            if (this.expandOnce() === false) {
              const token = this.stack.pop();
              if (token.treatAsRelax) {
                token.text = "\\relax";
              }
              return token;
            }
          }
          throw new Error;
        }
        expandMacro(name) {
          return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;
        }
        expandTokens(tokens) {
          const output = [];
          const oldStackLength = this.stack.length;
          this.pushTokens(tokens);
          while (this.stack.length > oldStackLength) {
            if (this.expandOnce(true) === false) {
              const token = this.stack.pop();
              if (token.treatAsRelax) {
                token.noexpand = false;
                token.treatAsRelax = false;
              }
              output.push(token);
            }
          }
          this.countExpansion(output.length);
          return output;
        }
        expandMacroAsText(name) {
          const tokens = this.expandMacro(name);
          if (tokens) {
            return tokens.map((token) => token.text).join("");
          } else {
            return tokens;
          }
        }
        _getExpansion(name) {
          const definition = this.macros.get(name);
          if (definition == null) {
            return definition;
          }
          if (name.length === 1) {
            const catcode = this.lexer.catcodes[name];
            if (catcode != null && catcode !== 13) {
              return;
            }
          }
          const expansion = typeof definition === "function" ? definition(this) : definition;
          if (typeof expansion === "string") {
            let numArgs = 0;
            if (expansion.indexOf("#") !== -1) {
              const stripped = expansion.replace(/##/g, "");
              while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                ++numArgs;
              }
            }
            const bodyLexer = new Lexer(expansion, this.settings);
            const tokens = [];
            let tok = bodyLexer.lex();
            while (tok.text !== "EOF") {
              tokens.push(tok);
              tok = bodyLexer.lex();
            }
            tokens.reverse();
            const expanded = {
              tokens,
              numArgs
            };
            return expanded;
          }
          return expansion;
        }
        isDefined(name) {
          return this.macros.has(name) || src_functions.hasOwnProperty(name) || src_symbols.math.hasOwnProperty(name) || src_symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
        }
        isExpandable(name) {
          const macro = this.macros.get(name);
          return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name) && !src_functions[name].primitive;
        }
      }
      const unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;
      const uSubsAndSups = Object.freeze({
        "₊": "+",
        "₋": "-",
        "₌": "=",
        "₍": "(",
        "₎": ")",
        "₀": "0",
        "₁": "1",
        "₂": "2",
        "₃": "3",
        "₄": "4",
        "₅": "5",
        "₆": "6",
        "₇": "7",
        "₈": "8",
        "₉": "9",
        "ₐ": "a",
        "ₑ": "e",
        "ₕ": "h",
        "ᵢ": "i",
        "ⱼ": "j",
        "ₖ": "k",
        "ₗ": "l",
        "ₘ": "m",
        "ₙ": "n",
        "ₒ": "o",
        "ₚ": "p",
        "ᵣ": "r",
        "ₛ": "s",
        "ₜ": "t",
        "ᵤ": "u",
        "ᵥ": "v",
        "ₓ": "x",
        "ᵦ": "β",
        "ᵧ": "γ",
        "ᵨ": "ρ",
        "ᵩ": "ϕ",
        "ᵪ": "χ",
        "⁺": "+",
        "⁻": "-",
        "⁼": "=",
        "⁽": "(",
        "⁾": ")",
        "⁰": "0",
        "¹": "1",
        "²": "2",
        "³": "3",
        "⁴": "4",
        "⁵": "5",
        "⁶": "6",
        "⁷": "7",
        "⁸": "8",
        "⁹": "9",
        "ᴬ": "A",
        "ᴮ": "B",
        "ᴰ": "D",
        "ᴱ": "E",
        "ᴳ": "G",
        "ᴴ": "H",
        "ᴵ": "I",
        "ᴶ": "J",
        "ᴷ": "K",
        "ᴸ": "L",
        "ᴹ": "M",
        "ᴺ": "N",
        "ᴼ": "O",
        "ᴾ": "P",
        "ᴿ": "R",
        "ᵀ": "T",
        "ᵁ": "U",
        "ⱽ": "V",
        "ᵂ": "W",
        "ᵃ": "a",
        "ᵇ": "b",
        "ᶜ": "c",
        "ᵈ": "d",
        "ᵉ": "e",
        "ᶠ": "f",
        "ᵍ": "g",
        "ʰ": "h",
        "ⁱ": "i",
        "ʲ": "j",
        "ᵏ": "k",
        "ˡ": "l",
        "ᵐ": "m",
        "ⁿ": "n",
        "ᵒ": "o",
        "ᵖ": "p",
        "ʳ": "r",
        "ˢ": "s",
        "ᵗ": "t",
        "ᵘ": "u",
        "ᵛ": "v",
        "ʷ": "w",
        "ˣ": "x",
        "ʸ": "y",
        "ᶻ": "z",
        "ᵝ": "β",
        "ᵞ": "γ",
        "ᵟ": "δ",
        "ᵠ": "ϕ",
        "ᵡ": "χ",
        "ᶿ": "θ"
      });
      const unicodeAccents = {
        "́": {
          text: "\\'",
          math: "\\acute"
        },
        "̀": {
          text: "\\`",
          math: "\\grave"
        },
        "̈": {
          text: "\\\"",
          math: "\\ddot"
        },
        "̃": {
          text: "\\~",
          math: "\\tilde"
        },
        "̄": {
          text: "\\=",
          math: "\\bar"
        },
        "̆": {
          text: "\\u",
          math: "\\breve"
        },
        "̌": {
          text: "\\v",
          math: "\\check"
        },
        "̂": {
          text: "\\^",
          math: "\\hat"
        },
        "̇": {
          text: "\\.",
          math: "\\dot"
        },
        "̊": {
          text: "\\r",
          math: "\\mathring"
        },
        "̋": {
          text: "\\H"
        },
        "̧": {
          text: "\\c"
        }
      };
      const unicodeSymbols = {
        "á": "á",
        "à": "à",
        "ä": "ä",
        "ǟ": "ǟ",
        "ã": "ã",
        "ā": "ā",
        "ă": "ă",
        "ắ": "ắ",
        "ằ": "ằ",
        "ẵ": "ẵ",
        "ǎ": "ǎ",
        "â": "â",
        "ấ": "ấ",
        "ầ": "ầ",
        "ẫ": "ẫ",
        "ȧ": "ȧ",
        "ǡ": "ǡ",
        "å": "å",
        "ǻ": "ǻ",
        "ḃ": "ḃ",
        "ć": "ć",
        "ḉ": "ḉ",
        "č": "č",
        "ĉ": "ĉ",
        "ċ": "ċ",
        "ç": "ç",
        "ď": "ď",
        "ḋ": "ḋ",
        "ḑ": "ḑ",
        "é": "é",
        "è": "è",
        "ë": "ë",
        "ẽ": "ẽ",
        "ē": "ē",
        "ḗ": "ḗ",
        "ḕ": "ḕ",
        "ĕ": "ĕ",
        "ḝ": "ḝ",
        "ě": "ě",
        "ê": "ê",
        "ế": "ế",
        "ề": "ề",
        "ễ": "ễ",
        "ė": "ė",
        "ȩ": "ȩ",
        "ḟ": "ḟ",
        "ǵ": "ǵ",
        "ḡ": "ḡ",
        "ğ": "ğ",
        "ǧ": "ǧ",
        "ĝ": "ĝ",
        "ġ": "ġ",
        "ģ": "ģ",
        "ḧ": "ḧ",
        "ȟ": "ȟ",
        "ĥ": "ĥ",
        "ḣ": "ḣ",
        "ḩ": "ḩ",
        "í": "í",
        "ì": "ì",
        "ï": "ï",
        "ḯ": "ḯ",
        "ĩ": "ĩ",
        "ī": "ī",
        "ĭ": "ĭ",
        "ǐ": "ǐ",
        "î": "î",
        "ǰ": "ǰ",
        "ĵ": "ĵ",
        "ḱ": "ḱ",
        "ǩ": "ǩ",
        "ķ": "ķ",
        "ĺ": "ĺ",
        "ľ": "ľ",
        "ļ": "ļ",
        "ḿ": "ḿ",
        "ṁ": "ṁ",
        "ń": "ń",
        "ǹ": "ǹ",
        "ñ": "ñ",
        "ň": "ň",
        "ṅ": "ṅ",
        "ņ": "ņ",
        "ó": "ó",
        "ò": "ò",
        "ö": "ö",
        "ȫ": "ȫ",
        "õ": "õ",
        "ṍ": "ṍ",
        "ṏ": "ṏ",
        "ȭ": "ȭ",
        "ō": "ō",
        "ṓ": "ṓ",
        "ṑ": "ṑ",
        "ŏ": "ŏ",
        "ǒ": "ǒ",
        "ô": "ô",
        "ố": "ố",
        "ồ": "ồ",
        "ỗ": "ỗ",
        "ȯ": "ȯ",
        "ȱ": "ȱ",
        "ő": "ő",
        "ṕ": "ṕ",
        "ṗ": "ṗ",
        "ŕ": "ŕ",
        "ř": "ř",
        "ṙ": "ṙ",
        "ŗ": "ŗ",
        "ś": "ś",
        "ṥ": "ṥ",
        "š": "š",
        "ṧ": "ṧ",
        "ŝ": "ŝ",
        "ṡ": "ṡ",
        "ş": "ş",
        "ẗ": "ẗ",
        "ť": "ť",
        "ṫ": "ṫ",
        "ţ": "ţ",
        "ú": "ú",
        "ù": "ù",
        "ü": "ü",
        "ǘ": "ǘ",
        "ǜ": "ǜ",
        "ǖ": "ǖ",
        "ǚ": "ǚ",
        "ũ": "ũ",
        "ṹ": "ṹ",
        "ū": "ū",
        "ṻ": "ṻ",
        "ŭ": "ŭ",
        "ǔ": "ǔ",
        "û": "û",
        "ů": "ů",
        "ű": "ű",
        "ṽ": "ṽ",
        "ẃ": "ẃ",
        "ẁ": "ẁ",
        "ẅ": "ẅ",
        "ŵ": "ŵ",
        "ẇ": "ẇ",
        "ẘ": "ẘ",
        "ẍ": "ẍ",
        "ẋ": "ẋ",
        "ý": "ý",
        "ỳ": "ỳ",
        "ÿ": "ÿ",
        "ỹ": "ỹ",
        "ȳ": "ȳ",
        "ŷ": "ŷ",
        "ẏ": "ẏ",
        "ẙ": "ẙ",
        "ź": "ź",
        "ž": "ž",
        "ẑ": "ẑ",
        "ż": "ż",
        "Á": "Á",
        "À": "À",
        "Ä": "Ä",
        "Ǟ": "Ǟ",
        "Ã": "Ã",
        "Ā": "Ā",
        "Ă": "Ă",
        "Ắ": "Ắ",
        "Ằ": "Ằ",
        "Ẵ": "Ẵ",
        "Ǎ": "Ǎ",
        "Â": "Â",
        "Ấ": "Ấ",
        "Ầ": "Ầ",
        "Ẫ": "Ẫ",
        "Ȧ": "Ȧ",
        "Ǡ": "Ǡ",
        "Å": "Å",
        "Ǻ": "Ǻ",
        "Ḃ": "Ḃ",
        "Ć": "Ć",
        "Ḉ": "Ḉ",
        "Č": "Č",
        "Ĉ": "Ĉ",
        "Ċ": "Ċ",
        "Ç": "Ç",
        "Ď": "Ď",
        "Ḋ": "Ḋ",
        "Ḑ": "Ḑ",
        "É": "É",
        "È": "È",
        "Ë": "Ë",
        "Ẽ": "Ẽ",
        "Ē": "Ē",
        "Ḗ": "Ḗ",
        "Ḕ": "Ḕ",
        "Ĕ": "Ĕ",
        "Ḝ": "Ḝ",
        "Ě": "Ě",
        "Ê": "Ê",
        "Ế": "Ế",
        "Ề": "Ề",
        "Ễ": "Ễ",
        "Ė": "Ė",
        "Ȩ": "Ȩ",
        "Ḟ": "Ḟ",
        "Ǵ": "Ǵ",
        "Ḡ": "Ḡ",
        "Ğ": "Ğ",
        "Ǧ": "Ǧ",
        "Ĝ": "Ĝ",
        "Ġ": "Ġ",
        "Ģ": "Ģ",
        "Ḧ": "Ḧ",
        "Ȟ": "Ȟ",
        "Ĥ": "Ĥ",
        "Ḣ": "Ḣ",
        "Ḩ": "Ḩ",
        "Í": "Í",
        "Ì": "Ì",
        "Ï": "Ï",
        "Ḯ": "Ḯ",
        "Ĩ": "Ĩ",
        "Ī": "Ī",
        "Ĭ": "Ĭ",
        "Ǐ": "Ǐ",
        "Î": "Î",
        "İ": "İ",
        "Ĵ": "Ĵ",
        "Ḱ": "Ḱ",
        "Ǩ": "Ǩ",
        "Ķ": "Ķ",
        "Ĺ": "Ĺ",
        "Ľ": "Ľ",
        "Ļ": "Ļ",
        "Ḿ": "Ḿ",
        "Ṁ": "Ṁ",
        "Ń": "Ń",
        "Ǹ": "Ǹ",
        "Ñ": "Ñ",
        "Ň": "Ň",
        "Ṅ": "Ṅ",
        "Ņ": "Ņ",
        "Ó": "Ó",
        "Ò": "Ò",
        "Ö": "Ö",
        "Ȫ": "Ȫ",
        "Õ": "Õ",
        "Ṍ": "Ṍ",
        "Ṏ": "Ṏ",
        "Ȭ": "Ȭ",
        "Ō": "Ō",
        "Ṓ": "Ṓ",
        "Ṑ": "Ṑ",
        "Ŏ": "Ŏ",
        "Ǒ": "Ǒ",
        "Ô": "Ô",
        "Ố": "Ố",
        "Ồ": "Ồ",
        "Ỗ": "Ỗ",
        "Ȯ": "Ȯ",
        "Ȱ": "Ȱ",
        "Ő": "Ő",
        "Ṕ": "Ṕ",
        "Ṗ": "Ṗ",
        "Ŕ": "Ŕ",
        "Ř": "Ř",
        "Ṙ": "Ṙ",
        "Ŗ": "Ŗ",
        "Ś": "Ś",
        "Ṥ": "Ṥ",
        "Š": "Š",
        "Ṧ": "Ṧ",
        "Ŝ": "Ŝ",
        "Ṡ": "Ṡ",
        "Ş": "Ş",
        "Ť": "Ť",
        "Ṫ": "Ṫ",
        "Ţ": "Ţ",
        "Ú": "Ú",
        "Ù": "Ù",
        "Ü": "Ü",
        "Ǘ": "Ǘ",
        "Ǜ": "Ǜ",
        "Ǖ": "Ǖ",
        "Ǚ": "Ǚ",
        "Ũ": "Ũ",
        "Ṹ": "Ṹ",
        "Ū": "Ū",
        "Ṻ": "Ṻ",
        "Ŭ": "Ŭ",
        "Ǔ": "Ǔ",
        "Û": "Û",
        "Ů": "Ů",
        "Ű": "Ű",
        "Ṽ": "Ṽ",
        "Ẃ": "Ẃ",
        "Ẁ": "Ẁ",
        "Ẅ": "Ẅ",
        "Ŵ": "Ŵ",
        "Ẇ": "Ẇ",
        "Ẍ": "Ẍ",
        "Ẋ": "Ẋ",
        "Ý": "Ý",
        "Ỳ": "Ỳ",
        "Ÿ": "Ÿ",
        "Ỹ": "Ỹ",
        "Ȳ": "Ȳ",
        "Ŷ": "Ŷ",
        "Ẏ": "Ẏ",
        "Ź": "Ź",
        "Ž": "Ž",
        "Ẑ": "Ẑ",
        "Ż": "Ż",
        "ά": "ά",
        "ὰ": "ὰ",
        "ᾱ": "ᾱ",
        "ᾰ": "ᾰ",
        "έ": "έ",
        "ὲ": "ὲ",
        "ή": "ή",
        "ὴ": "ὴ",
        "ί": "ί",
        "ὶ": "ὶ",
        "ϊ": "ϊ",
        "ΐ": "ΐ",
        "ῒ": "ῒ",
        "ῑ": "ῑ",
        "ῐ": "ῐ",
        "ό": "ό",
        "ὸ": "ὸ",
        "ύ": "ύ",
        "ὺ": "ὺ",
        "ϋ": "ϋ",
        "ΰ": "ΰ",
        "ῢ": "ῢ",
        "ῡ": "ῡ",
        "ῠ": "ῠ",
        "ώ": "ώ",
        "ὼ": "ὼ",
        "Ύ": "Ύ",
        "Ὺ": "Ὺ",
        "Ϋ": "Ϋ",
        "Ῡ": "Ῡ",
        "Ῠ": "Ῠ",
        "Ώ": "Ώ",
        "Ὼ": "Ὼ"
      };

      class Parser {
        constructor(input, settings) {
          this.mode = undefined;
          this.gullet = undefined;
          this.settings = undefined;
          this.leftrightDepth = undefined;
          this.nextToken = undefined;
          this.mode = "math";
          this.gullet = new MacroExpander(input, settings, this.mode);
          this.settings = settings;
          this.leftrightDepth = 0;
        }
        expect(text, consume) {
          if (consume === undefined) {
            consume = true;
          }
          if (this.fetch().text !== text) {
            throw new src_ParseError("Expected '" + text + "', got '" + this.fetch().text + "'", this.fetch());
          }
          if (consume) {
            this.consume();
          }
        }
        consume() {
          this.nextToken = null;
        }
        fetch() {
          if (this.nextToken == null) {
            this.nextToken = this.gullet.expandNextToken();
          }
          return this.nextToken;
        }
        switchMode(newMode) {
          this.mode = newMode;
          this.gullet.switchMode(newMode);
        }
        parse() {
          if (!this.settings.globalGroup) {
            this.gullet.beginGroup();
          }
          if (this.settings.colorIsTextColor) {
            this.gullet.macros.set("\\color", "\\textcolor");
          }
          try {
            const parse = this.parseExpression(false);
            this.expect("EOF");
            if (!this.settings.globalGroup) {
              this.gullet.endGroup();
            }
            return parse;
          } finally {
            this.gullet.endGroups();
          }
        }
        subparse(tokens) {
          const oldToken = this.nextToken;
          this.consume();
          this.gullet.pushToken(new Token("}"));
          this.gullet.pushTokens(tokens);
          const parse = this.parseExpression(false);
          this.expect("}");
          this.nextToken = oldToken;
          return parse;
        }
        parseExpression(breakOnInfix, breakOnTokenText) {
          const body = [];
          while (true) {
            if (this.mode === "math") {
              this.consumeSpaces();
            }
            const lex = this.fetch();
            if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
              break;
            }
            if (breakOnTokenText && lex.text === breakOnTokenText) {
              break;
            }
            if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
              break;
            }
            const atom = this.parseAtom(breakOnTokenText);
            if (!atom) {
              break;
            } else if (atom.type === "internal") {
              continue;
            }
            body.push(atom);
          }
          if (this.mode === "text") {
            this.formLigatures(body);
          }
          return this.handleInfixNodes(body);
        }
        handleInfixNodes(body) {
          let overIndex = -1;
          let funcName;
          for (let i = 0;i < body.length; i++) {
            if (body[i].type === "infix") {
              if (overIndex !== -1) {
                throw new src_ParseError("only one infix operator per group", body[i].token);
              }
              overIndex = i;
              funcName = body[i].replaceWith;
            }
          }
          if (overIndex !== -1 && funcName) {
            let numerNode;
            let denomNode;
            const numerBody = body.slice(0, overIndex);
            const denomBody = body.slice(overIndex + 1);
            if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
              numerNode = numerBody[0];
            } else {
              numerNode = {
                type: "ordgroup",
                mode: this.mode,
                body: numerBody
              };
            }
            if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
              denomNode = denomBody[0];
            } else {
              denomNode = {
                type: "ordgroup",
                mode: this.mode,
                body: denomBody
              };
            }
            let node;
            if (funcName === "\\\\abovefrac") {
              node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
            } else {
              node = this.callFunction(funcName, [numerNode, denomNode], []);
            }
            return [node];
          } else {
            return body;
          }
        }
        handleSupSubscript(name) {
          const symbolToken = this.fetch();
          const symbol = symbolToken.text;
          this.consume();
          this.consumeSpaces();
          const group = this.parseGroup(name);
          if (!group) {
            throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
          }
          return group;
        }
        formatUnsupportedCmd(text) {
          const textordArray = [];
          for (let i = 0;i < text.length; i++) {
            textordArray.push({
              type: "textord",
              mode: "text",
              text: text[i]
            });
          }
          const textNode = {
            type: "text",
            mode: this.mode,
            body: textordArray
          };
          const colorNode = {
            type: "color",
            mode: this.mode,
            color: this.settings.errorColor,
            body: [textNode]
          };
          return colorNode;
        }
        parseAtom(breakOnTokenText) {
          const base = this.parseGroup("atom", breakOnTokenText);
          if (this.mode === "text") {
            return base;
          }
          let superscript;
          let subscript;
          while (true) {
            this.consumeSpaces();
            const lex = this.fetch();
            if (lex.text === "\\limits" || lex.text === "\\nolimits") {
              if (base && base.type === "op") {
                const limits = lex.text === "\\limits";
                base.limits = limits;
                base.alwaysHandleSupSub = true;
              } else if (base && base.type === "operatorname") {
                if (base.alwaysHandleSupSub) {
                  base.limits = lex.text === "\\limits";
                }
              } else {
                throw new src_ParseError("Limit controls must follow a math operator", lex);
              }
              this.consume();
            } else if (lex.text === "^") {
              if (superscript) {
                throw new src_ParseError("Double superscript", lex);
              }
              superscript = this.handleSupSubscript("superscript");
            } else if (lex.text === "_") {
              if (subscript) {
                throw new src_ParseError("Double subscript", lex);
              }
              subscript = this.handleSupSubscript("subscript");
            } else if (lex.text === "'") {
              if (superscript) {
                throw new src_ParseError("Double superscript", lex);
              }
              const prime = {
                type: "textord",
                mode: this.mode,
                text: "\\prime"
              };
              const primes = [prime];
              this.consume();
              while (this.fetch().text === "'") {
                primes.push(prime);
                this.consume();
              }
              if (this.fetch().text === "^") {
                primes.push(this.handleSupSubscript("superscript"));
              }
              superscript = {
                type: "ordgroup",
                mode: this.mode,
                body: primes
              };
            } else if (uSubsAndSups[lex.text]) {
              const isSub = unicodeSubRegEx.test(lex.text);
              const subsupTokens = [];
              subsupTokens.push(new Token(uSubsAndSups[lex.text]));
              this.consume();
              while (true) {
                const token = this.fetch().text;
                if (!uSubsAndSups[token]) {
                  break;
                }
                if (unicodeSubRegEx.test(token) !== isSub) {
                  break;
                }
                subsupTokens.unshift(new Token(uSubsAndSups[token]));
                this.consume();
              }
              const body = this.subparse(subsupTokens);
              if (isSub) {
                subscript = {
                  type: "ordgroup",
                  mode: "math",
                  body
                };
              } else {
                superscript = {
                  type: "ordgroup",
                  mode: "math",
                  body
                };
              }
            } else {
              break;
            }
          }
          if (superscript || subscript) {
            return {
              type: "supsub",
              mode: this.mode,
              base,
              sup: superscript,
              sub: subscript
            };
          } else {
            return base;
          }
        }
        parseFunction(breakOnTokenText, name) {
          const token = this.fetch();
          const func = token.text;
          const funcData = src_functions[func];
          if (!funcData) {
            return null;
          }
          this.consume();
          if (name && name !== "atom" && !funcData.allowedInArgument) {
            throw new src_ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
          } else if (this.mode === "text" && !funcData.allowedInText) {
            throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
          } else if (this.mode === "math" && funcData.allowedInMath === false) {
            throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
          }
          const {
            args,
            optArgs
          } = this.parseArguments(func, funcData);
          return this.callFunction(func, args, optArgs, token, breakOnTokenText);
        }
        callFunction(name, args, optArgs, token, breakOnTokenText) {
          const context = {
            funcName: name,
            parser: this,
            token,
            breakOnTokenText
          };
          const func = src_functions[name];
          if (func && func.handler) {
            return func.handler(context, args, optArgs);
          } else {
            throw new src_ParseError("No function handler for " + name);
          }
        }
        parseArguments(func, funcData) {
          const totalArgs = funcData.numArgs + funcData.numOptionalArgs;
          if (totalArgs === 0) {
            return {
              args: [],
              optArgs: []
            };
          }
          const args = [];
          const optArgs = [];
          for (let i = 0;i < totalArgs; i++) {
            let argType = funcData.argTypes && funcData.argTypes[i];
            const isOptional = i < funcData.numOptionalArgs;
            if (funcData.primitive && argType == null || funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
              argType = "primitive";
            }
            const arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
            if (isOptional) {
              optArgs.push(arg);
            } else if (arg != null) {
              args.push(arg);
            } else {
              throw new src_ParseError("Null argument, please report this as a bug");
            }
          }
          return {
            args,
            optArgs
          };
        }
        parseGroupOfType(name, type, optional) {
          switch (type) {
            case "color":
              return this.parseColorGroup(optional);
            case "size":
              return this.parseSizeGroup(optional);
            case "url":
              return this.parseUrlGroup(optional);
            case "math":
            case "text":
              return this.parseArgumentGroup(optional, type);
            case "hbox": {
              const group = this.parseArgumentGroup(optional, "text");
              return group != null ? {
                type: "styling",
                mode: group.mode,
                body: [group],
                style: "text"
              } : null;
            }
            case "raw": {
              const token = this.parseStringGroup("raw", optional);
              return token != null ? {
                type: "raw",
                mode: "text",
                string: token.text
              } : null;
            }
            case "primitive": {
              if (optional) {
                throw new src_ParseError("A primitive argument cannot be optional");
              }
              const group = this.parseGroup(name);
              if (group == null) {
                throw new src_ParseError("Expected group as " + name, this.fetch());
              }
              return group;
            }
            case "original":
            case null:
            case undefined:
              return this.parseArgumentGroup(optional);
            default:
              throw new src_ParseError("Unknown group type as " + name, this.fetch());
          }
        }
        consumeSpaces() {
          while (this.fetch().text === " ") {
            this.consume();
          }
        }
        parseStringGroup(modeName, optional) {
          const argToken = this.gullet.scanArgument(optional);
          if (argToken == null) {
            return null;
          }
          let str = "";
          let nextToken;
          while ((nextToken = this.fetch()).text !== "EOF") {
            str += nextToken.text;
            this.consume();
          }
          this.consume();
          argToken.text = str;
          return argToken;
        }
        parseRegexGroup(regex, modeName) {
          const firstToken = this.fetch();
          let lastToken = firstToken;
          let str = "";
          let nextToken;
          while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
            lastToken = nextToken;
            str += lastToken.text;
            this.consume();
          }
          if (str === "") {
            throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
          }
          return firstToken.range(lastToken, str);
        }
        parseColorGroup(optional) {
          const res = this.parseStringGroup("color", optional);
          if (res == null) {
            return null;
          }
          const match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
          if (!match) {
            throw new src_ParseError("Invalid color: '" + res.text + "'", res);
          }
          let color = match[0];
          if (/^[0-9a-f]{6}$/i.test(color)) {
            color = "#" + color;
          }
          return {
            type: "color-token",
            mode: this.mode,
            color
          };
        }
        parseSizeGroup(optional) {
          let res;
          let isBlank = false;
          this.gullet.consumeSpaces();
          if (!optional && this.gullet.future().text !== "{") {
            res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
          } else {
            res = this.parseStringGroup("size", optional);
          }
          if (!res) {
            return null;
          }
          if (!optional && res.text.length === 0) {
            res.text = "0pt";
            isBlank = true;
          }
          const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
          if (!match) {
            throw new src_ParseError("Invalid size: '" + res.text + "'", res);
          }
          const data = {
            number: +(match[1] + match[2]),
            unit: match[3]
          };
          if (!validUnit(data)) {
            throw new src_ParseError("Invalid unit: '" + data.unit + "'", res);
          }
          return {
            type: "size",
            mode: this.mode,
            value: data,
            isBlank
          };
        }
        parseUrlGroup(optional) {
          this.gullet.lexer.setCatcode("%", 13);
          this.gullet.lexer.setCatcode("~", 12);
          const res = this.parseStringGroup("url", optional);
          this.gullet.lexer.setCatcode("%", 14);
          this.gullet.lexer.setCatcode("~", 13);
          if (res == null) {
            return null;
          }
          const url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
          return {
            type: "url",
            mode: this.mode,
            url
          };
        }
        parseArgumentGroup(optional, mode) {
          const argToken = this.gullet.scanArgument(optional);
          if (argToken == null) {
            return null;
          }
          const outerMode = this.mode;
          if (mode) {
            this.switchMode(mode);
          }
          this.gullet.beginGroup();
          const expression = this.parseExpression(false, "EOF");
          this.expect("EOF");
          this.gullet.endGroup();
          const result = {
            type: "ordgroup",
            mode: this.mode,
            loc: argToken.loc,
            body: expression
          };
          if (mode) {
            this.switchMode(outerMode);
          }
          return result;
        }
        parseGroup(name, breakOnTokenText) {
          const firstToken = this.fetch();
          const text = firstToken.text;
          let result;
          if (text === "{" || text === "\\begingroup") {
            this.consume();
            const groupEnd = text === "{" ? "}" : "\\endgroup";
            this.gullet.beginGroup();
            const expression = this.parseExpression(false, groupEnd);
            const lastToken = this.fetch();
            this.expect(groupEnd);
            this.gullet.endGroup();
            result = {
              type: "ordgroup",
              mode: this.mode,
              loc: SourceLocation.range(firstToken, lastToken),
              body: expression,
              semisimple: text === "\\begingroup" || undefined
            };
          } else {
            result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
            if (result == null && text[0] === "\\" && !implicitCommands.hasOwnProperty(text)) {
              if (this.settings.throwOnError) {
                throw new src_ParseError("Undefined control sequence: " + text, firstToken);
              }
              result = this.formatUnsupportedCmd(text);
              this.consume();
            }
          }
          return result;
        }
        formLigatures(group) {
          let n = group.length - 1;
          for (let i = 0;i < n; ++i) {
            const a3 = group[i];
            const v5 = a3.text;
            if (v5 === "-" && group[i + 1].text === "-") {
              if (i + 1 < n && group[i + 2].text === "-") {
                group.splice(i, 3, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a3, group[i + 2]),
                  text: "---"
                });
                n -= 2;
              } else {
                group.splice(i, 2, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a3, group[i + 1]),
                  text: "--"
                });
                n -= 1;
              }
            }
            if ((v5 === "'" || v5 === "`") && group[i + 1].text === v5) {
              group.splice(i, 2, {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(a3, group[i + 1]),
                text: v5 + v5
              });
              n -= 1;
            }
          }
        }
        parseSymbol() {
          const nucleus = this.fetch();
          let text = nucleus.text;
          if (/^\\verb[^a-zA-Z]/.test(text)) {
            this.consume();
            let arg = text.slice(5);
            const star = arg.charAt(0) === "*";
            if (star) {
              arg = arg.slice(1);
            }
            if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
              throw new src_ParseError(`\\verb assertion failed --
                    please report what input caused this bug`);
            }
            arg = arg.slice(1, -1);
            return {
              type: "verb",
              mode: "text",
              body: arg,
              star
            };
          }
          if (unicodeSymbols.hasOwnProperty(text[0]) && !src_symbols[this.mode][text[0]]) {
            if (this.settings.strict && this.mode === "math") {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text[0] + '" used in ' + "math mode", nucleus);
            }
            text = unicodeSymbols[text[0]] + text.slice(1);
          }
          const match = combiningDiacriticalMarksEndRegex.exec(text);
          if (match) {
            text = text.substring(0, match.index);
            if (text === "i") {
              text = "ı";
            } else if (text === "j") {
              text = "ȷ";
            }
          }
          let symbol;
          if (src_symbols[this.mode][text]) {
            if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text) >= 0) {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text[0] + '" used in ' + "math mode", nucleus);
            }
            const group = src_symbols[this.mode][text].group;
            const loc = SourceLocation.range(nucleus);
            let s2;
            if (ATOMS.hasOwnProperty(group)) {
              const family = group;
              s2 = {
                type: "atom",
                mode: this.mode,
                family,
                loc,
                text
              };
            } else {
              s2 = {
                type: group,
                mode: this.mode,
                loc,
                text
              };
            }
            symbol = s2;
          } else if (text.charCodeAt(0) >= 128) {
            if (this.settings.strict) {
              if (!supportedCodepoint(text.charCodeAt(0))) {
                this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text[0] + '"' + (" (" + text.charCodeAt(0) + ")"), nucleus);
              } else if (this.mode === "math") {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text[0] + '" used in math mode', nucleus);
              }
            }
            symbol = {
              type: "textord",
              mode: "text",
              loc: SourceLocation.range(nucleus),
              text
            };
          } else {
            return null;
          }
          this.consume();
          if (match) {
            for (let i = 0;i < match[0].length; i++) {
              const accent2 = match[0][i];
              if (!unicodeAccents[accent2]) {
                throw new src_ParseError("Unknown accent ' " + accent2 + "'", nucleus);
              }
              const command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
              if (!command) {
                throw new src_ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
              }
              symbol = {
                type: "accent",
                mode: this.mode,
                loc: SourceLocation.range(nucleus),
                label: command,
                isStretchy: false,
                isShifty: true,
                base: symbol
              };
            }
          }
          return symbol;
        }
      }
      Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
      const parseTree = function(toParse, settings) {
        if (!(typeof toParse === "string" || toParse instanceof String)) {
          throw new TypeError("KaTeX can only parse string typed expression");
        }
        const parser = new Parser(toParse, settings);
        delete parser.gullet.macros.current["\\df@tag"];
        let tree = parser.parse();
        delete parser.gullet.macros.current["\\current@color"];
        delete parser.gullet.macros.current["\\color"];
        if (parser.gullet.macros.get("\\df@tag")) {
          if (!settings.displayMode) {
            throw new src_ParseError("\\tag works only in display equations");
          }
          tree = [{
            type: "tag",
            mode: "text",
            body: tree,
            tag: parser.subparse([new Token("\\df@tag")])
          }];
        }
        return tree;
      };
      var src_parseTree = parseTree;
      let render = function(expression, baseNode, options) {
        baseNode.textContent = "";
        const node = renderToDomTree(expression, options).toNode();
        baseNode.appendChild(node);
      };
      if (typeof document !== "undefined") {
        if (document.compatMode !== "CSS1Compat") {
          typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your " + "website has a suitable doctype.");
          render = function() {
            throw new src_ParseError("KaTeX doesn't work in quirks mode.");
          };
        }
      }
      const renderToString = function(expression, options) {
        const markup = renderToDomTree(expression, options).toMarkup();
        return markup;
      };
      const generateParseTree = function(expression, options) {
        const settings = new Settings(options);
        return src_parseTree(expression, settings);
      };
      const renderError = function(error, expression, options) {
        if (options.throwOnError || !(error instanceof src_ParseError)) {
          throw error;
        }
        const node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
        node.setAttribute("title", error.toString());
        node.setAttribute("style", "color:" + options.errorColor);
        return node;
      };
      const renderToDomTree = function(expression, options) {
        const settings = new Settings(options);
        try {
          const tree = src_parseTree(expression, settings);
          return buildTree(tree, expression, settings);
        } catch (error) {
          return renderError(error, expression, settings);
        }
      };
      const renderToHTMLTree = function(expression, options) {
        const settings = new Settings(options);
        try {
          const tree = src_parseTree(expression, settings);
          return buildHTMLTree(tree, expression, settings);
        } catch (error) {
          return renderError(error, expression, settings);
        }
      };
      const version = "0.16.21";
      const __domTree = {
        Span,
        Anchor,
        SymbolNode,
        SvgNode,
        PathNode,
        LineNode
      };
      var katex = {
        version,
        render,
        renderToString,
        ParseError: src_ParseError,
        SETTINGS_SCHEMA,
        __parse: generateParseTree,
        __renderToDomTree: renderToDomTree,
        __renderToHTMLTree: renderToHTMLTree,
        __setFontMetrics: setFontMetrics,
        __defineSymbol: defineSymbol,
        __defineFunction: defineFunction,
        __defineMacro: defineMacro,
        __domTree
      };
      var katex_webpack = katex;
      __webpack_exports__ = __webpack_exports__["default"];
      return __webpack_exports__;
    }();
  });
});

// node_modules/editorjs-latex/src/index.js
var require_src = __commonJS((exports, module) => {
  var katex = require_katex();

  class EJLaTeX {
    constructor({ data, config }) {
      this.data = data.math;
      if (config && config.css) {
        this.addCss(config.css);
      }
    }
    static get toolbox() {
      return {
        title: "Math",
        icon: '<svg id="Layer_1" enable-background="new 0 0 506.1 506.1" height="512" viewBox="0 0 506.1 506.1" width="512" xmlns="http://www.w3.org/2000/svg"><path d="m489.609 0h-473.118c-9.108 0-16.491 7.383-16.491 16.491v473.118c0 9.107 7.383 16.491 16.491 16.491h473.119c9.107 0 16.49-7.383 16.49-16.491v-473.118c0-9.108-7.383-16.491-16.491-16.491zm-16.49 473.118h-440.138v-440.137h440.138z"/><path d="m367.278 240.136v-62.051c0-8.836-7.163-16-16-16s-16 7.164-16 16v147.377c0 15.024 18.993 21.77 28.457 10.03 34.691 18.107 77.146-6.988 77.146-46.831.001-37.966-39-63.416-73.603-48.525zm20.802 69.327c-11.47 0-20.802-9.332-20.802-20.802s9.332-20.802 20.802-20.802 20.802 9.332 20.802 20.802-9.332 20.802-20.802 20.802z"/><path d="m112.397 200.262h-14.014c-8.836 0-16 7.164-16 16s7.164 16 16 16h14.014c8.291 0 15.037 6.746 15.037 15.037v4.998c-30.589-10.389-62.216 12.536-62.216 44.609 0 34.402 35.954 57.331 67.13 42.629 10.128 9.747 27.086 2.537 27.086-11.521v-80.715c0-25.936-21.101-47.037-47.037-47.037zm-.071 111.752c-8.331 0-15.108-6.777-15.108-15.108s6.777-15.108 15.108-15.108 15.108 6.777 15.108 15.108-6.778 15.108-15.108 15.108z"/><path d="m287.786 243.114c-6.248-6.248-16.379-6.249-22.627 0l-18.11 18.11-18.11-18.11c-6.249-6.249-16.379-6.249-22.627 0-6.249 6.249-6.249 16.379 0 22.627l18.11 18.11-18.11 18.11c-6.248 6.248-6.248 16.379 0 22.627s16.378 6.249 22.627 0l18.11-18.11 18.11 18.11c6.246 6.248 16.377 6.249 22.627 0 6.249-6.249 6.249-16.379 0-22.627l-18.11-18.11 18.11-18.11c6.249-6.248 6.249-16.379 0-22.627z"/></svg>'
      };
    }
    render() {
      const wrapper = document.createElement("div");
      const preview = document.createElement("p");
      const input = document.createElement("input");
      if (typeof katex === "undefined") {
        let errorMessageSpan = document.createElement("span");
        errorMessageSpan.className = "errorMessage";
        errorMessageSpan.innerText = "[Error] KaTeX is not found! Add KaTeX to this webpage to continue!";
        return errorMessageSpan;
      }
      wrapper.classList.add("math-input-wrapper");
      preview.classList.add("math-preview");
      input.classList.add("math-input");
      input.value = this.data ? this.data : "";
      input.setAttribute("placeholder", "Enter LaTeX here");
      katex.render(input.value, preview, {
        throwOnError: false
      });
      input.addEventListener("keyup", (e) => {
        e.preventDefault();
        katex.render(input.value, preview, {
          throwOnError: false
        });
      });
      wrapper.appendChild(preview);
      wrapper.appendChild(input);
      return wrapper;
    }
    save(blockContent) {
      return {
        math: blockContent.childNodes[1].value
      };
    }
    static get isReadOnlySupported() {
      return true;
    }
    addCss(cssRules) {
      const head = document.head;
      let css = document.createElement("style");
      if (css.styleSheet) {
        css.styleSheet.cssText = cssRules;
      } else {
        css.appendChild(document.createTextNode(cssRules));
      }
      head.appendChild(css);
    }
  }
  if (typeof window !== "undefined") {
    window.EJLaTeX = EJLaTeX;
  }
  module.exports = EJLaTeX;
});

// node_modules/@editorjs/editorjs/dist/editorjs.mjs
(function() {
  try {
    if (typeof document < "u") {
      var e = document.createElement("style");
      e.appendChild(document.createTextNode(".ce-hint--align-start{text-align:left}.ce-hint--align-center{text-align:center}.ce-hint__description{opacity:.6;margin-top:3px}")), document.head.appendChild(e);
    }
  } catch (t) {
    console.error("vite-plugin-css-injected-by-js", t);
  }
})();
var Ce = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ke(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Xn(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function o() {
      return this instanceof o ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: true }), Object.keys(n).forEach(function(o) {
    var i = Object.getOwnPropertyDescriptor(n, o);
    Object.defineProperty(t, o, i.get ? i : {
      enumerable: true,
      get: function() {
        return n[o];
      }
    });
  }), t;
}
function ot() {
}
Object.assign(ot, {
  default: ot,
  register: ot,
  revert: function() {
  },
  __esModule: true
});
Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(n) {
  const e = (this.document || this.ownerDocument).querySelectorAll(n);
  let t = e.length;
  for (;--t >= 0 && e.item(t) !== this; )
    ;
  return t > -1;
});
Element.prototype.closest || (Element.prototype.closest = function(n) {
  let e = this;
  if (!document.documentElement.contains(e))
    return null;
  do {
    if (e.matches(n))
      return e;
    e = e.parentElement || e.parentNode;
  } while (e !== null);
  return null;
});
Element.prototype.prepend || (Element.prototype.prepend = function(e) {
  const t = document.createDocumentFragment();
  Array.isArray(e) || (e = [e]), e.forEach((o) => {
    const i = o instanceof Node;
    t.appendChild(i ? o : document.createTextNode(o));
  }), this.insertBefore(t, this.firstChild);
});
Element.prototype.scrollIntoViewIfNeeded || (Element.prototype.scrollIntoViewIfNeeded = function(n) {
  n = arguments.length === 0 ? true : !!n;
  const e = this.parentNode, t = window.getComputedStyle(e, null), o = parseInt(t.getPropertyValue("border-top-width")), i = parseInt(t.getPropertyValue("border-left-width")), s = this.offsetTop - e.offsetTop < e.scrollTop, r = this.offsetTop - e.offsetTop + this.clientHeight - o > e.scrollTop + e.clientHeight, a = this.offsetLeft - e.offsetLeft < e.scrollLeft, l = this.offsetLeft - e.offsetLeft + this.clientWidth - i > e.scrollLeft + e.clientWidth, c = s && !r;
  (s || r) && n && (e.scrollTop = this.offsetTop - e.offsetTop - e.clientHeight / 2 - o + this.clientHeight / 2), (a || l) && n && (e.scrollLeft = this.offsetLeft - e.offsetLeft - e.clientWidth / 2 - i + this.clientWidth / 2), (s || r || a || l) && !n && this.scrollIntoView(c);
});
window.requestIdleCallback = window.requestIdleCallback || function(n) {
  const e = Date.now();
  return setTimeout(function() {
    n({
      didTimeout: false,
      timeRemaining: function() {
        return Math.max(0, 50 - (Date.now() - e));
      }
    });
  }, 1);
};
window.cancelIdleCallback = window.cancelIdleCallback || function(n) {
  clearTimeout(n);
};
var Vn = (n = 21) => crypto.getRandomValues(new Uint8Array(n)).reduce((e, t) => (t &= 63, t < 36 ? e += t.toString(36) : t < 62 ? e += (t - 26).toString(36).toUpperCase() : t > 62 ? e += "-" : e += "_", e), "");
var Lo = /* @__PURE__ */ ((n) => (n.VERBOSE = "VERBOSE", n.INFO = "INFO", n.WARN = "WARN", n.ERROR = "ERROR", n))(Lo || {});
var y = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  ESC: 27,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  DOWN: 40,
  RIGHT: 39,
  DELETE: 46,
  META: 91,
  SLASH: 191
};
var qn = {
  LEFT: 0,
  WHEEL: 1,
  RIGHT: 2,
  BACKWARD: 3,
  FORWARD: 4
};
function Ie(n, e, t = "log", o, i = "color: inherit") {
  if (!("console" in window) || !window.console[t])
    return;
  const s = ["info", "log", "warn", "error"].includes(t), r = [];
  switch (Ie.logLevel) {
    case "ERROR":
      if (t !== "error")
        return;
      break;
    case "WARN":
      if (!["error", "warn"].includes(t))
        return;
      break;
    case "INFO":
      if (!s || n)
        return;
      break;
  }
  o && r.push(o);
  const a = "Editor.js 2.31.0-rc.7", l = `line-height: 1em;
            color: #006FEA;
            display: inline-block;
            font-size: 11px;
            line-height: 1em;
            background-color: #fff;
            padding: 4px 9px;
            border-radius: 30px;
            border: 1px solid rgba(56, 138, 229, 0.16);
            margin: 4px 5px 4px 0;`;
  n && (s ? (r.unshift(l, i), e = `%c${a}%c ${e}`) : e = `( ${a} )${e}`);
  try {
    s ? o ? console[t](`${e} %o`, ...r) : console[t](e, ...r) : console[t](e);
  } catch {
  }
}
Ie.logLevel = "VERBOSE";
function Zn(n) {
  Ie.logLevel = n;
}
var S = Ie.bind(window, false);
var X = Ie.bind(window, true);
function le(n) {
  return Object.prototype.toString.call(n).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
}
function A(n) {
  return le(n) === "function" || le(n) === "asyncfunction";
}
function D(n) {
  return le(n) === "object";
}
function te(n) {
  return le(n) === "string";
}
function Gn(n) {
  return le(n) === "boolean";
}
function yo(n) {
  return le(n) === "number";
}
function wo(n) {
  return le(n) === "undefined";
}
function V(n) {
  return n ? Object.keys(n).length === 0 && n.constructor === Object : true;
}
function Po(n) {
  return n > 47 && n < 58 || n === 32 || n === 13 || n === 229 || n > 64 && n < 91 || n > 95 && n < 112 || n > 185 && n < 193 || n > 218 && n < 223;
}
async function Qn(n, e = () => {
}, t = () => {
}) {
  async function o(i, s, r) {
    try {
      await i.function(i.data), await s(wo(i.data) ? {} : i.data);
    } catch {
      r(wo(i.data) ? {} : i.data);
    }
  }
  return n.reduce(async (i, s) => (await i, o(s, e, t)), Promise.resolve());
}
function No(n) {
  return Array.prototype.slice.call(n);
}
function Fe(n, e) {
  return function() {
    const t = this, o = arguments;
    window.setTimeout(() => n.apply(t, o), e);
  };
}
function Jn(n) {
  return n.name.split(".").pop();
}
function ei(n) {
  return /^[-\w]+\/([-+\w]+|\*)$/.test(n);
}
function Eo(n, e, t) {
  let o;
  return (...i) => {
    const s = this, r = () => {
      o = null, t || n.apply(s, i);
    }, a = t && !o;
    window.clearTimeout(o), o = window.setTimeout(r, e), a && n.apply(s, i);
  };
}
function dt(n, e, t = undefined) {
  let o, i, s, r = null, a = 0;
  t || (t = {});
  const l = function() {
    a = t.leading === false ? 0 : Date.now(), r = null, s = n.apply(o, i), r || (o = i = null);
  };
  return function() {
    const c = Date.now();
    !a && t.leading === false && (a = c);
    const u = e - (c - a);
    return o = this, i = arguments, u <= 0 || u > e ? (r && (clearTimeout(r), r = null), a = c, s = n.apply(o, i), r || (o = i = null)) : !r && t.trailing !== false && (r = setTimeout(l, u)), s;
  };
}
function ti() {
  const n = {
    win: false,
    mac: false,
    x11: false,
    linux: false
  }, e = Object.keys(n).find((t) => window.navigator.appVersion.toLowerCase().indexOf(t) !== -1);
  return e && (n[e] = true), n;
}
function je(n) {
  return n[0].toUpperCase() + n.slice(1);
}
function ut(n, ...e) {
  if (!e.length)
    return n;
  const t = e.shift();
  if (D(n) && D(t))
    for (const o in t)
      D(t[o]) ? (n[o] || Object.assign(n, { [o]: {} }), ut(n[o], t[o])) : Object.assign(n, { [o]: t[o] });
  return ut(n, ...e);
}
function vt(n) {
  const e = ti();
  return n = n.replace(/shift/gi, "⇧").replace(/backspace/gi, "⌫").replace(/enter/gi, "⏎").replace(/up/gi, "↑").replace(/left/gi, "→").replace(/down/gi, "↓").replace(/right/gi, "←").replace(/escape/gi, "⎋").replace(/insert/gi, "Ins").replace(/delete/gi, "␡").replace(/\+/gi, " + "), e.mac ? n = n.replace(/ctrl|cmd/gi, "⌘").replace(/alt/gi, "⌥") : n = n.replace(/cmd/gi, "Ctrl").replace(/windows/gi, "WIN"), n;
}
function oi(n) {
  try {
    return new URL(n).href;
  } catch {
  }
  return n.substring(0, 2) === "//" ? window.location.protocol + n : window.location.origin + n;
}
function ni() {
  return Vn(10);
}
function ii(n) {
  window.open(n, "_blank");
}
function si(n = "") {
  return `${n}${Math.floor(Math.random() * 1e8).toString(16)}`;
}
function ht(n, e, t) {
  const o = `«${e}» is deprecated and will be removed in the next major release. Please use the «${t}» instead.`;
  n && X(o, "warn");
}
function me(n, e, t) {
  const o = t.value ? "value" : "get", i = t[o], s = `#${e}Cache`;
  if (t[o] = function(...r) {
    return this[s] === undefined && (this[s] = i.apply(this, ...r)), this[s];
  }, o === "get" && t.set) {
    const r = t.set;
    t.set = function(a) {
      delete n[s], r.apply(this, a);
    };
  }
  return t;
}
var Ro = 650;
function be() {
  return window.matchMedia(`(max-width: ${Ro}px)`).matches;
}
var pt = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
function ri(n, e) {
  const t = Array.isArray(n) || D(n), o = Array.isArray(e) || D(e);
  return t || o ? JSON.stringify(n) === JSON.stringify(e) : n === e;
}

class d {
  static isSingleTag(e) {
    return e.tagName && [
      "AREA",
      "BASE",
      "BR",
      "COL",
      "COMMAND",
      "EMBED",
      "HR",
      "IMG",
      "INPUT",
      "KEYGEN",
      "LINK",
      "META",
      "PARAM",
      "SOURCE",
      "TRACK",
      "WBR"
    ].includes(e.tagName);
  }
  static isLineBreakTag(e) {
    return e && e.tagName && [
      "BR",
      "WBR"
    ].includes(e.tagName);
  }
  static make(e, t = null, o = {}) {
    const i = document.createElement(e);
    if (Array.isArray(t)) {
      const s = t.filter((r) => r !== undefined);
      i.classList.add(...s);
    } else
      t && i.classList.add(t);
    for (const s in o)
      Object.prototype.hasOwnProperty.call(o, s) && (i[s] = o[s]);
    return i;
  }
  static text(e) {
    return document.createTextNode(e);
  }
  static append(e, t) {
    Array.isArray(t) ? t.forEach((o) => e.appendChild(o)) : e.appendChild(t);
  }
  static prepend(e, t) {
    Array.isArray(t) ? (t = t.reverse(), t.forEach((o) => e.prepend(o))) : e.prepend(t);
  }
  static swap(e, t) {
    const o = document.createElement("div"), i = e.parentNode;
    i.insertBefore(o, e), i.insertBefore(e, t), i.insertBefore(t, o), i.removeChild(o);
  }
  static find(e = document, t) {
    return e.querySelector(t);
  }
  static get(e) {
    return document.getElementById(e);
  }
  static findAll(e = document, t) {
    return e.querySelectorAll(t);
  }
  static get allInputsSelector() {
    return "[contenteditable=true], textarea, input:not([type]), " + ["text", "password", "email", "number", "search", "tel", "url"].map((t) => `input[type="${t}"]`).join(", ");
  }
  static findAllInputs(e) {
    return No(e.querySelectorAll(d.allInputsSelector)).reduce((t, o) => d.isNativeInput(o) || d.containsOnlyInlineElements(o) ? [...t, o] : [...t, ...d.getDeepestBlockElements(o)], []);
  }
  static getDeepestNode(e, t = false) {
    const o = t ? "lastChild" : "firstChild", i = t ? "previousSibling" : "nextSibling";
    if (e && e.nodeType === Node.ELEMENT_NODE && e[o]) {
      let s = e[o];
      if (d.isSingleTag(s) && !d.isNativeInput(s) && !d.isLineBreakTag(s))
        if (s[i])
          s = s[i];
        else if (s.parentNode[i])
          s = s.parentNode[i];
        else
          return s.parentNode;
      return this.getDeepestNode(s, t);
    }
    return e;
  }
  static isElement(e) {
    return yo(e) ? false : e && e.nodeType && e.nodeType === Node.ELEMENT_NODE;
  }
  static isFragment(e) {
    return yo(e) ? false : e && e.nodeType && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
  }
  static isContentEditable(e) {
    return e.contentEditable === "true";
  }
  static isNativeInput(e) {
    const t = [
      "INPUT",
      "TEXTAREA"
    ];
    return e && e.tagName ? t.includes(e.tagName) : false;
  }
  static canSetCaret(e) {
    let t = true;
    if (d.isNativeInput(e))
      switch (e.type) {
        case "file":
        case "checkbox":
        case "radio":
        case "hidden":
        case "submit":
        case "button":
        case "image":
        case "reset":
          t = false;
          break;
      }
    else
      t = d.isContentEditable(e);
    return t;
  }
  static isNodeEmpty(e, t) {
    let o;
    return this.isSingleTag(e) && !this.isLineBreakTag(e) ? false : (this.isElement(e) && this.isNativeInput(e) ? o = e.value : o = e.textContent.replace("​", ""), t && (o = o.replace(new RegExp(t, "g"), "")), o.length === 0);
  }
  static isLeaf(e) {
    return e ? e.childNodes.length === 0 : false;
  }
  static isEmpty(e, t) {
    const o = [e];
    for (;o.length > 0; )
      if (e = o.shift(), !!e) {
        if (this.isLeaf(e) && !this.isNodeEmpty(e, t))
          return false;
        e.childNodes && o.push(...Array.from(e.childNodes));
      }
    return true;
  }
  static isHTMLString(e) {
    const t = d.make("div");
    return t.innerHTML = e, t.childElementCount > 0;
  }
  static getContentLength(e) {
    return d.isNativeInput(e) ? e.value.length : e.nodeType === Node.TEXT_NODE ? e.length : e.textContent.length;
  }
  static get blockElements() {
    return [
      "address",
      "article",
      "aside",
      "blockquote",
      "canvas",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "hr",
      "li",
      "main",
      "nav",
      "noscript",
      "ol",
      "output",
      "p",
      "pre",
      "ruby",
      "section",
      "table",
      "tbody",
      "thead",
      "tr",
      "tfoot",
      "ul",
      "video"
    ];
  }
  static containsOnlyInlineElements(e) {
    let t;
    te(e) ? (t = document.createElement("div"), t.innerHTML = e) : t = e;
    const o = (i) => !d.blockElements.includes(i.tagName.toLowerCase()) && Array.from(i.children).every(o);
    return Array.from(t.children).every(o);
  }
  static getDeepestBlockElements(e) {
    return d.containsOnlyInlineElements(e) ? [e] : Array.from(e.children).reduce((t, o) => [...t, ...d.getDeepestBlockElements(o)], []);
  }
  static getHolder(e) {
    return te(e) ? document.getElementById(e) : e;
  }
  static isAnchor(e) {
    return e.tagName.toLowerCase() === "a";
  }
  static offset(e) {
    const t = e.getBoundingClientRect(), o = window.pageXOffset || document.documentElement.scrollLeft, i = window.pageYOffset || document.documentElement.scrollTop, s = t.top + i, r = t.left + o;
    return {
      top: s,
      left: r,
      bottom: s + t.height,
      right: r + t.width
    };
  }
}
function ai(n) {
  return !/[^\t\n\r ]/.test(n);
}
function li(n) {
  const e = window.getComputedStyle(n), t = parseFloat(e.fontSize), o = parseFloat(e.lineHeight) || t * 1.2, i = parseFloat(e.paddingTop), s = parseFloat(e.borderTopWidth), r = parseFloat(e.marginTop), a = t * 0.8, l = (o - t) / 2;
  return r + s + i + l + a;
}
function Do(n) {
  n.dataset.empty = d.isEmpty(n) ? "true" : "false";
}
var ci = {
  blockTunes: {
    toggler: {
      "Click to tune": "",
      "or drag to move": ""
    }
  },
  inlineToolbar: {
    converter: {
      "Convert to": ""
    }
  },
  toolbar: {
    toolbox: {
      Add: ""
    }
  },
  popover: {
    Filter: "",
    "Nothing found": "",
    "Convert to": ""
  }
};
var di = {
  Text: "",
  Link: "",
  Bold: "",
  Italic: ""
};
var ui = {
  link: {
    "Add a link": ""
  },
  stub: {
    "The block can not be displayed correctly.": ""
  }
};
var hi = {
  delete: {
    Delete: "",
    "Click to delete": ""
  },
  moveUp: {
    "Move up": ""
  },
  moveDown: {
    "Move down": ""
  }
};
var Fo = {
  ui: ci,
  toolNames: di,
  tools: ui,
  blockTunes: hi
};
var jo = class he {
  static ui(e, t) {
    return he._t(e, t);
  }
  static t(e, t) {
    return he._t(e, t);
  }
  static setDictionary(e) {
    he.currentDictionary = e;
  }
  static _t(e, t) {
    const o = he.getNamespace(e);
    return !o || !o[t] ? t : o[t];
  }
  static getNamespace(e) {
    return e.split(".").reduce((o, i) => !o || !Object.keys(o).length ? {} : o[i], he.currentDictionary);
  }
};
jo.currentDictionary = Fo;
var z = jo;

class Ho extends Error {
}

class Oe {
  constructor() {
    this.subscribers = {};
  }
  on(e, t) {
    e in this.subscribers || (this.subscribers[e] = []), this.subscribers[e].push(t);
  }
  once(e, t) {
    e in this.subscribers || (this.subscribers[e] = []);
    const o = (i) => {
      const s = t(i), r = this.subscribers[e].indexOf(o);
      return r !== -1 && this.subscribers[e].splice(r, 1), s;
    };
    this.subscribers[e].push(o);
  }
  emit(e, t) {
    V(this.subscribers) || !this.subscribers[e] || this.subscribers[e].reduce((o, i) => {
      const s = i(o);
      return s !== undefined ? s : o;
    }, t);
  }
  off(e, t) {
    if (this.subscribers[e] === undefined) {
      console.warn(`EventDispatcher .off(): there is no subscribers for event "${e.toString()}". Probably, .off() called before .on()`);
      return;
    }
    for (let o = 0;o < this.subscribers[e].length; o++)
      if (this.subscribers[e][o] === t) {
        delete this.subscribers[e][o];
        break;
      }
  }
  destroy() {
    this.subscribers = {};
  }
}
function J(n) {
  Object.setPrototypeOf(this, {
    get id() {
      return n.id;
    },
    get name() {
      return n.name;
    },
    get config() {
      return n.config;
    },
    get holder() {
      return n.holder;
    },
    get isEmpty() {
      return n.isEmpty;
    },
    get selected() {
      return n.selected;
    },
    set stretched(t) {
      n.stretched = t;
    },
    get stretched() {
      return n.stretched;
    },
    get focusable() {
      return n.focusable;
    },
    call(t, o) {
      return n.call(t, o);
    },
    save() {
      return n.save();
    },
    validate(t) {
      return n.validate(t);
    },
    dispatchChange() {
      n.dispatchChange();
    },
    getActiveToolboxEntry() {
      return n.getActiveToolboxEntry();
    }
  });
}

class _e {
  constructor() {
    this.allListeners = [];
  }
  on(e, t, o, i = false) {
    const s = si("l"), r = {
      id: s,
      element: e,
      eventType: t,
      handler: o,
      options: i
    };
    if (!this.findOne(e, t, o))
      return this.allListeners.push(r), e.addEventListener(t, o, i), s;
  }
  off(e, t, o, i) {
    const s = this.findAll(e, t, o);
    s.forEach((r, a) => {
      const l = this.allListeners.indexOf(s[a]);
      l > -1 && (this.allListeners.splice(l, 1), r.element.removeEventListener(r.eventType, r.handler, r.options));
    });
  }
  offById(e) {
    const t = this.findById(e);
    t && t.element.removeEventListener(t.eventType, t.handler, t.options);
  }
  findOne(e, t, o) {
    const i = this.findAll(e, t, o);
    return i.length > 0 ? i[0] : null;
  }
  findAll(e, t, o) {
    let i;
    const s = e ? this.findByEventTarget(e) : [];
    return e && t && o ? i = s.filter((r) => r.eventType === t && r.handler === o) : e && t ? i = s.filter((r) => r.eventType === t) : i = s, i;
  }
  removeAll() {
    this.allListeners.map((e) => {
      e.element.removeEventListener(e.eventType, e.handler, e.options);
    }), this.allListeners = [];
  }
  destroy() {
    this.removeAll();
  }
  findByEventTarget(e) {
    return this.allListeners.filter((t) => {
      if (t.element === e)
        return t;
    });
  }
  findByType(e) {
    return this.allListeners.filter((t) => {
      if (t.eventType === e)
        return t;
    });
  }
  findByHandler(e) {
    return this.allListeners.filter((t) => {
      if (t.handler === e)
        return t;
    });
  }
  findById(e) {
    return this.allListeners.find((t) => t.id === e);
  }
}

class E {
  constructor({ config: e, eventsDispatcher: t }) {
    if (this.nodes = {}, this.listeners = new _e, this.readOnlyMutableListeners = {
      on: (o, i, s, r = false) => {
        this.mutableListenerIds.push(this.listeners.on(o, i, s, r));
      },
      clearAll: () => {
        for (const o of this.mutableListenerIds)
          this.listeners.offById(o);
        this.mutableListenerIds = [];
      }
    }, this.mutableListenerIds = [], new.target === E)
      throw new TypeError("Constructors for abstract class Module are not allowed.");
    this.config = e, this.eventsDispatcher = t;
  }
  set state(e) {
    this.Editor = e;
  }
  removeAllNodes() {
    for (const e in this.nodes) {
      const t = this.nodes[e];
      t instanceof HTMLElement && t.remove();
    }
  }
  get isRtl() {
    return this.config.i18n.direction === "rtl";
  }
}

class b {
  constructor() {
    this.instance = null, this.selection = null, this.savedSelectionRange = null, this.isFakeBackgroundEnabled = false, this.commandBackground = "backColor", this.commandRemoveFormat = "removeFormat";
  }
  static get CSS() {
    return {
      editorWrapper: "codex-editor",
      editorZone: "codex-editor__redactor"
    };
  }
  static get anchorNode() {
    const e = window.getSelection();
    return e ? e.anchorNode : null;
  }
  static get anchorElement() {
    const e = window.getSelection();
    if (!e)
      return null;
    const t = e.anchorNode;
    return t ? d.isElement(t) ? t : t.parentElement : null;
  }
  static get anchorOffset() {
    const e = window.getSelection();
    return e ? e.anchorOffset : null;
  }
  static get isCollapsed() {
    const e = window.getSelection();
    return e ? e.isCollapsed : null;
  }
  static get isAtEditor() {
    return this.isSelectionAtEditor(b.get());
  }
  static isSelectionAtEditor(e) {
    if (!e)
      return false;
    let t = e.anchorNode || e.focusNode;
    t && t.nodeType === Node.TEXT_NODE && (t = t.parentNode);
    let o = null;
    return t && t instanceof Element && (o = t.closest(`.${b.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : false;
  }
  static isRangeAtEditor(e) {
    if (!e)
      return;
    let t = e.startContainer;
    t && t.nodeType === Node.TEXT_NODE && (t = t.parentNode);
    let o = null;
    return t && t instanceof Element && (o = t.closest(`.${b.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : false;
  }
  static get isSelectionExists() {
    return !!b.get().anchorNode;
  }
  static get range() {
    return this.getRangeFromSelection(this.get());
  }
  static getRangeFromSelection(e) {
    return e && e.rangeCount ? e.getRangeAt(0) : null;
  }
  static get rect() {
    let e = document.selection, t, o = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    if (e && e.type !== "Control")
      return e = e, t = e.createRange(), o.x = t.boundingLeft, o.y = t.boundingTop, o.width = t.boundingWidth, o.height = t.boundingHeight, o;
    if (!window.getSelection)
      return S("Method window.getSelection is not supported", "warn"), o;
    if (e = window.getSelection(), e.rangeCount === null || isNaN(e.rangeCount))
      return S("Method SelectionUtils.rangeCount is not supported", "warn"), o;
    if (e.rangeCount === 0)
      return o;
    if (t = e.getRangeAt(0).cloneRange(), t.getBoundingClientRect && (o = t.getBoundingClientRect()), o.x === 0 && o.y === 0) {
      const i = document.createElement("span");
      if (i.getBoundingClientRect) {
        i.appendChild(document.createTextNode("​")), t.insertNode(i), o = i.getBoundingClientRect();
        const s = i.parentNode;
        s.removeChild(i), s.normalize();
      }
    }
    return o;
  }
  static get text() {
    return window.getSelection ? window.getSelection().toString() : "";
  }
  static get() {
    return window.getSelection();
  }
  static setCursor(e, t = 0) {
    const o = document.createRange(), i = window.getSelection();
    return d.isNativeInput(e) ? d.canSetCaret(e) ? (e.focus(), e.selectionStart = e.selectionEnd = t, e.getBoundingClientRect()) : undefined : (o.setStart(e, t), o.setEnd(e, t), i.removeAllRanges(), i.addRange(o), o.getBoundingClientRect());
  }
  static isRangeInsideContainer(e) {
    const t = b.range;
    return t === null ? false : e.contains(t.startContainer);
  }
  static addFakeCursor() {
    const e = b.range;
    if (e === null)
      return;
    const t = d.make("span", "codex-editor__fake-cursor");
    t.dataset.mutationFree = "true", e.collapse(), e.insertNode(t);
  }
  static isFakeCursorInsideContainer(e) {
    return d.find(e, ".codex-editor__fake-cursor") !== null;
  }
  static removeFakeCursor(e = document.body) {
    const t = d.find(e, ".codex-editor__fake-cursor");
    t && t.remove();
  }
  removeFakeBackground() {
    this.isFakeBackgroundEnabled && (this.isFakeBackgroundEnabled = false, document.execCommand(this.commandRemoveFormat));
  }
  setFakeBackground() {
    document.execCommand(this.commandBackground, false, "#a8d6ff"), this.isFakeBackgroundEnabled = true;
  }
  save() {
    this.savedSelectionRange = b.range;
  }
  restore() {
    if (!this.savedSelectionRange)
      return;
    const e = window.getSelection();
    e.removeAllRanges(), e.addRange(this.savedSelectionRange);
  }
  clearSaved() {
    this.savedSelectionRange = null;
  }
  collapseToEnd() {
    const e = window.getSelection(), t = document.createRange();
    t.selectNodeContents(e.focusNode), t.collapse(false), e.removeAllRanges(), e.addRange(t);
  }
  findParentTag(e, t, o = 10) {
    const i = window.getSelection();
    let s = null;
    return !i || !i.anchorNode || !i.focusNode ? null : ([
      i.anchorNode,
      i.focusNode
    ].forEach((a) => {
      let l = o;
      for (;l > 0 && a.parentNode && !(a.tagName === e && (s = a, t && a.classList && !a.classList.contains(t) && (s = null), s)); )
        a = a.parentNode, l--;
    }), s);
  }
  expandToTag(e) {
    const t = window.getSelection();
    t.removeAllRanges();
    const o = document.createRange();
    o.selectNodeContents(e), t.addRange(o);
  }
}
function pi(n, e) {
  const { type: t, target: o, addedNodes: i, removedNodes: s } = n;
  return n.type === "attributes" && n.attributeName === "data-empty" ? false : !!(e.contains(o) || t === "childList" && (Array.from(i).some((l) => l === e) || Array.from(s).some((l) => l === e)));
}
var ft = "redactor dom changed";
var $o = "block changed";
var zo = "fake cursor is about to be toggled";
var Uo = "fake cursor have been set";
var Te = "editor mobile layout toggled";
function gt(n, e) {
  if (!n.conversionConfig)
    return false;
  const t = n.conversionConfig[e];
  return A(t) || te(t);
}
function He(n, e) {
  return gt(n.tool, e);
}
function Wo(n, e) {
  return Object.entries(n).some(([t, o]) => e[t] && ri(e[t], o));
}
async function Yo(n, e) {
  const o = (await n.save()).data, i = e.find((s) => s.name === n.name);
  return i !== undefined && !gt(i, "export") ? [] : e.reduce((s, r) => {
    if (!gt(r, "import") || r.toolbox === undefined)
      return s;
    const a = r.toolbox.filter((l) => {
      if (V(l) || l.icon === undefined)
        return false;
      if (l.data !== undefined) {
        if (Wo(l.data, o))
          return false;
      } else if (r.name === n.name)
        return false;
      return true;
    });
    return s.push({
      ...r,
      toolbox: a
    }), s;
  }, []);
}
function xo(n, e) {
  return n.mergeable ? n.name === e.name ? true : He(e, "export") && He(n, "import") : false;
}
function fi(n, e) {
  const t = e == null ? undefined : e.export;
  return A(t) ? t(n) : te(t) ? n[t] : (t !== undefined && S("Conversion «export» property must be a string or function. String means key of saved data object to export. Function should export processed string to export."), "");
}
function Bo(n, e, t) {
  const o = e == null ? undefined : e.import;
  return A(o) ? o(n, t) : te(o) ? {
    [o]: n
  } : (o !== undefined && S("Conversion «import» property must be a string or function. String means key of tool data to import. Function accepts a imported string and return composed tool data."), {});
}
var _ = /* @__PURE__ */ ((n) => (n.Default = "default", n.Separator = "separator", n.Html = "html", n))(_ || {});
var ee = /* @__PURE__ */ ((n) => (n.APPEND_CALLBACK = "appendCallback", n.RENDERED = "rendered", n.MOVED = "moved", n.UPDATED = "updated", n.REMOVED = "removed", n.ON_PASTE = "onPaste", n))(ee || {});

class R extends Oe {
  constructor({
    id: e = ni(),
    data: t,
    tool: o,
    readOnly: i,
    tunesData: s
  }, r) {
    super(), this.cachedInputs = [], this.toolRenderedElement = null, this.tunesInstances = /* @__PURE__ */ new Map, this.defaultTunesInstances = /* @__PURE__ */ new Map, this.unavailableTunesData = {}, this.inputIndex = 0, this.editorEventBus = null, this.handleFocus = () => {
      this.dropInputsCache(), this.updateCurrentInput();
    }, this.didMutated = (a = undefined) => {
      const l = a === undefined, c = a instanceof InputEvent;
      !l && !c && this.detectToolRootChange(a);
      let u;
      l || c ? u = true : u = !(a.length > 0 && a.every((p) => {
        const { addedNodes: g, removedNodes: f, target: v } = p;
        return [
          ...Array.from(g),
          ...Array.from(f),
          v
        ].some((T) => (d.isElement(T) || (T = T.parentElement), T && T.closest('[data-mutation-free="true"]') !== null));
      })), u && (this.dropInputsCache(), this.updateCurrentInput(), this.toggleInputsEmptyMark(), this.call("updated"), this.emit("didMutated", this));
    }, this.name = o.name, this.id = e, this.settings = o.settings, this.config = o.settings.config || {}, this.editorEventBus = r || null, this.blockAPI = new J(this), this.tool = o, this.toolInstance = o.create(t, this.blockAPI, i), this.tunes = o.tunes, this.composeTunes(s), this.holder = this.compose(), window.requestIdleCallback(() => {
      this.watchBlockMutations(), this.addInputEvents(), this.toggleInputsEmptyMark();
    });
  }
  static get CSS() {
    return {
      wrapper: "ce-block",
      wrapperStretched: "ce-block--stretched",
      content: "ce-block__content",
      selected: "ce-block--selected",
      dropTarget: "ce-block--drop-target"
    };
  }
  get inputs() {
    if (this.cachedInputs.length !== 0)
      return this.cachedInputs;
    const e = d.findAllInputs(this.holder);
    return this.inputIndex > e.length - 1 && (this.inputIndex = e.length - 1), this.cachedInputs = e, e;
  }
  get currentInput() {
    return this.inputs[this.inputIndex];
  }
  set currentInput(e) {
    const t = this.inputs.findIndex((o) => o === e || o.contains(e));
    t !== -1 && (this.inputIndex = t);
  }
  get firstInput() {
    return this.inputs[0];
  }
  get lastInput() {
    const e = this.inputs;
    return e[e.length - 1];
  }
  get nextInput() {
    return this.inputs[this.inputIndex + 1];
  }
  get previousInput() {
    return this.inputs[this.inputIndex - 1];
  }
  get data() {
    return this.save().then((e) => e && !V(e.data) ? e.data : {});
  }
  get sanitize() {
    return this.tool.sanitizeConfig;
  }
  get mergeable() {
    return A(this.toolInstance.merge);
  }
  get focusable() {
    return this.inputs.length !== 0;
  }
  get isEmpty() {
    const e = d.isEmpty(this.pluginsContent, "/"), t = !this.hasMedia;
    return e && t;
  }
  get hasMedia() {
    const e = [
      "img",
      "iframe",
      "video",
      "audio",
      "source",
      "input",
      "textarea",
      "twitterwidget"
    ];
    return !!this.holder.querySelector(e.join(","));
  }
  set selected(e) {
    var i, s;
    this.holder.classList.toggle(R.CSS.selected, e);
    const t = e === true && b.isRangeInsideContainer(this.holder), o = e === false && b.isFakeCursorInsideContainer(this.holder);
    (t || o) && ((i = this.editorEventBus) == null || i.emit(zo, { state: e }), t ? b.addFakeCursor() : b.removeFakeCursor(this.holder), (s = this.editorEventBus) == null || s.emit(Uo, { state: e }));
  }
  get selected() {
    return this.holder.classList.contains(R.CSS.selected);
  }
  set stretched(e) {
    this.holder.classList.toggle(R.CSS.wrapperStretched, e);
  }
  get stretched() {
    return this.holder.classList.contains(R.CSS.wrapperStretched);
  }
  set dropTarget(e) {
    this.holder.classList.toggle(R.CSS.dropTarget, e);
  }
  get pluginsContent() {
    return this.toolRenderedElement;
  }
  call(e, t) {
    if (A(this.toolInstance[e])) {
      e === "appendCallback" && S("`appendCallback` hook is deprecated and will be removed in the next major release. Use `rendered` hook instead", "warn");
      try {
        this.toolInstance[e].call(this.toolInstance, t);
      } catch (o) {
        S(`Error during '${e}' call: ${o.message}`, "error");
      }
    }
  }
  async mergeWith(e) {
    await this.toolInstance.merge(e);
  }
  async save() {
    const e = await this.toolInstance.save(this.pluginsContent), t = this.unavailableTunesData;
    [
      ...this.tunesInstances.entries(),
      ...this.defaultTunesInstances.entries()
    ].forEach(([s, r]) => {
      if (A(r.save))
        try {
          t[s] = r.save();
        } catch (a) {
          S(`Tune ${r.constructor.name} save method throws an Error %o`, "warn", a);
        }
    });
    const o = window.performance.now();
    let i;
    return Promise.resolve(e).then((s) => (i = window.performance.now(), {
      id: this.id,
      tool: this.name,
      data: s,
      tunes: t,
      time: i - o
    })).catch((s) => {
      S(`Saving process for ${this.name} tool failed due to the ${s}`, "log", "red");
    });
  }
  async validate(e) {
    let t = true;
    return this.toolInstance.validate instanceof Function && (t = await this.toolInstance.validate(e)), t;
  }
  getTunes() {
    const e = [], t = [], o = typeof this.toolInstance.renderSettings == "function" ? this.toolInstance.renderSettings() : [];
    return d.isElement(o) ? e.push({
      type: _.Html,
      element: o
    }) : Array.isArray(o) ? e.push(...o) : e.push(o), [
      ...this.tunesInstances.values(),
      ...this.defaultTunesInstances.values()
    ].map((s) => s.render()).forEach((s) => {
      d.isElement(s) ? t.push({
        type: _.Html,
        element: s
      }) : Array.isArray(s) ? t.push(...s) : t.push(s);
    }), {
      toolTunes: e,
      commonTunes: t
    };
  }
  updateCurrentInput() {
    this.currentInput = d.isNativeInput(document.activeElement) || !b.anchorNode ? document.activeElement : b.anchorNode;
  }
  dispatchChange() {
    this.didMutated();
  }
  destroy() {
    this.unwatchBlockMutations(), this.removeInputEvents(), super.destroy(), A(this.toolInstance.destroy) && this.toolInstance.destroy();
  }
  async getActiveToolboxEntry() {
    const e = this.tool.toolbox;
    if (e.length === 1)
      return Promise.resolve(this.tool.toolbox[0]);
    const t = await this.data, o = e;
    return o == null ? undefined : o.find((i) => Wo(i.data, t));
  }
  async exportDataAsString() {
    const e = await this.data;
    return fi(e, this.tool.conversionConfig);
  }
  compose() {
    const e = d.make("div", R.CSS.wrapper), t = d.make("div", R.CSS.content), o = this.toolInstance.render();
    e.setAttribute("data-cy", "block-wrapper"), e.dataset.id = this.id, this.toolRenderedElement = o, t.appendChild(this.toolRenderedElement);
    let i = t;
    return [...this.tunesInstances.values(), ...this.defaultTunesInstances.values()].forEach((s) => {
      if (A(s.wrap))
        try {
          i = s.wrap(i);
        } catch (r) {
          S(`Tune ${s.constructor.name} wrap method throws an Error %o`, "warn", r);
        }
    }), e.appendChild(i), e;
  }
  composeTunes(e) {
    Array.from(this.tunes.values()).forEach((t) => {
      (t.isInternal ? this.defaultTunesInstances : this.tunesInstances).set(t.name, t.create(e[t.name], this.blockAPI));
    }), Object.entries(e).forEach(([t, o]) => {
      this.tunesInstances.has(t) || (this.unavailableTunesData[t] = o);
    });
  }
  addInputEvents() {
    this.inputs.forEach((e) => {
      e.addEventListener("focus", this.handleFocus), d.isNativeInput(e) && e.addEventListener("input", this.didMutated);
    });
  }
  removeInputEvents() {
    this.inputs.forEach((e) => {
      e.removeEventListener("focus", this.handleFocus), d.isNativeInput(e) && e.removeEventListener("input", this.didMutated);
    });
  }
  watchBlockMutations() {
    var e;
    this.redactorDomChangedCallback = (t) => {
      const { mutations: o } = t;
      o.some((s) => pi(s, this.toolRenderedElement)) && this.didMutated(o);
    }, (e = this.editorEventBus) == null || e.on(ft, this.redactorDomChangedCallback);
  }
  unwatchBlockMutations() {
    var e;
    (e = this.editorEventBus) == null || e.off(ft, this.redactorDomChangedCallback);
  }
  detectToolRootChange(e) {
    e.forEach((t) => {
      if (Array.from(t.removedNodes).includes(this.toolRenderedElement)) {
        const i = t.addedNodes[t.addedNodes.length - 1];
        this.toolRenderedElement = i;
      }
    });
  }
  dropInputsCache() {
    this.cachedInputs = [];
  }
  toggleInputsEmptyMark() {
    this.inputs.forEach(Do);
  }
}

class gi extends E {
  constructor() {
    super(...arguments), this.insert = (e = this.config.defaultBlock, t = {}, o = {}, i, s, r, a) => {
      const l = this.Editor.BlockManager.insert({
        id: a,
        tool: e,
        data: t,
        index: i,
        needToFocus: s,
        replace: r
      });
      return new J(l);
    }, this.composeBlockData = async (e) => {
      const t = this.Editor.Tools.blockTools.get(e);
      return new R({
        tool: t,
        api: this.Editor.API,
        readOnly: true,
        data: {},
        tunesData: {}
      }).data;
    }, this.update = async (e, t, o) => {
      const { BlockManager: i } = this.Editor, s = i.getBlockById(e);
      if (s === undefined)
        throw new Error(`Block with id "${e}" not found`);
      const r = await i.update(s, t, o);
      return new J(r);
    }, this.convert = async (e, t, o) => {
      var h, p;
      const { BlockManager: i, Tools: s } = this.Editor, r = i.getBlockById(e);
      if (!r)
        throw new Error(`Block with id "${e}" not found`);
      const a = s.blockTools.get(r.name), l = s.blockTools.get(t);
      if (!l)
        throw new Error(`Block Tool with type "${t}" not found`);
      const c = ((h = a == null ? undefined : a.conversionConfig) == null ? undefined : h.export) !== undefined, u = ((p = l.conversionConfig) == null ? undefined : p.import) !== undefined;
      if (c && u) {
        const g = await i.convert(r, t, o);
        return new J(g);
      } else {
        const g = [
          c ? false : je(r.name),
          u ? false : je(t)
        ].filter(Boolean).join(" and ");
        throw new Error(`Conversion from "${r.name}" to "${t}" is not possible. ${g} tool(s) should provide a "conversionConfig"`);
      }
    }, this.insertMany = (e, t = this.Editor.BlockManager.blocks.length - 1) => {
      this.validateIndex(t);
      const o = e.map(({ id: i, type: s, data: r }) => this.Editor.BlockManager.composeBlock({
        id: i,
        tool: s || this.config.defaultBlock,
        data: r
      }));
      return this.Editor.BlockManager.insertMany(o, t), o.map((i) => new J(i));
    };
  }
  get methods() {
    return {
      clear: () => this.clear(),
      render: (e) => this.render(e),
      renderFromHTML: (e) => this.renderFromHTML(e),
      delete: (e) => this.delete(e),
      swap: (e, t) => this.swap(e, t),
      move: (e, t) => this.move(e, t),
      getBlockByIndex: (e) => this.getBlockByIndex(e),
      getById: (e) => this.getById(e),
      getCurrentBlockIndex: () => this.getCurrentBlockIndex(),
      getBlockIndex: (e) => this.getBlockIndex(e),
      getBlocksCount: () => this.getBlocksCount(),
      getBlockByElement: (e) => this.getBlockByElement(e),
      stretchBlock: (e, t = true) => this.stretchBlock(e, t),
      insertNewBlock: () => this.insertNewBlock(),
      insert: this.insert,
      insertMany: this.insertMany,
      update: this.update,
      composeBlockData: this.composeBlockData,
      convert: this.convert
    };
  }
  getBlocksCount() {
    return this.Editor.BlockManager.blocks.length;
  }
  getCurrentBlockIndex() {
    return this.Editor.BlockManager.currentBlockIndex;
  }
  getBlockIndex(e) {
    const t = this.Editor.BlockManager.getBlockById(e);
    if (!t) {
      X("There is no block with id `" + e + "`", "warn");
      return;
    }
    return this.Editor.BlockManager.getBlockIndex(t);
  }
  getBlockByIndex(e) {
    const t = this.Editor.BlockManager.getBlockByIndex(e);
    if (t === undefined) {
      X("There is no block at index `" + e + "`", "warn");
      return;
    }
    return new J(t);
  }
  getById(e) {
    const t = this.Editor.BlockManager.getBlockById(e);
    return t === undefined ? (X("There is no block with id `" + e + "`", "warn"), null) : new J(t);
  }
  getBlockByElement(e) {
    const t = this.Editor.BlockManager.getBlock(e);
    if (t === undefined) {
      X("There is no block corresponding to element `" + e + "`", "warn");
      return;
    }
    return new J(t);
  }
  swap(e, t) {
    S("`blocks.swap()` method is deprecated and will be removed in the next major release. Use `block.move()` method instead", "info"), this.Editor.BlockManager.swap(e, t);
  }
  move(e, t) {
    this.Editor.BlockManager.move(e, t);
  }
  delete(e = this.Editor.BlockManager.currentBlockIndex) {
    try {
      const t = this.Editor.BlockManager.getBlockByIndex(e);
      this.Editor.BlockManager.removeBlock(t);
    } catch (t) {
      X(t, "warn");
      return;
    }
    this.Editor.BlockManager.blocks.length === 0 && this.Editor.BlockManager.insert(), this.Editor.BlockManager.currentBlock && this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END), this.Editor.Toolbar.close();
  }
  async clear() {
    await this.Editor.BlockManager.clear(true), this.Editor.InlineToolbar.close();
  }
  async render(e) {
    if (e === undefined || e.blocks === undefined)
      throw new Error("Incorrect data passed to the render() method");
    this.Editor.ModificationsObserver.disable(), await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(e.blocks), this.Editor.ModificationsObserver.enable();
  }
  renderFromHTML(e) {
    return this.Editor.BlockManager.clear(), this.Editor.Paste.processText(e, true);
  }
  stretchBlock(e, t = true) {
    ht(true, "blocks.stretchBlock()", "BlockAPI");
    const o = this.Editor.BlockManager.getBlockByIndex(e);
    o && (o.stretched = t);
  }
  insertNewBlock() {
    S("Method blocks.insertNewBlock() is deprecated and it will be removed in the next major release. Use blocks.insert() instead.", "warn"), this.insert();
  }
  validateIndex(e) {
    if (typeof e != "number")
      throw new Error("Index should be a number");
    if (e < 0)
      throw new Error("Index should be greater than or equal to 0");
    if (e === null)
      throw new Error("Index should be greater than or equal to 0");
  }
}
function mi(n, e) {
  return typeof n == "number" ? e.BlockManager.getBlockByIndex(n) : typeof n == "string" ? e.BlockManager.getBlockById(n) : e.BlockManager.getBlockById(n.id);
}

class bi extends E {
  constructor() {
    super(...arguments), this.setToFirstBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.firstBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.firstBlock, e, t), true) : false, this.setToLastBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.lastBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.lastBlock, e, t), true) : false, this.setToPreviousBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.previousBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.previousBlock, e, t), true) : false, this.setToNextBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.nextBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.nextBlock, e, t), true) : false, this.setToBlock = (e, t = this.Editor.Caret.positions.DEFAULT, o = 0) => {
      const i = mi(e, this.Editor);
      return i === undefined ? false : (this.Editor.Caret.setToBlock(i, t, o), true);
    }, this.focus = (e = false) => e ? this.setToLastBlock(this.Editor.Caret.positions.END) : this.setToFirstBlock(this.Editor.Caret.positions.START);
  }
  get methods() {
    return {
      setToFirstBlock: this.setToFirstBlock,
      setToLastBlock: this.setToLastBlock,
      setToPreviousBlock: this.setToPreviousBlock,
      setToNextBlock: this.setToNextBlock,
      setToBlock: this.setToBlock,
      focus: this.focus
    };
  }
}

class vi extends E {
  get methods() {
    return {
      emit: (e, t) => this.emit(e, t),
      off: (e, t) => this.off(e, t),
      on: (e, t) => this.on(e, t)
    };
  }
  on(e, t) {
    this.eventsDispatcher.on(e, t);
  }
  emit(e, t) {
    this.eventsDispatcher.emit(e, t);
  }
  off(e, t) {
    this.eventsDispatcher.off(e, t);
  }
}

class kt extends E {
  static getNamespace(e, t) {
    return t ? `blockTunes.${e}` : `tools.${e}`;
  }
  get methods() {
    return {
      t: () => {
        X("I18n.t() method can be accessed only from Tools", "warn");
      }
    };
  }
  getMethodsForTool(e, t) {
    return Object.assign(this.methods, {
      t: (o) => z.t(kt.getNamespace(e, t), o)
    });
  }
}

class ki extends E {
  get methods() {
    return {
      blocks: this.Editor.BlocksAPI.methods,
      caret: this.Editor.CaretAPI.methods,
      tools: this.Editor.ToolsAPI.methods,
      events: this.Editor.EventsAPI.methods,
      listeners: this.Editor.ListenersAPI.methods,
      notifier: this.Editor.NotifierAPI.methods,
      sanitizer: this.Editor.SanitizerAPI.methods,
      saver: this.Editor.SaverAPI.methods,
      selection: this.Editor.SelectionAPI.methods,
      styles: this.Editor.StylesAPI.classes,
      toolbar: this.Editor.ToolbarAPI.methods,
      inlineToolbar: this.Editor.InlineToolbarAPI.methods,
      tooltip: this.Editor.TooltipAPI.methods,
      i18n: this.Editor.I18nAPI.methods,
      readOnly: this.Editor.ReadOnlyAPI.methods,
      ui: this.Editor.UiAPI.methods
    };
  }
  getMethodsForTool(e, t) {
    return Object.assign(this.methods, {
      i18n: this.Editor.I18nAPI.getMethodsForTool(e, t)
    });
  }
}

class yi extends E {
  get methods() {
    return {
      close: () => this.close(),
      open: () => this.open()
    };
  }
  open() {
    this.Editor.InlineToolbar.tryToShow();
  }
  close() {
    this.Editor.InlineToolbar.close();
  }
}

class wi extends E {
  get methods() {
    return {
      on: (e, t, o, i) => this.on(e, t, o, i),
      off: (e, t, o, i) => this.off(e, t, o, i),
      offById: (e) => this.offById(e)
    };
  }
  on(e, t, o, i) {
    return this.listeners.on(e, t, o, i);
  }
  off(e, t, o, i) {
    this.listeners.off(e, t, o, i);
  }
  offById(e) {
    this.listeners.offById(e);
  }
}
var Ko = { exports: {} };
(function(n, e) {
  (function(t, o) {
    n.exports = o();
  })(window, function() {
    return function(t) {
      var o = {};
      function i(s) {
        if (o[s])
          return o[s].exports;
        var r = o[s] = { i: s, l: false, exports: {} };
        return t[s].call(r.exports, r, r.exports, i), r.l = true, r.exports;
      }
      return i.m = t, i.c = o, i.d = function(s, r, a) {
        i.o(s, r) || Object.defineProperty(s, r, { enumerable: true, get: a });
      }, i.r = function(s) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(s, "__esModule", { value: true });
      }, i.t = function(s, r) {
        if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == "object" && s && s.__esModule)
          return s;
        var a = /* @__PURE__ */ Object.create(null);
        if (i.r(a), Object.defineProperty(a, "default", { enumerable: true, value: s }), 2 & r && typeof s != "string")
          for (var l in s)
            i.d(a, l, function(c) {
              return s[c];
            }.bind(null, l));
        return a;
      }, i.n = function(s) {
        var r = s && s.__esModule ? function() {
          return s.default;
        } : function() {
          return s;
        };
        return i.d(r, "a", r), r;
      }, i.o = function(s, r) {
        return Object.prototype.hasOwnProperty.call(s, r);
      }, i.p = "/", i(i.s = 0);
    }([function(t, o, i) {
      i(1), t.exports = function() {
        /*!
               * Codex JavaScript Notification module
               * https://github.com/codex-team/js-notifier
               */
        var s = i(6), r = "cdx-notify--bounce-in", a = null;
        return { show: function(l) {
          if (l.message) {
            (function() {
              if (a)
                return true;
              a = s.getWrapper(), document.body.appendChild(a);
            })();
            var c = null, u = l.time || 8000;
            switch (l.type) {
              case "confirm":
                c = s.confirm(l);
                break;
              case "prompt":
                c = s.prompt(l);
                break;
              default:
                c = s.alert(l), window.setTimeout(function() {
                  c.remove();
                }, u);
            }
            a.appendChild(c), c.classList.add(r);
          }
        } };
      }();
    }, function(t, o, i) {
      var s = i(2);
      typeof s == "string" && (s = [[t.i, s, ""]]);
      var r = { hmr: true, transform: undefined, insertInto: undefined };
      i(4)(s, r), s.locals && (t.exports = s.locals);
    }, function(t, o, i) {
      (t.exports = i(3)(false)).push([t.i, `.cdx-notify--error{background:#fffbfb!important}.cdx-notify--error::before{background:#fb5d5d!important}.cdx-notify__input{max-width:130px;padding:5px 10px;background:#f7f7f7;border:0;border-radius:3px;font-size:13px;color:#656b7c;outline:0}.cdx-notify__input:-ms-input-placeholder{color:#656b7c}.cdx-notify__input::placeholder{color:#656b7c}.cdx-notify__input:focus:-ms-input-placeholder{color:rgba(101,107,124,.3)}.cdx-notify__input:focus::placeholder{color:rgba(101,107,124,.3)}.cdx-notify__button{border:none;border-radius:3px;font-size:13px;padding:5px 10px;cursor:pointer}.cdx-notify__button:last-child{margin-left:10px}.cdx-notify__button--cancel{background:#f2f5f7;box-shadow:0 2px 1px 0 rgba(16,19,29,0);color:#656b7c}.cdx-notify__button--cancel:hover{background:#eee}.cdx-notify__button--confirm{background:#34c992;box-shadow:0 1px 1px 0 rgba(18,49,35,.05);color:#fff}.cdx-notify__button--confirm:hover{background:#33b082}.cdx-notify__btns-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;margin-top:5px}.cdx-notify__cross{position:absolute;top:5px;right:5px;width:10px;height:10px;padding:5px;opacity:.54;cursor:pointer}.cdx-notify__cross::after,.cdx-notify__cross::before{content:'';position:absolute;left:9px;top:5px;height:12px;width:2px;background:#575d67}.cdx-notify__cross::before{transform:rotate(-45deg)}.cdx-notify__cross::after{transform:rotate(45deg)}.cdx-notify__cross:hover{opacity:1}.cdx-notifies{position:fixed;z-index:2;bottom:20px;left:20px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",sans-serif}.cdx-notify{position:relative;width:220px;margin-top:15px;padding:13px 16px;background:#fff;box-shadow:0 11px 17px 0 rgba(23,32,61,.13);border-radius:5px;font-size:14px;line-height:1.4em;word-wrap:break-word}.cdx-notify::before{content:'';position:absolute;display:block;top:0;left:0;width:3px;height:calc(100% - 6px);margin:3px;border-radius:5px;background:0 0}@keyframes bounceIn{0%{opacity:0;transform:scale(.3)}50%{opacity:1;transform:scale(1.05)}70%{transform:scale(.9)}100%{transform:scale(1)}}.cdx-notify--bounce-in{animation-name:bounceIn;animation-duration:.6s;animation-iteration-count:1}.cdx-notify--success{background:#fafffe!important}.cdx-notify--success::before{background:#41ffb1!important}`, ""]);
    }, function(t, o) {
      t.exports = function(i) {
        var s = [];
        return s.toString = function() {
          return this.map(function(r) {
            var a = function(l, c) {
              var u = l[1] || "", h = l[3];
              if (!h)
                return u;
              if (c && typeof btoa == "function") {
                var p = (f = h, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(f)))) + " */"), g = h.sources.map(function(v) {
                  return "/*# sourceURL=" + h.sourceRoot + v + " */";
                });
                return [u].concat(g).concat([p]).join(`
`);
              }
              var f;
              return [u].join(`
`);
            }(r, i);
            return r[2] ? "@media " + r[2] + "{" + a + "}" : a;
          }).join("");
        }, s.i = function(r, a) {
          typeof r == "string" && (r = [[null, r, ""]]);
          for (var l = {}, c = 0;c < this.length; c++) {
            var u = this[c][0];
            typeof u == "number" && (l[u] = true);
          }
          for (c = 0;c < r.length; c++) {
            var h = r[c];
            typeof h[0] == "number" && l[h[0]] || (a && !h[2] ? h[2] = a : a && (h[2] = "(" + h[2] + ") and (" + a + ")"), s.push(h));
          }
        }, s;
      };
    }, function(t, o, i) {
      var s, r, a = {}, l = (s = function() {
        return window && document && document.all && !window.atob;
      }, function() {
        return r === undefined && (r = s.apply(this, arguments)), r;
      }), c = function(k) {
        var m = {};
        return function(w) {
          if (typeof w == "function")
            return w();
          if (m[w] === undefined) {
            var x = function(I) {
              return document.querySelector(I);
            }.call(this, w);
            if (window.HTMLIFrameElement && x instanceof window.HTMLIFrameElement)
              try {
                x = x.contentDocument.head;
              } catch {
                x = null;
              }
            m[w] = x;
          }
          return m[w];
        };
      }(), u = null, h = 0, p = [], g = i(5);
      function f(k, m) {
        for (var w = 0;w < k.length; w++) {
          var x = k[w], I = a[x.id];
          if (I) {
            I.refs++;
            for (var C = 0;C < I.parts.length; C++)
              I.parts[C](x.parts[C]);
            for (;C < x.parts.length; C++)
              I.parts.push(F(x.parts[C], m));
          } else {
            var N = [];
            for (C = 0;C < x.parts.length; C++)
              N.push(F(x.parts[C], m));
            a[x.id] = { id: x.id, refs: 1, parts: N };
          }
        }
      }
      function v(k, m) {
        for (var w = [], x = {}, I = 0;I < k.length; I++) {
          var C = k[I], N = m.base ? C[0] + m.base : C[0], B = { css: C[1], media: C[2], sourceMap: C[3] };
          x[N] ? x[N].parts.push(B) : w.push(x[N] = { id: N, parts: [B] });
        }
        return w;
      }
      function O(k, m) {
        var w = c(k.insertInto);
        if (!w)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
        var x = p[p.length - 1];
        if (k.insertAt === "top")
          x ? x.nextSibling ? w.insertBefore(m, x.nextSibling) : w.appendChild(m) : w.insertBefore(m, w.firstChild), p.push(m);
        else if (k.insertAt === "bottom")
          w.appendChild(m);
        else {
          if (typeof k.insertAt != "object" || !k.insertAt.before)
            throw new Error(`[Style Loader]

 Invalid value for parameter 'insertAt' ('options.insertAt') found.
 Must be 'top', 'bottom', or Object.
 (https://github.com/webpack-contrib/style-loader#insertat)
`);
          var I = c(k.insertInto + " " + k.insertAt.before);
          w.insertBefore(m, I);
        }
      }
      function T(k) {
        if (k.parentNode === null)
          return false;
        k.parentNode.removeChild(k);
        var m = p.indexOf(k);
        m >= 0 && p.splice(m, 1);
      }
      function M(k) {
        var m = document.createElement("style");
        return k.attrs.type === undefined && (k.attrs.type = "text/css"), q(m, k.attrs), O(k, m), m;
      }
      function q(k, m) {
        Object.keys(m).forEach(function(w) {
          k.setAttribute(w, m[w]);
        });
      }
      function F(k, m) {
        var w, x, I, C;
        if (m.transform && k.css) {
          if (!(C = m.transform(k.css)))
            return function() {
            };
          k.css = C;
        }
        if (m.singleton) {
          var N = h++;
          w = u || (u = M(m)), x = ie.bind(null, w, N, false), I = ie.bind(null, w, N, true);
        } else
          k.sourceMap && typeof URL == "function" && typeof URL.createObjectURL == "function" && typeof URL.revokeObjectURL == "function" && typeof Blob == "function" && typeof btoa == "function" ? (w = function(B) {
            var W = document.createElement("link");
            return B.attrs.type === undefined && (B.attrs.type = "text/css"), B.attrs.rel = "stylesheet", q(W, B.attrs), O(B, W), W;
          }(m), x = function(B, W, ve) {
            var { css: se, sourceMap: tt } = ve, Yn = W.convertToAbsoluteUrls === undefined && tt;
            (W.convertToAbsoluteUrls || Yn) && (se = g(se)), tt && (se += `
/*# sourceMappingURL=data:application/json;base64,` + btoa(unescape(encodeURIComponent(JSON.stringify(tt)))) + " */");
            var Kn = new Blob([se], { type: "text/css" }), ko = B.href;
            B.href = URL.createObjectURL(Kn), ko && URL.revokeObjectURL(ko);
          }.bind(null, w, m), I = function() {
            T(w), w.href && URL.revokeObjectURL(w.href);
          }) : (w = M(m), x = function(B, W) {
            var { css: ve, media: se } = W;
            if (se && B.setAttribute("media", se), B.styleSheet)
              B.styleSheet.cssText = ve;
            else {
              for (;B.firstChild; )
                B.removeChild(B.firstChild);
              B.appendChild(document.createTextNode(ve));
            }
          }.bind(null, w), I = function() {
            T(w);
          });
        return x(k), function(B) {
          if (B) {
            if (B.css === k.css && B.media === k.media && B.sourceMap === k.sourceMap)
              return;
            x(k = B);
          } else
            I();
        };
      }
      t.exports = function(k, m) {
        if (typeof DEBUG < "u" && DEBUG && typeof document != "object")
          throw new Error("The style-loader cannot be used in a non-browser environment");
        (m = m || {}).attrs = typeof m.attrs == "object" ? m.attrs : {}, m.singleton || typeof m.singleton == "boolean" || (m.singleton = l()), m.insertInto || (m.insertInto = "head"), m.insertAt || (m.insertAt = "bottom");
        var w = v(k, m);
        return f(w, m), function(x) {
          for (var I = [], C = 0;C < w.length; C++) {
            var N = w[C];
            (B = a[N.id]).refs--, I.push(B);
          }
          for (x && f(v(x, m), m), C = 0;C < I.length; C++) {
            var B;
            if ((B = I[C]).refs === 0) {
              for (var W = 0;W < B.parts.length; W++)
                B.parts[W]();
              delete a[B.id];
            }
          }
        };
      };
      var H, Q = (H = [], function(k, m) {
        return H[k] = m, H.filter(Boolean).join(`
`);
      });
      function ie(k, m, w, x) {
        var I = w ? "" : x.css;
        if (k.styleSheet)
          k.styleSheet.cssText = Q(m, I);
        else {
          var C = document.createTextNode(I), N = k.childNodes;
          N[m] && k.removeChild(N[m]), N.length ? k.insertBefore(C, N[m]) : k.appendChild(C);
        }
      }
    }, function(t, o) {
      t.exports = function(i) {
        var s = typeof window < "u" && window.location;
        if (!s)
          throw new Error("fixUrls requires window.location");
        if (!i || typeof i != "string")
          return i;
        var r = s.protocol + "//" + s.host, a = r + s.pathname.replace(/\/[^\/]*$/, "/");
        return i.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(l, c) {
          var u, h = c.trim().replace(/^"(.*)"$/, function(p, g) {
            return g;
          }).replace(/^'(.*)'$/, function(p, g) {
            return g;
          });
          return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(h) ? l : (u = h.indexOf("//") === 0 ? h : h.indexOf("/") === 0 ? r + h : a + h.replace(/^\.\//, ""), "url(" + JSON.stringify(u) + ")");
        });
      };
    }, function(t, o, i) {
      var s, r, a, l, c, u, h, p, g;
      t.exports = (s = "cdx-notifies", r = "cdx-notify", a = "cdx-notify__cross", l = "cdx-notify__button--confirm", c = "cdx-notify__button--cancel", u = "cdx-notify__input", h = "cdx-notify__button", p = "cdx-notify__btns-wrapper", { alert: g = function(f) {
        var v = document.createElement("DIV"), O = document.createElement("DIV"), T = f.message, M = f.style;
        return v.classList.add(r), M && v.classList.add(r + "--" + M), v.innerHTML = T, O.classList.add(a), O.addEventListener("click", v.remove.bind(v)), v.appendChild(O), v;
      }, confirm: function(f) {
        var v = g(f), O = document.createElement("div"), T = document.createElement("button"), M = document.createElement("button"), q = v.querySelector("." + a), F = f.cancelHandler, H = f.okHandler;
        return O.classList.add(p), T.innerHTML = f.okText || "Confirm", M.innerHTML = f.cancelText || "Cancel", T.classList.add(h), M.classList.add(h), T.classList.add(l), M.classList.add(c), F && typeof F == "function" && (M.addEventListener("click", F), q.addEventListener("click", F)), H && typeof H == "function" && T.addEventListener("click", H), T.addEventListener("click", v.remove.bind(v)), M.addEventListener("click", v.remove.bind(v)), O.appendChild(T), O.appendChild(M), v.appendChild(O), v;
      }, prompt: function(f) {
        var v = g(f), O = document.createElement("div"), T = document.createElement("button"), M = document.createElement("input"), q = v.querySelector("." + a), F = f.cancelHandler, H = f.okHandler;
        return O.classList.add(p), T.innerHTML = f.okText || "Ok", T.classList.add(h), T.classList.add(l), M.classList.add(u), f.placeholder && M.setAttribute("placeholder", f.placeholder), f.default && (M.value = f.default), f.inputType && (M.type = f.inputType), F && typeof F == "function" && q.addEventListener("click", F), H && typeof H == "function" && T.addEventListener("click", function() {
          H(M.value);
        }), T.addEventListener("click", v.remove.bind(v)), O.appendChild(M), O.appendChild(T), v.appendChild(O), v;
      }, getWrapper: function() {
        var f = document.createElement("DIV");
        return f.classList.add(s), f;
      } });
    }]);
  });
})(Ko);
var Ei = Ko.exports;
var xi = /* @__PURE__ */ Ke(Ei);

class Bi {
  show(e) {
    xi.show(e);
  }
}

class Ci extends E {
  constructor({ config: e, eventsDispatcher: t }) {
    super({
      config: e,
      eventsDispatcher: t
    }), this.notifier = new Bi;
  }
  get methods() {
    return {
      show: (e) => this.show(e)
    };
  }
  show(e) {
    return this.notifier.show(e);
  }
}

class Ti extends E {
  get methods() {
    const e = () => this.isEnabled;
    return {
      toggle: (t) => this.toggle(t),
      get isEnabled() {
        return e();
      }
    };
  }
  toggle(e) {
    return this.Editor.ReadOnly.toggle(e);
  }
  get isEnabled() {
    return this.Editor.ReadOnly.isEnabled;
  }
}
var Xo = { exports: {} };
(function(n, e) {
  (function(t, o) {
    n.exports = o();
  })(Ce, function() {
    function t(h) {
      var p = h.tags, g = Object.keys(p), f = g.map(function(v) {
        return typeof p[v];
      }).every(function(v) {
        return v === "object" || v === "boolean" || v === "function";
      });
      if (!f)
        throw new Error("The configuration was invalid");
      this.config = h;
    }
    var o = ["P", "LI", "TD", "TH", "DIV", "H1", "H2", "H3", "H4", "H5", "H6", "PRE"];
    function i(h) {
      return o.indexOf(h.nodeName) !== -1;
    }
    var s = ["A", "B", "STRONG", "I", "EM", "SUB", "SUP", "U", "STRIKE"];
    function r(h) {
      return s.indexOf(h.nodeName) !== -1;
    }
    t.prototype.clean = function(h) {
      const p = document.implementation.createHTMLDocument(), g = p.createElement("div");
      return g.innerHTML = h, this._sanitize(p, g), g.innerHTML;
    }, t.prototype._sanitize = function(h, p) {
      var g = a(h, p), f = g.firstChild();
      if (f)
        do {
          if (f.nodeType === Node.TEXT_NODE)
            if (f.data.trim() === "" && (f.previousElementSibling && i(f.previousElementSibling) || f.nextElementSibling && i(f.nextElementSibling))) {
              p.removeChild(f), this._sanitize(h, p);
              break;
            } else
              continue;
          if (f.nodeType === Node.COMMENT_NODE) {
            p.removeChild(f), this._sanitize(h, p);
            break;
          }
          var v = r(f), O;
          v && (O = Array.prototype.some.call(f.childNodes, i));
          var T = !!p.parentNode, M = i(p) && i(f) && T, q = f.nodeName.toLowerCase(), F = l(this.config, q, f), H = v && O;
          if (H || c(f, F) || !this.config.keepNestedBlockElements && M) {
            if (!(f.nodeName === "SCRIPT" || f.nodeName === "STYLE"))
              for (;f.childNodes.length > 0; )
                p.insertBefore(f.childNodes[0], f);
            p.removeChild(f), this._sanitize(h, p);
            break;
          }
          for (var Q = 0;Q < f.attributes.length; Q += 1) {
            var ie = f.attributes[Q];
            u(ie, F, f) && (f.removeAttribute(ie.name), Q = Q - 1);
          }
          this._sanitize(h, f);
        } while (f = g.nextSibling());
    };
    function a(h, p) {
      return h.createTreeWalker(p, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null, false);
    }
    function l(h, p, g) {
      return typeof h.tags[p] == "function" ? h.tags[p](g) : h.tags[p];
    }
    function c(h, p) {
      return typeof p > "u" ? true : typeof p == "boolean" ? !p : false;
    }
    function u(h, p, g) {
      var f = h.name.toLowerCase();
      return p === true ? false : typeof p[f] == "function" ? !p[f](h.value, g) : typeof p[f] > "u" || p[f] === false ? true : typeof p[f] == "string" ? p[f] !== h.value : false;
    }
    return t;
  });
})(Xo);
var Si = Xo.exports;
var Ii = /* @__PURE__ */ Ke(Si);
function yt(n, e) {
  return n.map((t) => {
    const o = A(e) ? e(t.tool) : e;
    return V(o) || (t.data = wt(t.data, o)), t;
  });
}
function Z(n, e = {}) {
  const t = {
    tags: e
  };
  return new Ii(t).clean(n);
}
function wt(n, e) {
  return Array.isArray(n) ? Oi(n, e) : D(n) ? _i(n, e) : te(n) ? Mi(n, e) : n;
}
function Oi(n, e) {
  return n.map((t) => wt(t, e));
}
function _i(n, e) {
  const t = {};
  for (const o in n) {
    if (!Object.prototype.hasOwnProperty.call(n, o))
      continue;
    const i = n[o], s = Ai(e[o]) ? e[o] : e;
    t[o] = wt(i, s);
  }
  return t;
}
function Mi(n, e) {
  return D(e) ? Z(n, e) : e === false ? Z(n, {}) : n;
}
function Ai(n) {
  return D(n) || Gn(n) || A(n);
}

class Li extends E {
  get methods() {
    return {
      clean: (e, t) => this.clean(e, t)
    };
  }
  clean(e, t) {
    return Z(e, t);
  }
}

class Pi extends E {
  get methods() {
    return {
      save: () => this.save()
    };
  }
  save() {
    const e = "Editor's content can not be saved in read-only mode";
    return this.Editor.ReadOnly.isEnabled ? (X(e, "warn"), Promise.reject(new Error(e))) : this.Editor.Saver.save();
  }
}

class Ni extends E {
  constructor() {
    super(...arguments), this.selectionUtils = new b;
  }
  get methods() {
    return {
      findParentTag: (e, t) => this.findParentTag(e, t),
      expandToTag: (e) => this.expandToTag(e),
      save: () => this.selectionUtils.save(),
      restore: () => this.selectionUtils.restore(),
      setFakeBackground: () => this.selectionUtils.setFakeBackground(),
      removeFakeBackground: () => this.selectionUtils.removeFakeBackground()
    };
  }
  findParentTag(e, t) {
    return this.selectionUtils.findParentTag(e, t);
  }
  expandToTag(e) {
    this.selectionUtils.expandToTag(e);
  }
}

class Ri extends E {
  get methods() {
    return {
      getBlockTools: () => Array.from(this.Editor.Tools.blockTools.values())
    };
  }
}

class Di extends E {
  get classes() {
    return {
      block: "cdx-block",
      inlineToolButton: "ce-inline-tool",
      inlineToolButtonActive: "ce-inline-tool--active",
      input: "cdx-input",
      loader: "cdx-loader",
      button: "cdx-button",
      settingsButton: "cdx-settings-button",
      settingsButtonActive: "cdx-settings-button--active"
    };
  }
}

class Fi extends E {
  get methods() {
    return {
      close: () => this.close(),
      open: () => this.open(),
      toggleBlockSettings: (e) => this.toggleBlockSettings(e),
      toggleToolbox: (e) => this.toggleToolbox(e)
    };
  }
  open() {
    this.Editor.Toolbar.moveAndOpen();
  }
  close() {
    this.Editor.Toolbar.close();
  }
  toggleBlockSettings(e) {
    if (this.Editor.BlockManager.currentBlockIndex === -1) {
      X("Could't toggle the Toolbar because there is no block selected ", "warn");
      return;
    }
    e ?? !this.Editor.BlockSettings.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.open()) : this.Editor.BlockSettings.close();
  }
  toggleToolbox(e) {
    if (this.Editor.BlockManager.currentBlockIndex === -1) {
      X("Could't toggle the Toolbox because there is no block selected ", "warn");
      return;
    }
    e ?? !this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open()) : this.Editor.Toolbar.toolbox.close();
  }
}
var Vo = { exports: {} };
/*!
 * CodeX.Tooltips
 * 
 * @version 1.0.5
 * 
 * @licence MIT
 * @author CodeX <https://codex.so>
 * 
 * 
 */
(function(n, e) {
  (function(t, o) {
    n.exports = o();
  })(window, function() {
    return function(t) {
      var o = {};
      function i(s) {
        if (o[s])
          return o[s].exports;
        var r = o[s] = { i: s, l: false, exports: {} };
        return t[s].call(r.exports, r, r.exports, i), r.l = true, r.exports;
      }
      return i.m = t, i.c = o, i.d = function(s, r, a) {
        i.o(s, r) || Object.defineProperty(s, r, { enumerable: true, get: a });
      }, i.r = function(s) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(s, "__esModule", { value: true });
      }, i.t = function(s, r) {
        if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == "object" && s && s.__esModule)
          return s;
        var a = /* @__PURE__ */ Object.create(null);
        if (i.r(a), Object.defineProperty(a, "default", { enumerable: true, value: s }), 2 & r && typeof s != "string")
          for (var l in s)
            i.d(a, l, function(c) {
              return s[c];
            }.bind(null, l));
        return a;
      }, i.n = function(s) {
        var r = s && s.__esModule ? function() {
          return s.default;
        } : function() {
          return s;
        };
        return i.d(r, "a", r), r;
      }, i.o = function(s, r) {
        return Object.prototype.hasOwnProperty.call(s, r);
      }, i.p = "", i(i.s = 0);
    }([function(t, o, i) {
      t.exports = i(1);
    }, function(t, o, i) {
      i.r(o), i.d(o, "default", function() {
        return s;
      });

      class s {
        constructor() {
          this.nodes = { wrapper: null, content: null }, this.showed = false, this.offsetTop = 10, this.offsetLeft = 10, this.offsetRight = 10, this.hidingDelay = 0, this.handleWindowScroll = () => {
            this.showed && this.hide(true);
          }, this.loadStyles(), this.prepare(), window.addEventListener("scroll", this.handleWindowScroll, { passive: true });
        }
        get CSS() {
          return { tooltip: "ct", tooltipContent: "ct__content", tooltipShown: "ct--shown", placement: { left: "ct--left", bottom: "ct--bottom", right: "ct--right", top: "ct--top" } };
        }
        show(a, l, c) {
          this.nodes.wrapper || this.prepare(), this.hidingTimeout && clearTimeout(this.hidingTimeout);
          const u = Object.assign({ placement: "bottom", marginTop: 0, marginLeft: 0, marginRight: 0, marginBottom: 0, delay: 70, hidingDelay: 0 }, c);
          if (u.hidingDelay && (this.hidingDelay = u.hidingDelay), this.nodes.content.innerHTML = "", typeof l == "string")
            this.nodes.content.appendChild(document.createTextNode(l));
          else {
            if (!(l instanceof Node))
              throw Error("[CodeX Tooltip] Wrong type of «content» passed. It should be an instance of Node or String. But " + typeof l + " given.");
            this.nodes.content.appendChild(l);
          }
          switch (this.nodes.wrapper.classList.remove(...Object.values(this.CSS.placement)), u.placement) {
            case "top":
              this.placeTop(a, u);
              break;
            case "left":
              this.placeLeft(a, u);
              break;
            case "right":
              this.placeRight(a, u);
              break;
            case "bottom":
            default:
              this.placeBottom(a, u);
          }
          u && u.delay ? this.showingTimeout = setTimeout(() => {
            this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = true;
          }, u.delay) : (this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = true);
        }
        hide(a = false) {
          if (this.hidingDelay && !a)
            return this.hidingTimeout && clearTimeout(this.hidingTimeout), void (this.hidingTimeout = setTimeout(() => {
              this.hide(true);
            }, this.hidingDelay));
          this.nodes.wrapper.classList.remove(this.CSS.tooltipShown), this.showed = false, this.showingTimeout && clearTimeout(this.showingTimeout);
        }
        onHover(a, l, c) {
          a.addEventListener("mouseenter", () => {
            this.show(a, l, c);
          }), a.addEventListener("mouseleave", () => {
            this.hide();
          });
        }
        destroy() {
          this.nodes.wrapper.remove(), window.removeEventListener("scroll", this.handleWindowScroll);
        }
        prepare() {
          this.nodes.wrapper = this.make("div", this.CSS.tooltip), this.nodes.content = this.make("div", this.CSS.tooltipContent), this.append(this.nodes.wrapper, this.nodes.content), this.append(document.body, this.nodes.wrapper);
        }
        loadStyles() {
          const a = "codex-tooltips-style";
          if (document.getElementById(a))
            return;
          const l = i(2), c = this.make("style", null, { textContent: l.toString(), id: a });
          this.prepend(document.head, c);
        }
        placeBottom(a, l) {
          const c = a.getBoundingClientRect(), u = c.left + a.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = c.bottom + window.pageYOffset + this.offsetTop + l.marginTop;
          this.applyPlacement("bottom", u, h);
        }
        placeTop(a, l) {
          const c = a.getBoundingClientRect(), u = c.left + a.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = c.top + window.pageYOffset - this.nodes.wrapper.clientHeight - this.offsetTop;
          this.applyPlacement("top", u, h);
        }
        placeLeft(a, l) {
          const c = a.getBoundingClientRect(), u = c.left - this.nodes.wrapper.offsetWidth - this.offsetLeft - l.marginLeft, h = c.top + window.pageYOffset + a.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;
          this.applyPlacement("left", u, h);
        }
        placeRight(a, l) {
          const c = a.getBoundingClientRect(), u = c.right + this.offsetRight + l.marginRight, h = c.top + window.pageYOffset + a.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;
          this.applyPlacement("right", u, h);
        }
        applyPlacement(a, l, c) {
          this.nodes.wrapper.classList.add(this.CSS.placement[a]), this.nodes.wrapper.style.left = l + "px", this.nodes.wrapper.style.top = c + "px";
        }
        make(a, l = null, c = {}) {
          const u = document.createElement(a);
          Array.isArray(l) ? u.classList.add(...l) : l && u.classList.add(l);
          for (const h in c)
            c.hasOwnProperty(h) && (u[h] = c[h]);
          return u;
        }
        append(a, l) {
          Array.isArray(l) ? l.forEach((c) => a.appendChild(c)) : a.appendChild(l);
        }
        prepend(a, l) {
          Array.isArray(l) ? (l = l.reverse()).forEach((c) => a.prepend(c)) : a.prepend(l);
        }
      }
    }, function(t, o) {
      t.exports = `.ct{z-index:999;opacity:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1),-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);will-change:opacity,top,left;-webkit-box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);border-radius:9px}.ct,.ct:before{position:absolute;top:0;left:0}.ct:before{content:"";bottom:0;right:0;background-color:#1d202b;z-index:-1;border-radius:4px}@supports(-webkit-mask-box-image:url("")){.ct:before{border-radius:0;-webkit-mask-box-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M10.71 0h2.58c3.02 0 4.64.42 6.1 1.2a8.18 8.18 0 013.4 3.4C23.6 6.07 24 7.7 24 10.71v2.58c0 3.02-.42 4.64-1.2 6.1a8.18 8.18 0 01-3.4 3.4c-1.47.8-3.1 1.21-6.11 1.21H10.7c-3.02 0-4.64-.42-6.1-1.2a8.18 8.18 0 01-3.4-3.4C.4 17.93 0 16.3 0 13.29V10.7c0-3.02.42-4.64 1.2-6.1a8.18 8.18 0 013.4-3.4C6.07.4 7.7 0 10.71 0z"/></svg>') 48% 41% 37.9% 53.3%}}@media (--mobile){.ct{display:none}}.ct__content{padding:6px 10px;color:#cdd1e0;font-size:12px;text-align:center;letter-spacing:.02em;line-height:1em}.ct:after{content:"";width:8px;height:8px;position:absolute;background-color:#1d202b;z-index:-1}.ct--bottom{-webkit-transform:translateY(5px);transform:translateY(5px)}.ct--bottom:after{top:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--top{-webkit-transform:translateY(-5px);transform:translateY(-5px)}.ct--top:after{top:auto;bottom:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--left{-webkit-transform:translateX(-5px);transform:translateX(-5px)}.ct--left:after{top:50%;left:auto;right:0;-webkit-transform:translate(41.6%,-50%) rotate(-45deg);transform:translate(41.6%,-50%) rotate(-45deg)}.ct--right{-webkit-transform:translateX(5px);transform:translateX(5px)}.ct--right:after{top:50%;left:0;-webkit-transform:translate(-41.6%,-50%) rotate(-45deg);transform:translate(-41.6%,-50%) rotate(-45deg)}.ct--shown{opacity:1;-webkit-transform:none;transform:none}`;
    }]).default;
  });
})(Vo);
var ji = Vo.exports;
var Hi = /* @__PURE__ */ Ke(ji);
var U = null;
function Et() {
  U || (U = new Hi);
}
function $i(n, e, t) {
  Et(), U == null || U.show(n, e, t);
}
function $e(n = false) {
  Et(), U == null || U.hide(n);
}
function ze(n, e, t) {
  Et(), U == null || U.onHover(n, e, t);
}
function zi() {
  U == null || U.destroy(), U = null;
}

class Ui extends E {
  constructor({ config: e, eventsDispatcher: t }) {
    super({
      config: e,
      eventsDispatcher: t
    });
  }
  get methods() {
    return {
      show: (e, t, o) => this.show(e, t, o),
      hide: () => this.hide(),
      onHover: (e, t, o) => this.onHover(e, t, o)
    };
  }
  show(e, t, o) {
    $i(e, t, o);
  }
  hide() {
    $e();
  }
  onHover(e, t, o) {
    ze(e, t, o);
  }
}

class Wi extends E {
  get methods() {
    return {
      nodes: this.editorNodes
    };
  }
  get editorNodes() {
    return {
      wrapper: this.Editor.UI.nodes.wrapper,
      redactor: this.Editor.UI.nodes.redactor
    };
  }
}
function qo(n, e) {
  const t = {};
  return Object.entries(n).forEach(([o, i]) => {
    if (D(i)) {
      const s = e ? `${e}.${o}` : o;
      Object.values(i).every((a) => te(a)) ? t[o] = s : t[o] = qo(i, s);
      return;
    }
    t[o] = i;
  }), t;
}
var K = qo(Fo);
function Yi(n, e) {
  const t = {};
  return Object.keys(n).forEach((o) => {
    const i = e[o];
    i !== undefined ? t[i] = n[o] : t[o] = n[o];
  }), t;
}
var Zo = class Ee {
  constructor(e, t) {
    this.cursor = -1, this.items = [], this.items = e || [], this.focusedCssClass = t;
  }
  get currentItem() {
    return this.cursor === -1 ? null : this.items[this.cursor];
  }
  setCursor(e) {
    e < this.items.length && e >= -1 && (this.dropCursor(), this.cursor = e, this.items[this.cursor].classList.add(this.focusedCssClass));
  }
  setItems(e) {
    this.items = e;
  }
  next() {
    this.cursor = this.leafNodesAndReturnIndex(Ee.directions.RIGHT);
  }
  previous() {
    this.cursor = this.leafNodesAndReturnIndex(Ee.directions.LEFT);
  }
  dropCursor() {
    this.cursor !== -1 && (this.items[this.cursor].classList.remove(this.focusedCssClass), this.cursor = -1);
  }
  leafNodesAndReturnIndex(e) {
    if (this.items.length === 0)
      return this.cursor;
    let t = this.cursor;
    return t === -1 ? t = e === Ee.directions.RIGHT ? -1 : 0 : this.items[t].classList.remove(this.focusedCssClass), e === Ee.directions.RIGHT ? t = (t + 1) % this.items.length : t = (this.items.length + t - 1) % this.items.length, d.canSetCaret(this.items[t]) && Fe(() => b.setCursor(this.items[t]), 50)(), this.items[t].classList.add(this.focusedCssClass), t;
  }
};
Zo.directions = {
  RIGHT: "right",
  LEFT: "left"
};
var ke = Zo;

class ce {
  constructor(e) {
    this.iterator = null, this.activated = false, this.flipCallbacks = [], this.onKeyDown = (t) => {
      if (this.isEventReadyForHandling(t))
        switch (ce.usedKeys.includes(t.keyCode) && t.preventDefault(), t.keyCode) {
          case y.TAB:
            this.handleTabPress(t);
            break;
          case y.LEFT:
          case y.UP:
            this.flipLeft();
            break;
          case y.RIGHT:
          case y.DOWN:
            this.flipRight();
            break;
          case y.ENTER:
            this.handleEnterPress(t);
            break;
        }
    }, this.iterator = new ke(e.items, e.focusedItemClass), this.activateCallback = e.activateCallback, this.allowedKeys = e.allowedKeys || ce.usedKeys;
  }
  get isActivated() {
    return this.activated;
  }
  static get usedKeys() {
    return [
      y.TAB,
      y.LEFT,
      y.RIGHT,
      y.ENTER,
      y.UP,
      y.DOWN
    ];
  }
  activate(e, t) {
    this.activated = true, e && this.iterator.setItems(e), t !== undefined && this.iterator.setCursor(t), document.addEventListener("keydown", this.onKeyDown, true);
  }
  deactivate() {
    this.activated = false, this.dropCursor(), document.removeEventListener("keydown", this.onKeyDown);
  }
  focusFirst() {
    this.dropCursor(), this.flipRight();
  }
  flipLeft() {
    this.iterator.previous(), this.flipCallback();
  }
  flipRight() {
    this.iterator.next(), this.flipCallback();
  }
  hasFocus() {
    return !!this.iterator.currentItem;
  }
  onFlip(e) {
    this.flipCallbacks.push(e);
  }
  removeOnFlip(e) {
    this.flipCallbacks = this.flipCallbacks.filter((t) => t !== e);
  }
  dropCursor() {
    this.iterator.dropCursor();
  }
  isEventReadyForHandling(e) {
    return this.activated && this.allowedKeys.includes(e.keyCode);
  }
  handleTabPress(e) {
    switch (e.shiftKey ? ke.directions.LEFT : ke.directions.RIGHT) {
      case ke.directions.RIGHT:
        this.flipRight();
        break;
      case ke.directions.LEFT:
        this.flipLeft();
        break;
    }
  }
  handleEnterPress(e) {
    this.activated && (this.iterator.currentItem && (e.stopPropagation(), e.preventDefault(), this.iterator.currentItem.click()), A(this.activateCallback) && this.activateCallback(this.iterator.currentItem));
  }
  flipCallback() {
    this.iterator.currentItem && this.iterator.currentItem.scrollIntoViewIfNeeded(), this.flipCallbacks.forEach((e) => e());
  }
}
var Ki = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9 12L9 7.1C9 7.04477 9.04477 7 9.1 7H10.4C11.5 7 14 7.1 14 9.5C14 9.5 14 12 11 12M9 12V16.8C9 16.9105 9.08954 17 9.2 17H12.5C14 17 15 16 15 14.5C15 11.7046 11 12 11 12M9 12H11"/></svg>';
var Xi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7 10L11.8586 14.8586C11.9367 14.9367 12.0633 14.9367 12.1414 14.8586L17 10"/></svg>';
var Vi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M14.5 17.5L9.64142 12.6414C9.56331 12.5633 9.56331 12.4367 9.64142 12.3586L14.5 7.5"/></svg>';
var qi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9.58284 17.5L14.4414 12.6414C14.5195 12.5633 14.5195 12.4367 14.4414 12.3586L9.58284 7.5"/></svg>';
var Zi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7 15L11.8586 10.1414C11.9367 10.0633 12.0633 10.0633 12.1414 10.1414L17 15"/></svg>';
var Gi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16"/></svg>';
var Qi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><circle cx="12" cy="12" r="4" stroke="currentColor" stroke-width="2"/></svg>';
var Ji = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M13.34 10C12.4223 12.7337 11 17 11 17"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M14.21 7H14.2"/></svg>';
var Co = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7.69998 12.6L7.67896 12.62C6.53993 13.7048 6.52012 15.5155 7.63516 16.625V16.625C8.72293 17.7073 10.4799 17.7102 11.5712 16.6314L13.0263 15.193C14.0703 14.1609 14.2141 12.525 13.3662 11.3266L13.22 11.12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16.22 11.12L16.3564 10.9805C17.2895 10.0265 17.3478 8.5207 16.4914 7.49733V7.49733C15.5691 6.39509 13.9269 6.25143 12.8271 7.17675L11.3901 8.38588C10.0935 9.47674 9.95706 11.4241 11.0888 12.6852L11.12 12.72"/></svg>';
var es = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.40999 7.29999H9.4"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 7.29999H14.59"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.30999 12H9.3"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 12H14.59"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.40999 16.7H9.4"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 16.7H14.59"/></svg>';
var ts = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 7V12M12 17V12M17 12H12M12 12H7"/></svg>';
var Go = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M11.5 17.5L5 11M5 11V15.5M5 11H9.5"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12.5 6.5L19 13M19 13V8.5M19 13H14.5"/></svg>';
var os = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><circle cx="10.5" cy="10.5" r="5.5" stroke="currentColor" stroke-width="2"/><line x1="15.4142" x2="19" y1="15" y2="18.5858" stroke="currentColor" stroke-linecap="round" stroke-width="2"/></svg>';
var ns = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M15.7795 11.5C15.7795 11.5 16.053 11.1962 16.5497 10.6722C17.4442 9.72856 17.4701 8.2475 16.5781 7.30145V7.30145C15.6482 6.31522 14.0873 6.29227 13.1288 7.25073L11.8796 8.49999"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8.24517 12.3883C8.24517 12.3883 7.97171 12.6922 7.47504 13.2161C6.58051 14.1598 6.55467 15.6408 7.44666 16.5869V16.5869C8.37653 17.5731 9.93744 17.5961 10.8959 16.6376L12.1452 15.3883"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M17.7802 15.1032L16.597 14.9422C16.0109 14.8624 15.4841 15.3059 15.4627 15.8969L15.4199 17.0818"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6.39064 9.03238L7.58432 9.06668C8.17551 9.08366 8.6522 8.58665 8.61056 7.99669L8.5271 6.81397"/><line x1="12.1142" x2="11.7" y1="12.2" y2="11.7858" stroke="currentColor" stroke-linecap="round" stroke-width="2"/></svg>';
var is = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/><line x1="12" x2="12" y1="9" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 15.02V15.01"/></svg>';
var ss = "__";
var rs = "--";
function ne(n) {
  return (e, t) => [[n, e].filter((i) => !!i).join(ss), t].filter((i) => !!i).join(rs);
}
var ye = ne("ce-hint");
var we = {
  root: ye(),
  alignedStart: ye(null, "align-left"),
  alignedCenter: ye(null, "align-center"),
  title: ye("title"),
  description: ye("description")
};

class as {
  constructor(e) {
    this.nodes = {
      root: d.make("div", [we.root, e.alignment === "center" ? we.alignedCenter : we.alignedStart]),
      title: d.make("div", we.title, { textContent: e.title })
    }, this.nodes.root.appendChild(this.nodes.title), e.description !== undefined && (this.nodes.description = d.make("div", we.description, { textContent: e.description }), this.nodes.root.appendChild(this.nodes.description));
  }
  getElement() {
    return this.nodes.root;
  }
}

class xt {
  constructor(e) {
    this.params = e;
  }
  get name() {
    if (this.params !== undefined && "name" in this.params)
      return this.params.name;
  }
  destroy() {
    $e();
  }
  onChildrenOpen() {
    var e;
    this.params !== undefined && "children" in this.params && typeof ((e = this.params.children) == null ? undefined : e.onOpen) == "function" && this.params.children.onOpen();
  }
  onChildrenClose() {
    var e;
    this.params !== undefined && "children" in this.params && typeof ((e = this.params.children) == null ? undefined : e.onClose) == "function" && this.params.children.onClose();
  }
  handleClick() {
    var e, t;
    this.params !== undefined && "onActivate" in this.params && ((t = (e = this.params).onActivate) == null || t.call(e, this.params));
  }
  addHint(e, t) {
    const o = new as(t);
    ze(e, o.getElement(), {
      placement: t.position,
      hidingDelay: 100
    });
  }
  get children() {
    var e;
    return this.params !== undefined && "children" in this.params && ((e = this.params.children) == null ? undefined : e.items) !== undefined ? this.params.children.items : [];
  }
  get hasChildren() {
    return this.children.length > 0;
  }
  get isChildrenOpen() {
    var e;
    return this.params !== undefined && "children" in this.params && ((e = this.params.children) == null ? undefined : e.isOpen) === true;
  }
  get isChildrenFlippable() {
    var e;
    return !(this.params === undefined || !("children" in this.params) || ((e = this.params.children) == null ? undefined : e.isFlippable) === false);
  }
  get isChildrenSearchable() {
    var e;
    return this.params !== undefined && "children" in this.params && ((e = this.params.children) == null ? undefined : e.searchable) === true;
  }
  get closeOnActivate() {
    return this.params !== undefined && "closeOnActivate" in this.params && this.params.closeOnActivate;
  }
  get isActive() {
    return this.params === undefined || !("isActive" in this.params) ? false : typeof this.params.isActive == "function" ? this.params.isActive() : this.params.isActive === true;
  }
}
var Y = ne("ce-popover-item");
var L = {
  container: Y(),
  active: Y(null, "active"),
  disabled: Y(null, "disabled"),
  focused: Y(null, "focused"),
  hidden: Y(null, "hidden"),
  confirmationState: Y(null, "confirmation"),
  noHover: Y(null, "no-hover"),
  noFocus: Y(null, "no-focus"),
  title: Y("title"),
  secondaryTitle: Y("secondary-title"),
  icon: Y("icon"),
  iconTool: Y("icon", "tool"),
  iconChevronRight: Y("icon", "chevron-right"),
  wobbleAnimation: ne("wobble")()
};

class re extends xt {
  constructor(e, t) {
    super(e), this.params = e, this.nodes = {
      root: null,
      icon: null
    }, this.confirmationState = null, this.removeSpecialFocusBehavior = () => {
      var o;
      (o = this.nodes.root) == null || o.classList.remove(L.noFocus);
    }, this.removeSpecialHoverBehavior = () => {
      var o;
      (o = this.nodes.root) == null || o.classList.remove(L.noHover);
    }, this.onErrorAnimationEnd = () => {
      var o, i;
      (o = this.nodes.icon) == null || o.classList.remove(L.wobbleAnimation), (i = this.nodes.icon) == null || i.removeEventListener("animationend", this.onErrorAnimationEnd);
    }, this.nodes.root = this.make(e, t);
  }
  get isDisabled() {
    return this.params.isDisabled === true;
  }
  get toggle() {
    return this.params.toggle;
  }
  get title() {
    return this.params.title;
  }
  get isConfirmationStateEnabled() {
    return this.confirmationState !== null;
  }
  get isFocused() {
    return this.nodes.root === null ? false : this.nodes.root.classList.contains(L.focused);
  }
  getElement() {
    return this.nodes.root;
  }
  handleClick() {
    if (this.isConfirmationStateEnabled && this.confirmationState !== null) {
      this.activateOrEnableConfirmationMode(this.confirmationState);
      return;
    }
    this.activateOrEnableConfirmationMode(this.params);
  }
  toggleActive(e) {
    var t;
    (t = this.nodes.root) == null || t.classList.toggle(L.active, e);
  }
  toggleHidden(e) {
    var t;
    (t = this.nodes.root) == null || t.classList.toggle(L.hidden, e);
  }
  reset() {
    this.isConfirmationStateEnabled && this.disableConfirmationMode();
  }
  onFocus() {
    this.disableSpecialHoverAndFocusBehavior();
  }
  make(e, t) {
    var s, r;
    const o = (t == null ? undefined : t.wrapperTag) || "div", i = d.make(o, L.container, {
      type: o === "button" ? "button" : undefined
    });
    return e.name && (i.dataset.itemName = e.name), this.nodes.icon = d.make("div", [L.icon, L.iconTool], {
      innerHTML: e.icon || Qi
    }), i.appendChild(this.nodes.icon), e.title !== undefined && i.appendChild(d.make("div", L.title, {
      innerHTML: e.title || ""
    })), e.secondaryLabel && i.appendChild(d.make("div", L.secondaryTitle, {
      textContent: e.secondaryLabel
    })), this.hasChildren && i.appendChild(d.make("div", [L.icon, L.iconChevronRight], {
      innerHTML: qi
    })), this.isActive && i.classList.add(L.active), e.isDisabled && i.classList.add(L.disabled), e.hint !== undefined && ((s = t == null ? undefined : t.hint) == null ? undefined : s.enabled) !== false && this.addHint(i, {
      ...e.hint,
      position: ((r = t == null ? undefined : t.hint) == null ? undefined : r.position) || "right"
    }), i;
  }
  enableConfirmationMode(e) {
    if (this.nodes.root === null)
      return;
    const t = {
      ...this.params,
      ...e,
      confirmation: "confirmation" in e ? e.confirmation : undefined
    }, o = this.make(t);
    this.nodes.root.innerHTML = o.innerHTML, this.nodes.root.classList.add(L.confirmationState), this.confirmationState = e, this.enableSpecialHoverAndFocusBehavior();
  }
  disableConfirmationMode() {
    if (this.nodes.root === null)
      return;
    const e = this.make(this.params);
    this.nodes.root.innerHTML = e.innerHTML, this.nodes.root.classList.remove(L.confirmationState), this.confirmationState = null, this.disableSpecialHoverAndFocusBehavior();
  }
  enableSpecialHoverAndFocusBehavior() {
    var e, t, o;
    (e = this.nodes.root) == null || e.classList.add(L.noHover), (t = this.nodes.root) == null || t.classList.add(L.noFocus), (o = this.nodes.root) == null || o.addEventListener("mouseleave", this.removeSpecialHoverBehavior, { once: true });
  }
  disableSpecialHoverAndFocusBehavior() {
    var e;
    this.removeSpecialFocusBehavior(), this.removeSpecialHoverBehavior(), (e = this.nodes.root) == null || e.removeEventListener("mouseleave", this.removeSpecialHoverBehavior);
  }
  activateOrEnableConfirmationMode(e) {
    var t;
    if (!("confirmation" in e) || e.confirmation === undefined)
      try {
        (t = e.onActivate) == null || t.call(e, e), this.disableConfirmationMode();
      } catch {
        this.animateError();
      }
    else
      this.enableConfirmationMode(e.confirmation);
  }
  animateError() {
    var e, t, o;
    (e = this.nodes.icon) != null && e.classList.contains(L.wobbleAnimation) || ((t = this.nodes.icon) == null || t.classList.add(L.wobbleAnimation), (o = this.nodes.icon) == null || o.addEventListener("animationend", this.onErrorAnimationEnd));
  }
}
var nt = ne("ce-popover-item-separator");
var it = {
  container: nt(),
  line: nt("line"),
  hidden: nt(null, "hidden")
};

class Qo extends xt {
  constructor() {
    super(), this.nodes = {
      root: d.make("div", it.container),
      line: d.make("div", it.line)
    }, this.nodes.root.appendChild(this.nodes.line);
  }
  getElement() {
    return this.nodes.root;
  }
  toggleHidden(e) {
    var t;
    (t = this.nodes.root) == null || t.classList.toggle(it.hidden, e);
  }
}
var G = /* @__PURE__ */ ((n) => (n.Closed = "closed", n.ClosedOnActivate = "closed-on-activate", n))(G || {});
var $ = ne("ce-popover");
var P = {
  popover: $(),
  popoverContainer: $("container"),
  popoverOpenTop: $(null, "open-top"),
  popoverOpenLeft: $(null, "open-left"),
  popoverOpened: $(null, "opened"),
  search: $("search"),
  nothingFoundMessage: $("nothing-found-message"),
  nothingFoundMessageDisplayed: $("nothing-found-message", "displayed"),
  items: $("items"),
  overlay: $("overlay"),
  overlayHidden: $("overlay", "hidden"),
  popoverNested: $(null, "nested"),
  getPopoverNestedClass: (n) => $(null, `nested-level-${n.toString()}`),
  popoverInline: $(null, "inline"),
  popoverHeader: $("header")
};
var fe = /* @__PURE__ */ ((n) => (n.NestingLevel = "--nesting-level", n.PopoverHeight = "--popover-height", n.InlinePopoverWidth = "--inline-popover-width", n.TriggerItemLeft = "--trigger-item-left", n.TriggerItemTop = "--trigger-item-top", n))(fe || {});
var To = ne("ce-popover-item-html");
var So = {
  root: To(),
  hidden: To(null, "hidden")
};

class Se extends xt {
  constructor(e, t) {
    var o, i;
    super(e), this.nodes = {
      root: d.make("div", So.root)
    }, this.nodes.root.appendChild(e.element), e.name && (this.nodes.root.dataset.itemName = e.name), e.hint !== undefined && ((o = t == null ? undefined : t.hint) == null ? undefined : o.enabled) !== false && this.addHint(this.nodes.root, {
      ...e.hint,
      position: ((i = t == null ? undefined : t.hint) == null ? undefined : i.position) || "right"
    });
  }
  getElement() {
    return this.nodes.root;
  }
  toggleHidden(e) {
    var t;
    (t = this.nodes.root) == null || t.classList.toggle(So.hidden, e);
  }
  getControls() {
    const e = this.nodes.root.querySelectorAll(`button, ${d.allInputsSelector}`);
    return Array.from(e);
  }
}

class Jo extends Oe {
  constructor(e, t = {}) {
    super(), this.params = e, this.itemsRenderParams = t, this.listeners = new _e, this.messages = {
      nothingFound: "Nothing found",
      search: "Search"
    }, this.items = this.buildItems(e.items), e.messages && (this.messages = {
      ...this.messages,
      ...e.messages
    }), this.nodes = {}, this.nodes.popoverContainer = d.make("div", [P.popoverContainer]), this.nodes.nothingFoundMessage = d.make("div", [P.nothingFoundMessage], {
      textContent: this.messages.nothingFound
    }), this.nodes.popoverContainer.appendChild(this.nodes.nothingFoundMessage), this.nodes.items = d.make("div", [P.items]), this.items.forEach((o) => {
      const i = o.getElement();
      i !== null && this.nodes.items.appendChild(i);
    }), this.nodes.popoverContainer.appendChild(this.nodes.items), this.listeners.on(this.nodes.popoverContainer, "click", (o) => this.handleClick(o)), this.nodes.popover = d.make("div", [
      P.popover,
      this.params.class
    ]), this.nodes.popover.appendChild(this.nodes.popoverContainer);
  }
  get itemsDefault() {
    return this.items.filter((e) => e instanceof re);
  }
  getElement() {
    return this.nodes.popover;
  }
  show() {
    this.nodes.popover.classList.add(P.popoverOpened), this.search !== undefined && this.search.focus();
  }
  hide() {
    this.nodes.popover.classList.remove(P.popoverOpened), this.nodes.popover.classList.remove(P.popoverOpenTop), this.itemsDefault.forEach((e) => e.reset()), this.search !== undefined && this.search.clear(), this.emit(G.Closed);
  }
  destroy() {
    var e;
    this.items.forEach((t) => t.destroy()), this.nodes.popover.remove(), this.listeners.removeAll(), (e = this.search) == null || e.destroy();
  }
  activateItemByName(e) {
    const t = this.items.find((o) => o.name === e);
    this.handleItemClick(t);
  }
  buildItems(e) {
    return e.map((t) => {
      switch (t.type) {
        case _.Separator:
          return new Qo;
        case _.Html:
          return new Se(t, this.itemsRenderParams[_.Html]);
        default:
          return new re(t, this.itemsRenderParams[_.Default]);
      }
    });
  }
  getTargetItem(e) {
    return this.items.filter((t) => t instanceof re || t instanceof Se).find((t) => {
      const o = t.getElement();
      return o === null ? false : e.composedPath().includes(o);
    });
  }
  handleItemClick(e) {
    if (!(("isDisabled" in e) && e.isDisabled)) {
      if (e.hasChildren) {
        this.showNestedItems(e), "handleClick" in e && typeof e.handleClick == "function" && e.handleClick();
        return;
      }
      this.itemsDefault.filter((t) => t !== e).forEach((t) => t.reset()), "handleClick" in e && typeof e.handleClick == "function" && e.handleClick(), this.toggleItemActivenessIfNeeded(e), e.closeOnActivate && (this.hide(), this.emit(G.ClosedOnActivate));
    }
  }
  handleClick(e) {
    const t = this.getTargetItem(e);
    t !== undefined && this.handleItemClick(t);
  }
  toggleItemActivenessIfNeeded(e) {
    if (e instanceof re && (e.toggle === true && e.toggleActive(), typeof e.toggle == "string")) {
      const t = this.itemsDefault.filter((o) => o.toggle === e.toggle);
      if (t.length === 1) {
        e.toggleActive();
        return;
      }
      t.forEach((o) => {
        o.toggleActive(o === e);
      });
    }
  }
}
var Ue = /* @__PURE__ */ ((n) => (n.Search = "search", n))(Ue || {});
var st = ne("cdx-search-field");
var rt = {
  wrapper: st(),
  icon: st("icon"),
  input: st("input")
};

class ls extends Oe {
  constructor({ items: e, placeholder: t }) {
    super(), this.listeners = new _e, this.items = e, this.wrapper = d.make("div", rt.wrapper);
    const o = d.make("div", rt.icon, {
      innerHTML: os
    });
    this.input = d.make("input", rt.input, {
      placeholder: t,
      tabIndex: -1
    }), this.wrapper.appendChild(o), this.wrapper.appendChild(this.input), this.listeners.on(this.input, "input", () => {
      this.searchQuery = this.input.value, this.emit(Ue.Search, {
        query: this.searchQuery,
        items: this.foundItems
      });
    });
  }
  getElement() {
    return this.wrapper;
  }
  focus() {
    this.input.focus();
  }
  clear() {
    this.input.value = "", this.searchQuery = "", this.emit(Ue.Search, {
      query: "",
      items: this.foundItems
    });
  }
  destroy() {
    this.listeners.removeAll();
  }
  get foundItems() {
    return this.items.filter((e) => this.checkItem(e));
  }
  checkItem(e) {
    var i, s;
    const t = ((i = e.title) == null ? undefined : i.toLowerCase()) || "", o = (s = this.searchQuery) == null ? undefined : s.toLowerCase();
    return o !== undefined ? t.includes(o) : false;
  }
}
var cs = Object.defineProperty;
var ds = Object.getOwnPropertyDescriptor;
var us = (n, e, t, o) => {
  for (var i = o > 1 ? undefined : o ? ds(e, t) : e, s = n.length - 1, r;s >= 0; s--)
    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);
  return o && i && cs(e, t, i), i;
};
var en = class tn extends Jo {
  constructor(e, t) {
    super(e, t), this.nestingLevel = 0, this.nestedPopoverTriggerItem = null, this.previouslyHoveredItem = null, this.scopeElement = document.body, this.hide = () => {
      var o;
      super.hide(), this.destroyNestedPopoverIfExists(), (o = this.flipper) == null || o.deactivate(), this.previouslyHoveredItem = null;
    }, this.onFlip = () => {
      const o = this.itemsDefault.find((i) => i.isFocused);
      o == null || o.onFocus();
    }, this.onSearch = (o) => {
      var a;
      const i = o.query === "", s = o.items.length === 0;
      this.items.forEach((l) => {
        let c = false;
        l instanceof re ? c = !o.items.includes(l) : (l instanceof Qo || l instanceof Se) && (c = s || !i), l.toggleHidden(c);
      }), this.toggleNothingFoundMessage(s);
      const r = o.query === "" ? this.flippableElements : o.items.map((l) => l.getElement());
      (a = this.flipper) != null && a.isActivated && (this.flipper.deactivate(), this.flipper.activate(r));
    }, e.nestingLevel !== undefined && (this.nestingLevel = e.nestingLevel), this.nestingLevel > 0 && this.nodes.popover.classList.add(P.popoverNested), e.scopeElement !== undefined && (this.scopeElement = e.scopeElement), this.nodes.popoverContainer !== null && this.listeners.on(this.nodes.popoverContainer, "mouseover", (o) => this.handleHover(o)), e.searchable && this.addSearch(), e.flippable !== false && (this.flipper = new ce({
      items: this.flippableElements,
      focusedItemClass: L.focused,
      allowedKeys: [
        y.TAB,
        y.UP,
        y.DOWN,
        y.ENTER
      ]
    }), this.flipper.onFlip(this.onFlip));
  }
  hasFocus() {
    return this.flipper === undefined ? false : this.flipper.hasFocus();
  }
  get scrollTop() {
    return this.nodes.items === null ? 0 : this.nodes.items.scrollTop;
  }
  get offsetTop() {
    return this.nodes.popoverContainer === null ? 0 : this.nodes.popoverContainer.offsetTop;
  }
  show() {
    var e;
    this.nodes.popover.style.setProperty(fe.PopoverHeight, this.size.height + "px"), this.shouldOpenBottom || this.nodes.popover.classList.add(P.popoverOpenTop), this.shouldOpenRight || this.nodes.popover.classList.add(P.popoverOpenLeft), super.show(), (e = this.flipper) == null || e.activate(this.flippableElements);
  }
  destroy() {
    this.hide(), super.destroy();
  }
  showNestedItems(e) {
    this.nestedPopover !== null && this.nestedPopover !== undefined || (this.nestedPopoverTriggerItem = e, this.showNestedPopoverForItem(e));
  }
  handleHover(e) {
    const t = this.getTargetItem(e);
    t !== undefined && this.previouslyHoveredItem !== t && (this.destroyNestedPopoverIfExists(), this.previouslyHoveredItem = t, t.hasChildren && this.showNestedPopoverForItem(t));
  }
  setTriggerItemPosition(e, t) {
    const o = t.getElement(), i = (o ? o.offsetTop : 0) - this.scrollTop, s = this.offsetTop + i;
    e.style.setProperty(fe.TriggerItemTop, s + "px");
  }
  destroyNestedPopoverIfExists() {
    var e, t;
    this.nestedPopover === undefined || this.nestedPopover === null || (this.nestedPopover.off(G.ClosedOnActivate, this.hide), this.nestedPopover.hide(), this.nestedPopover.destroy(), this.nestedPopover.getElement().remove(), this.nestedPopover = null, (e = this.flipper) == null || e.activate(this.flippableElements), (t = this.nestedPopoverTriggerItem) == null || t.onChildrenClose());
  }
  showNestedPopoverForItem(e) {
    var o;
    this.nestedPopover = new tn({
      searchable: e.isChildrenSearchable,
      items: e.children,
      nestingLevel: this.nestingLevel + 1,
      flippable: e.isChildrenFlippable,
      messages: this.messages
    }), e.onChildrenOpen(), this.nestedPopover.on(G.ClosedOnActivate, this.hide);
    const t = this.nestedPopover.getElement();
    return this.nodes.popover.appendChild(t), this.setTriggerItemPosition(t, e), t.style.setProperty(fe.NestingLevel, this.nestedPopover.nestingLevel.toString()), this.nestedPopover.show(), (o = this.flipper) == null || o.deactivate(), this.nestedPopover;
  }
  get shouldOpenBottom() {
    if (this.nodes.popover === undefined || this.nodes.popover === null)
      return false;
    const e = this.nodes.popoverContainer.getBoundingClientRect(), t = this.scopeElement.getBoundingClientRect(), o = this.size.height, i = e.top + o, s = e.top - o, r = Math.min(window.innerHeight, t.bottom);
    return s < t.top || i <= r;
  }
  get shouldOpenRight() {
    if (this.nodes.popover === undefined || this.nodes.popover === null)
      return false;
    const e = this.nodes.popover.getBoundingClientRect(), t = this.scopeElement.getBoundingClientRect(), o = this.size.width, i = e.right + o, s = e.left - o, r = Math.min(window.innerWidth, t.right);
    return s < t.left || i <= r;
  }
  get size() {
    var i;
    const e = {
      height: 0,
      width: 0
    };
    if (this.nodes.popover === null)
      return e;
    const t = this.nodes.popover.cloneNode(true);
    t.style.visibility = "hidden", t.style.position = "absolute", t.style.top = "-1000px", t.classList.add(P.popoverOpened), (i = t.querySelector("." + P.popoverNested)) == null || i.remove(), document.body.appendChild(t);
    const o = t.querySelector("." + P.popoverContainer);
    return e.height = o.offsetHeight, e.width = o.offsetWidth, t.remove(), e;
  }
  get flippableElements() {
    return this.items.map((t) => {
      if (t instanceof re)
        return t.getElement();
      if (t instanceof Se)
        return t.getControls();
    }).flat().filter((t) => t != null);
  }
  addSearch() {
    this.search = new ls({
      items: this.itemsDefault,
      placeholder: this.messages.search
    }), this.search.on(Ue.Search, this.onSearch);
    const e = this.search.getElement();
    e.classList.add(P.search), this.nodes.popoverContainer.insertBefore(e, this.nodes.popoverContainer.firstChild);
  }
  toggleNothingFoundMessage(e) {
    this.nodes.nothingFoundMessage.classList.toggle(P.nothingFoundMessageDisplayed, e);
  }
};
us([
  me
], en.prototype, "size", 1);
var Bt = en;

class hs extends Bt {
  constructor(e) {
    const t = !be();
    super({
      ...e,
      class: P.popoverInline
    }, {
      [_.Default]: {
        wrapperTag: "button",
        hint: {
          position: "top",
          alignment: "center",
          enabled: t
        }
      },
      [_.Html]: {
        hint: {
          position: "top",
          alignment: "center",
          enabled: t
        }
      }
    }), this.items.forEach((o) => {
      !(o instanceof re) && !(o instanceof Se) || o.hasChildren && o.isChildrenOpen && this.showNestedItems(o);
    });
  }
  get offsetLeft() {
    return this.nodes.popoverContainer === null ? 0 : this.nodes.popoverContainer.offsetLeft;
  }
  show() {
    this.nestingLevel === 0 && this.nodes.popover.style.setProperty(fe.InlinePopoverWidth, this.size.width + "px"), super.show();
  }
  handleHover() {
  }
  setTriggerItemPosition(e, t) {
    const o = t.getElement(), i = o ? o.offsetLeft : 0, s = this.offsetLeft + i;
    e.style.setProperty(fe.TriggerItemLeft, s + "px");
  }
  showNestedItems(e) {
    if (this.nestedPopoverTriggerItem === e) {
      this.destroyNestedPopoverIfExists(), this.nestedPopoverTriggerItem = null;
      return;
    }
    super.showNestedItems(e);
  }
  showNestedPopoverForItem(e) {
    const t = super.showNestedPopoverForItem(e);
    return t.getElement().classList.add(P.getPopoverNestedClass(t.nestingLevel)), t;
  }
  handleItemClick(e) {
    var t;
    e !== this.nestedPopoverTriggerItem && ((t = this.nestedPopoverTriggerItem) == null || t.handleClick(), super.destroyNestedPopoverIfExists()), super.handleItemClick(e);
  }
}
var on = class xe {
  constructor() {
    this.scrollPosition = null;
  }
  lock() {
    pt ? this.lockHard() : document.body.classList.add(xe.CSS.scrollLocked);
  }
  unlock() {
    pt ? this.unlockHard() : document.body.classList.remove(xe.CSS.scrollLocked);
  }
  lockHard() {
    this.scrollPosition = window.pageYOffset, document.documentElement.style.setProperty("--window-scroll-offset", `${this.scrollPosition}px`), document.body.classList.add(xe.CSS.scrollLockedHard);
  }
  unlockHard() {
    document.body.classList.remove(xe.CSS.scrollLockedHard), this.scrollPosition !== null && window.scrollTo(0, this.scrollPosition), this.scrollPosition = null;
  }
};
on.CSS = {
  scrollLocked: "ce-scroll-locked",
  scrollLockedHard: "ce-scroll-locked--hard"
};
var ps = on;
var at = ne("ce-popover-header");
var lt = {
  root: at(),
  text: at("text"),
  backButton: at("back-button")
};

class fs {
  constructor({ text: e, onBackButtonClick: t }) {
    this.listeners = new _e, this.text = e, this.onBackButtonClick = t, this.nodes = {
      root: d.make("div", [lt.root]),
      backButton: d.make("button", [lt.backButton]),
      text: d.make("div", [lt.text])
    }, this.nodes.backButton.innerHTML = Vi, this.nodes.root.appendChild(this.nodes.backButton), this.listeners.on(this.nodes.backButton, "click", this.onBackButtonClick), this.nodes.text.innerText = this.text, this.nodes.root.appendChild(this.nodes.text);
  }
  getElement() {
    return this.nodes.root;
  }
  destroy() {
    this.nodes.root.remove(), this.listeners.destroy();
  }
}

class gs {
  constructor() {
    this.history = [];
  }
  push(e) {
    this.history.push(e);
  }
  pop() {
    return this.history.pop();
  }
  get currentTitle() {
    return this.history.length === 0 ? "" : this.history[this.history.length - 1].title;
  }
  get currentItems() {
    return this.history.length === 0 ? [] : this.history[this.history.length - 1].items;
  }
  reset() {
    for (;this.history.length > 1; )
      this.pop();
  }
}

class nn extends Jo {
  constructor(e) {
    super(e, {
      [_.Default]: {
        hint: {
          enabled: false
        }
      },
      [_.Html]: {
        hint: {
          enabled: false
        }
      }
    }), this.scrollLocker = new ps, this.history = new gs, this.isHidden = true, this.nodes.overlay = d.make("div", [P.overlay, P.overlayHidden]), this.nodes.popover.insertBefore(this.nodes.overlay, this.nodes.popover.firstChild), this.listeners.on(this.nodes.overlay, "click", () => {
      this.hide();
    }), this.history.push({ items: e.items });
  }
  show() {
    this.nodes.overlay.classList.remove(P.overlayHidden), super.show(), this.scrollLocker.lock(), this.isHidden = false;
  }
  hide() {
    this.isHidden || (super.hide(), this.nodes.overlay.classList.add(P.overlayHidden), this.scrollLocker.unlock(), this.history.reset(), this.isHidden = true);
  }
  destroy() {
    super.destroy(), this.scrollLocker.unlock();
  }
  showNestedItems(e) {
    this.updateItemsAndHeader(e.children, e.title), this.history.push({
      title: e.title,
      items: e.children
    });
  }
  updateItemsAndHeader(e, t) {
    if (this.header !== null && this.header !== undefined && (this.header.destroy(), this.header = null), t !== undefined) {
      this.header = new fs({
        text: t,
        onBackButtonClick: () => {
          this.history.pop(), this.updateItemsAndHeader(this.history.currentItems, this.history.currentTitle);
        }
      });
      const o = this.header.getElement();
      o !== null && this.nodes.popoverContainer.insertBefore(o, this.nodes.popoverContainer.firstChild);
    }
    this.items.forEach((o) => {
      var i;
      return (i = o.getElement()) == null ? undefined : i.remove();
    }), this.items = this.buildItems(e), this.items.forEach((o) => {
      var s;
      const i = o.getElement();
      i !== null && ((s = this.nodes.items) == null || s.appendChild(i));
    });
  }
}

class ms extends E {
  constructor() {
    super(...arguments), this.opened = false, this.selection = new b, this.popover = null, this.close = () => {
      this.opened && (this.opened = false, b.isAtEditor || this.selection.restore(), this.selection.clearSaved(), !this.Editor.CrossBlockSelection.isCrossBlockSelectionStarted && this.Editor.BlockManager.currentBlock && this.Editor.BlockSelection.unselectBlock(this.Editor.BlockManager.currentBlock), this.eventsDispatcher.emit(this.events.closed), this.popover && (this.popover.off(G.Closed, this.onPopoverClose), this.popover.destroy(), this.popover.getElement().remove(), this.popover = null));
    }, this.onPopoverClose = () => {
      this.close();
    };
  }
  get events() {
    return {
      opened: "block-settings-opened",
      closed: "block-settings-closed"
    };
  }
  get CSS() {
    return {
      settings: "ce-settings"
    };
  }
  get flipper() {
    var e;
    if (this.popover !== null)
      return "flipper" in this.popover ? (e = this.popover) == null ? undefined : e.flipper : undefined;
  }
  make() {
    this.nodes.wrapper = d.make("div", [this.CSS.settings]), this.nodes.wrapper.setAttribute("data-cy", "block-tunes"), this.eventsDispatcher.on(Te, this.close);
  }
  destroy() {
    this.removeAllNodes(), this.listeners.destroy(), this.eventsDispatcher.off(Te, this.close);
  }
  async open(e = this.Editor.BlockManager.currentBlock) {
    var s;
    this.opened = true, this.selection.save(), this.Editor.BlockSelection.selectBlock(e), this.Editor.BlockSelection.clearCache();
    const { toolTunes: t, commonTunes: o } = e.getTunes();
    this.eventsDispatcher.emit(this.events.opened);
    const i = be() ? nn : Bt;
    this.popover = new i({
      searchable: true,
      items: await this.getTunesItems(e, o, t),
      scopeElement: this.Editor.API.methods.ui.nodes.redactor,
      messages: {
        nothingFound: z.ui(K.ui.popover, "Nothing found"),
        search: z.ui(K.ui.popover, "Filter")
      }
    }), this.popover.on(G.Closed, this.onPopoverClose), (s = this.nodes.wrapper) == null || s.append(this.popover.getElement()), this.popover.show();
  }
  getElement() {
    return this.nodes.wrapper;
  }
  async getTunesItems(e, t, o) {
    const i = [];
    o !== undefined && o.length > 0 && (i.push(...o), i.push({
      type: _.Separator
    }));
    const s = Array.from(this.Editor.Tools.blockTools.values()), a = (await Yo(e, s)).reduce((l, c) => (c.toolbox.forEach((u) => {
      l.push({
        icon: u.icon,
        title: z.t(K.toolNames, u.title),
        name: c.name,
        closeOnActivate: true,
        onActivate: async () => {
          const { BlockManager: h, Caret: p, Toolbar: g } = this.Editor, f = await h.convert(e, c.name, u.data);
          g.close(), p.setToBlock(f, p.positions.END);
        }
      });
    }), l), []);
    return a.length > 0 && (i.push({
      icon: Go,
      name: "convert-to",
      title: z.ui(K.ui.popover, "Convert to"),
      children: {
        searchable: true,
        items: a
      }
    }), i.push({
      type: _.Separator
    })), i.push(...t), i.map((l) => this.resolveTuneAliases(l));
  }
  resolveTuneAliases(e) {
    if (e.type === _.Separator || e.type === _.Html)
      return e;
    const t = Yi(e, { label: "title" });
    return e.confirmation && (t.confirmation = this.resolveTuneAliases(e.confirmation)), t;
  }
}
var sn = { exports: {} };
/*!
 * Library for handling keyboard shortcuts
 * @copyright CodeX (https://codex.so)
 * @license MIT
 * @author CodeX (https://codex.so)
 * @version 1.2.0
 */
(function(n, e) {
  (function(t, o) {
    n.exports = o();
  })(window, function() {
    return function(t) {
      var o = {};
      function i(s) {
        if (o[s])
          return o[s].exports;
        var r = o[s] = { i: s, l: false, exports: {} };
        return t[s].call(r.exports, r, r.exports, i), r.l = true, r.exports;
      }
      return i.m = t, i.c = o, i.d = function(s, r, a) {
        i.o(s, r) || Object.defineProperty(s, r, { enumerable: true, get: a });
      }, i.r = function(s) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(s, "__esModule", { value: true });
      }, i.t = function(s, r) {
        if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == "object" && s && s.__esModule)
          return s;
        var a = /* @__PURE__ */ Object.create(null);
        if (i.r(a), Object.defineProperty(a, "default", { enumerable: true, value: s }), 2 & r && typeof s != "string")
          for (var l in s)
            i.d(a, l, function(c) {
              return s[c];
            }.bind(null, l));
        return a;
      }, i.n = function(s) {
        var r = s && s.__esModule ? function() {
          return s.default;
        } : function() {
          return s;
        };
        return i.d(r, "a", r), r;
      }, i.o = function(s, r) {
        return Object.prototype.hasOwnProperty.call(s, r);
      }, i.p = "", i(i.s = 0);
    }([function(t, o, i) {
      function s(l, c) {
        for (var u = 0;u < c.length; u++) {
          var h = c[u];
          h.enumerable = h.enumerable || false, h.configurable = true, "value" in h && (h.writable = true), Object.defineProperty(l, h.key, h);
        }
      }
      function r(l, c, u) {
        return c && s(l.prototype, c), u && s(l, u), l;
      }
      i.r(o);
      var a = function() {
        function l(c) {
          var u = this;
          (function(h, p) {
            if (!(h instanceof p))
              throw new TypeError("Cannot call a class as a function");
          })(this, l), this.commands = {}, this.keys = {}, this.name = c.name, this.parseShortcutName(c.name), this.element = c.on, this.callback = c.callback, this.executeShortcut = function(h) {
            u.execute(h);
          }, this.element.addEventListener("keydown", this.executeShortcut, false);
        }
        return r(l, null, [{ key: "supportedCommands", get: function() {
          return { SHIFT: ["SHIFT"], CMD: ["CMD", "CONTROL", "COMMAND", "WINDOWS", "CTRL"], ALT: ["ALT", "OPTION"] };
        } }, { key: "keyCodes", get: function() {
          return { 0: 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, BACKSPACE: 8, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, INSERT: 45, DELETE: 46, ".": 190 };
        } }]), r(l, [{ key: "parseShortcutName", value: function(c) {
          c = c.split("+");
          for (var u = 0;u < c.length; u++) {
            c[u] = c[u].toUpperCase();
            var h = false;
            for (var p in l.supportedCommands)
              if (l.supportedCommands[p].includes(c[u])) {
                h = this.commands[p] = true;
                break;
              }
            h || (this.keys[c[u]] = true);
          }
          for (var g in l.supportedCommands)
            this.commands[g] || (this.commands[g] = false);
        } }, { key: "execute", value: function(c) {
          var u, h = { CMD: c.ctrlKey || c.metaKey, SHIFT: c.shiftKey, ALT: c.altKey }, p = true;
          for (u in this.commands)
            this.commands[u] !== h[u] && (p = false);
          var g, f = true;
          for (g in this.keys)
            f = f && c.keyCode === l.keyCodes[g];
          p && f && this.callback(c);
        } }, { key: "remove", value: function() {
          this.element.removeEventListener("keydown", this.executeShortcut);
        } }]), l;
      }();
      o.default = a;
    }]).default;
  });
})(sn);
var bs = sn.exports;
var vs = /* @__PURE__ */ Ke(bs);

class ks {
  constructor() {
    this.registeredShortcuts = /* @__PURE__ */ new Map;
  }
  add(e) {
    if (this.findShortcut(e.on, e.name))
      throw Error(`Shortcut ${e.name} is already registered for ${e.on}. Please remove it before add a new handler.`);
    const o = new vs({
      name: e.name,
      on: e.on,
      callback: e.handler
    }), i = this.registeredShortcuts.get(e.on) || [];
    this.registeredShortcuts.set(e.on, [...i, o]);
  }
  remove(e, t) {
    const o = this.findShortcut(e, t);
    if (!o)
      return;
    o.remove();
    const i = this.registeredShortcuts.get(e);
    this.registeredShortcuts.set(e, i.filter((s) => s !== o));
  }
  findShortcut(e, t) {
    return (this.registeredShortcuts.get(e) || []).find(({ name: i }) => i === t);
  }
}
var ge = new ks;
var ys = Object.defineProperty;
var ws = Object.getOwnPropertyDescriptor;
var rn = (n, e, t, o) => {
  for (var i = o > 1 ? undefined : o ? ws(e, t) : e, s = n.length - 1, r;s >= 0; s--)
    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);
  return o && i && ys(e, t, i), i;
};
var Le = /* @__PURE__ */ ((n) => (n.Opened = "toolbox-opened", n.Closed = "toolbox-closed", n.BlockAdded = "toolbox-block-added", n))(Le || {});
var Ct = class an extends Oe {
  constructor({ api: e, tools: t, i18nLabels: o }) {
    super(), this.opened = false, this.listeners = new _e, this.popover = null, this.handleMobileLayoutToggle = () => {
      this.destroyPopover(), this.initPopover();
    }, this.onPopoverClose = () => {
      this.opened = false, this.emit("toolbox-closed");
    }, this.api = e, this.tools = t, this.i18nLabels = o, this.enableShortcuts(), this.nodes = {
      toolbox: d.make("div", an.CSS.toolbox)
    }, this.initPopover(), this.nodes.toolbox.setAttribute("data-cy", "toolbox"), this.api.events.on(Te, this.handleMobileLayoutToggle);
  }
  get isEmpty() {
    return this.toolsToBeDisplayed.length === 0;
  }
  static get CSS() {
    return {
      toolbox: "ce-toolbox"
    };
  }
  getElement() {
    return this.nodes.toolbox;
  }
  hasFocus() {
    if (this.popover !== null)
      return "hasFocus" in this.popover ? this.popover.hasFocus() : undefined;
  }
  destroy() {
    var e;
    super.destroy(), this.nodes && this.nodes.toolbox && this.nodes.toolbox.remove(), this.removeAllShortcuts(), (e = this.popover) == null || e.off(G.Closed, this.onPopoverClose), this.listeners.destroy(), this.api.events.off(Te, this.handleMobileLayoutToggle);
  }
  toolButtonActivated(e, t) {
    this.insertNewBlock(e, t);
  }
  open() {
    var e;
    this.isEmpty || ((e = this.popover) == null || e.show(), this.opened = true, this.emit("toolbox-opened"));
  }
  close() {
    var e;
    (e = this.popover) == null || e.hide(), this.opened = false, this.emit("toolbox-closed");
  }
  toggle() {
    this.opened ? this.close() : this.open();
  }
  initPopover() {
    var t;
    const e = be() ? nn : Bt;
    this.popover = new e({
      scopeElement: this.api.ui.nodes.redactor,
      searchable: true,
      messages: {
        nothingFound: this.i18nLabels.nothingFound,
        search: this.i18nLabels.filter
      },
      items: this.toolboxItemsToBeDisplayed
    }), this.popover.on(G.Closed, this.onPopoverClose), (t = this.nodes.toolbox) == null || t.append(this.popover.getElement());
  }
  destroyPopover() {
    this.popover !== null && (this.popover.hide(), this.popover.off(G.Closed, this.onPopoverClose), this.popover.destroy(), this.popover = null), this.nodes.toolbox !== null && (this.nodes.toolbox.innerHTML = "");
  }
  get toolsToBeDisplayed() {
    const e = [];
    return this.tools.forEach((t) => {
      t.toolbox && e.push(t);
    }), e;
  }
  get toolboxItemsToBeDisplayed() {
    const e = (t, o, i = true) => ({
      icon: t.icon,
      title: z.t(K.toolNames, t.title || je(o.name)),
      name: o.name,
      onActivate: () => {
        this.toolButtonActivated(o.name, t.data);
      },
      secondaryLabel: o.shortcut && i ? vt(o.shortcut) : ""
    });
    return this.toolsToBeDisplayed.reduce((t, o) => (Array.isArray(o.toolbox) ? o.toolbox.forEach((i, s) => {
      t.push(e(i, o, s === 0));
    }) : o.toolbox !== undefined && t.push(e(o.toolbox, o)), t), []);
  }
  enableShortcuts() {
    this.toolsToBeDisplayed.forEach((e) => {
      const t = e.shortcut;
      t && this.enableShortcutForTool(e.name, t);
    });
  }
  enableShortcutForTool(e, t) {
    ge.add({
      name: t,
      on: this.api.ui.nodes.redactor,
      handler: async (o) => {
        o.preventDefault();
        const i = this.api.blocks.getCurrentBlockIndex(), s = this.api.blocks.getBlockByIndex(i);
        if (s)
          try {
            const r = await this.api.blocks.convert(s.id, e);
            this.api.caret.setToBlock(r, "end");
            return;
          } catch {
          }
        this.insertNewBlock(e);
      }
    });
  }
  removeAllShortcuts() {
    this.toolsToBeDisplayed.forEach((e) => {
      const t = e.shortcut;
      t && ge.remove(this.api.ui.nodes.redactor, t);
    });
  }
  async insertNewBlock(e, t) {
    const o = this.api.blocks.getCurrentBlockIndex(), i = this.api.blocks.getBlockByIndex(o);
    if (!i)
      return;
    const s = i.isEmpty ? o : o + 1;
    let r;
    if (t) {
      const l = await this.api.blocks.composeBlockData(e);
      r = Object.assign(l, t);
    }
    const a = this.api.blocks.insert(e, r, undefined, s, undefined, i.isEmpty);
    a.call(ee.APPEND_CALLBACK), this.api.caret.setToBlock(s), this.emit("toolbox-block-added", {
      block: a
    }), this.api.toolbar.close();
  }
};
rn([
  me
], Ct.prototype, "toolsToBeDisplayed", 1);
rn([
  me
], Ct.prototype, "toolboxItemsToBeDisplayed", 1);
var Es = Ct;
var ln = "block hovered";
async function xs(n, e) {
  const t = navigator.keyboard;
  if (!t)
    return e;
  try {
    return (await t.getLayoutMap()).get(n) || e;
  } catch (o) {
    return console.error(o), e;
  }
}

class Bs extends E {
  constructor({ config: e, eventsDispatcher: t }) {
    super({
      config: e,
      eventsDispatcher: t
    }), this.toolboxInstance = null;
  }
  get CSS() {
    return {
      toolbar: "ce-toolbar",
      content: "ce-toolbar__content",
      actions: "ce-toolbar__actions",
      actionsOpened: "ce-toolbar__actions--opened",
      toolbarOpened: "ce-toolbar--opened",
      openedToolboxHolderModifier: "codex-editor--toolbox-opened",
      plusButton: "ce-toolbar__plus",
      plusButtonShortcut: "ce-toolbar__plus-shortcut",
      settingsToggler: "ce-toolbar__settings-btn",
      settingsTogglerHidden: "ce-toolbar__settings-btn--hidden"
    };
  }
  get opened() {
    return this.nodes.wrapper.classList.contains(this.CSS.toolbarOpened);
  }
  get toolbox() {
    var e;
    return {
      opened: (e = this.toolboxInstance) == null ? undefined : e.opened,
      close: () => {
        var t;
        (t = this.toolboxInstance) == null || t.close();
      },
      open: () => {
        if (this.toolboxInstance === null) {
          S("toolbox.open() called before initialization is finished", "warn");
          return;
        }
        this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.toolboxInstance.open();
      },
      toggle: () => {
        if (this.toolboxInstance === null) {
          S("toolbox.toggle() called before initialization is finished", "warn");
          return;
        }
        this.toolboxInstance.toggle();
      },
      hasFocus: () => {
        var t;
        return (t = this.toolboxInstance) == null ? undefined : t.hasFocus();
      }
    };
  }
  get blockActions() {
    return {
      hide: () => {
        this.nodes.actions.classList.remove(this.CSS.actionsOpened);
      },
      show: () => {
        this.nodes.actions.classList.add(this.CSS.actionsOpened);
      }
    };
  }
  get blockTunesToggler() {
    return {
      hide: () => this.nodes.settingsToggler.classList.add(this.CSS.settingsTogglerHidden),
      show: () => this.nodes.settingsToggler.classList.remove(this.CSS.settingsTogglerHidden)
    };
  }
  toggleReadOnly(e) {
    e ? (this.destroy(), this.Editor.BlockSettings.destroy(), this.disableModuleBindings()) : window.requestIdleCallback(() => {
      this.drawUI(), this.enableModuleBindings();
    }, { timeout: 2000 });
  }
  moveAndOpen(e = this.Editor.BlockManager.currentBlock) {
    if (this.toolboxInstance === null) {
      S("Can't open Toolbar since Editor initialization is not finished yet", "warn");
      return;
    }
    if (this.toolboxInstance.opened && this.toolboxInstance.close(), this.Editor.BlockSettings.opened && this.Editor.BlockSettings.close(), !e)
      return;
    this.hoveredBlock = e;
    const t = e.holder, { isMobile: o } = this.Editor.UI;
    let i;
    const s = 20, r = e.firstInput, a = t.getBoundingClientRect(), l = r !== undefined ? r.getBoundingClientRect() : null, c = l !== null ? l.top - a.top : null, u = c !== null ? c > s : undefined;
    if (o)
      i = t.offsetTop + t.offsetHeight;
    else if (r === undefined || u) {
      const h = parseInt(window.getComputedStyle(e.pluginsContent).paddingTop);
      i = t.offsetTop + h;
    } else {
      const h = li(r), p = parseInt(window.getComputedStyle(this.nodes.plusButton).height, 10), g = 8;
      i = t.offsetTop + h - p + g + c;
    }
    this.nodes.wrapper.style.top = `${Math.floor(i)}px`, this.Editor.BlockManager.blocks.length === 1 && e.isEmpty ? this.blockTunesToggler.hide() : this.blockTunesToggler.show(), this.open();
  }
  close() {
    var e, t;
    this.Editor.ReadOnly.isEnabled || ((e = this.nodes.wrapper) == null || e.classList.remove(this.CSS.toolbarOpened), this.blockActions.hide(), (t = this.toolboxInstance) == null || t.close(), this.Editor.BlockSettings.close(), this.reset());
  }
  reset() {
    this.nodes.wrapper.style.top = "unset";
  }
  open(e = true) {
    this.nodes.wrapper.classList.add(this.CSS.toolbarOpened), e ? this.blockActions.show() : this.blockActions.hide();
  }
  async make() {
    this.nodes.wrapper = d.make("div", this.CSS.toolbar), ["content", "actions"].forEach((s) => {
      this.nodes[s] = d.make("div", this.CSS[s]);
    }), d.append(this.nodes.wrapper, this.nodes.content), d.append(this.nodes.content, this.nodes.actions), this.nodes.plusButton = d.make("div", this.CSS.plusButton, {
      innerHTML: ts
    }), d.append(this.nodes.actions, this.nodes.plusButton), this.readOnlyMutableListeners.on(this.nodes.plusButton, "click", () => {
      $e(true), this.plusButtonClicked();
    }, false);
    const e = d.make("div");
    e.appendChild(document.createTextNode(z.ui(K.ui.toolbar.toolbox, "Add"))), e.appendChild(d.make("div", this.CSS.plusButtonShortcut, {
      textContent: "/"
    })), ze(this.nodes.plusButton, e, {
      hidingDelay: 400
    }), this.nodes.settingsToggler = d.make("span", this.CSS.settingsToggler, {
      innerHTML: es
    }), d.append(this.nodes.actions, this.nodes.settingsToggler);
    const t = d.make("div"), o = d.text(z.ui(K.ui.blockTunes.toggler, "Click to tune")), i = await xs("Slash", "/");
    t.appendChild(o), t.appendChild(d.make("div", this.CSS.plusButtonShortcut, {
      textContent: vt(`CMD + ${i}`)
    })), ze(this.nodes.settingsToggler, t, {
      hidingDelay: 400
    }), d.append(this.nodes.actions, this.makeToolbox()), d.append(this.nodes.actions, this.Editor.BlockSettings.getElement()), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);
  }
  makeToolbox() {
    return this.toolboxInstance = new Es({
      api: this.Editor.API.methods,
      tools: this.Editor.Tools.blockTools,
      i18nLabels: {
        filter: z.ui(K.ui.popover, "Filter"),
        nothingFound: z.ui(K.ui.popover, "Nothing found")
      }
    }), this.toolboxInstance.on(Le.Opened, () => {
      this.Editor.UI.nodes.wrapper.classList.add(this.CSS.openedToolboxHolderModifier);
    }), this.toolboxInstance.on(Le.Closed, () => {
      this.Editor.UI.nodes.wrapper.classList.remove(this.CSS.openedToolboxHolderModifier);
    }), this.toolboxInstance.on(Le.BlockAdded, ({ block: e }) => {
      const { BlockManager: t, Caret: o } = this.Editor, i = t.getBlockById(e.id);
      i.inputs.length === 0 && (i === t.lastBlock ? (t.insertAtEnd(), o.setToBlock(t.lastBlock)) : o.setToBlock(t.nextBlock));
    }), this.toolboxInstance.getElement();
  }
  plusButtonClicked() {
    var e;
    this.Editor.BlockManager.currentBlock = this.hoveredBlock, (e = this.toolboxInstance) == null || e.toggle();
  }
  enableModuleBindings() {
    this.readOnlyMutableListeners.on(this.nodes.settingsToggler, "mousedown", (e) => {
      var t;
      e.stopPropagation(), this.settingsTogglerClicked(), (t = this.toolboxInstance) != null && t.opened && this.toolboxInstance.close(), $e(true);
    }, true), be() || this.eventsDispatcher.on(ln, (e) => {
      var t;
      this.Editor.BlockSettings.opened || (t = this.toolboxInstance) != null && t.opened || this.moveAndOpen(e.block);
    });
  }
  disableModuleBindings() {
    this.readOnlyMutableListeners.clearAll();
  }
  settingsTogglerClicked() {
    this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.BlockSettings.open(this.hoveredBlock);
  }
  drawUI() {
    this.Editor.BlockSettings.make(), this.make();
  }
  destroy() {
    this.removeAllNodes(), this.toolboxInstance && this.toolboxInstance.destroy();
  }
}
var ae = /* @__PURE__ */ ((n) => (n[n.Block = 0] = "Block", n[n.Inline = 1] = "Inline", n[n.Tune = 2] = "Tune", n))(ae || {});
var Pe = /* @__PURE__ */ ((n) => (n.Shortcut = "shortcut", n.Toolbox = "toolbox", n.EnabledInlineTools = "inlineToolbar", n.EnabledBlockTunes = "tunes", n.Config = "config", n))(Pe || {});
var cn = /* @__PURE__ */ ((n) => (n.Shortcut = "shortcut", n.SanitizeConfig = "sanitize", n))(cn || {});
var pe = /* @__PURE__ */ ((n) => (n.IsEnabledLineBreaks = "enableLineBreaks", n.Toolbox = "toolbox", n.ConversionConfig = "conversionConfig", n.IsReadOnlySupported = "isReadOnlySupported", n.PasteConfig = "pasteConfig", n))(pe || {});
var We = /* @__PURE__ */ ((n) => (n.IsInline = "isInline", n.Title = "title", n.IsReadOnlySupported = "isReadOnlySupported", n))(We || {});
var mt = /* @__PURE__ */ ((n) => (n.IsTune = "isTune", n))(mt || {});

class Tt {
  constructor({
    name: e,
    constructable: t,
    config: o,
    api: i,
    isDefault: s,
    isInternal: r = false,
    defaultPlaceholder: a
  }) {
    this.api = i, this.name = e, this.constructable = t, this.config = o, this.isDefault = s, this.isInternal = r, this.defaultPlaceholder = a;
  }
  get settings() {
    const e = this.config.config || {};
    return this.isDefault && !("placeholder" in e) && this.defaultPlaceholder && (e.placeholder = this.defaultPlaceholder), e;
  }
  reset() {
    if (A(this.constructable.reset))
      return this.constructable.reset();
  }
  prepare() {
    if (A(this.constructable.prepare))
      return this.constructable.prepare({
        toolName: this.name,
        config: this.settings
      });
  }
  get shortcut() {
    const e = this.constructable.shortcut;
    return this.config.shortcut || e;
  }
  get sanitizeConfig() {
    return this.constructable.sanitize || {};
  }
  isInline() {
    return this.type === ae.Inline;
  }
  isBlock() {
    return this.type === ae.Block;
  }
  isTune() {
    return this.type === ae.Tune;
  }
}

class Cs extends E {
  constructor({ config: e, eventsDispatcher: t }) {
    super({
      config: e,
      eventsDispatcher: t
    }), this.CSS = {
      inlineToolbar: "ce-inline-toolbar"
    }, this.opened = false, this.popover = null, this.toolbarVerticalMargin = be() ? 20 : 6, this.tools = /* @__PURE__ */ new Map, window.requestIdleCallback(() => {
      this.make();
    }, { timeout: 2000 });
  }
  async tryToShow(e = false) {
    e && this.close(), this.allowedToShow() && (await this.open(), this.Editor.Toolbar.close());
  }
  close() {
    var e, t;
    if (this.opened) {
      for (const [o, i] of this.tools) {
        const s = this.getToolShortcut(o.name);
        s !== undefined && ge.remove(this.Editor.UI.nodes.redactor, s), A(i.clear) && i.clear();
      }
      this.tools = /* @__PURE__ */ new Map, this.reset(), this.opened = false, (e = this.popover) == null || e.hide(), (t = this.popover) == null || t.destroy(), this.popover = null;
    }
  }
  containsNode(e) {
    return this.nodes.wrapper === undefined ? false : this.nodes.wrapper.contains(e);
  }
  destroy() {
    var e;
    this.removeAllNodes(), (e = this.popover) == null || e.destroy(), this.popover = null;
  }
  make() {
    this.nodes.wrapper = d.make("div", [
      this.CSS.inlineToolbar,
      ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []
    ]), this.nodes.wrapper.setAttribute("data-cy", "inline-toolbar"), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);
  }
  async open() {
    var t;
    if (this.opened)
      return;
    this.opened = true, this.popover !== null && this.popover.destroy(), this.createToolsInstances();
    const e = await this.getPopoverItems();
    this.popover = new hs({
      items: e,
      scopeElement: this.Editor.API.methods.ui.nodes.redactor,
      messages: {
        nothingFound: z.ui(K.ui.popover, "Nothing found"),
        search: z.ui(K.ui.popover, "Filter")
      }
    }), this.move(this.popover.size.width), (t = this.nodes.wrapper) == null || t.append(this.popover.getElement()), this.popover.show();
  }
  move(e) {
    const t = b.rect, o = this.Editor.UI.nodes.wrapper.getBoundingClientRect(), i = {
      x: t.x - o.x,
      y: t.y + t.height - o.top + this.toolbarVerticalMargin
    };
    i.x + e + o.x > this.Editor.UI.contentRect.right && (i.x = this.Editor.UI.contentRect.right - e - o.x), this.nodes.wrapper.style.left = Math.floor(i.x) + "px", this.nodes.wrapper.style.top = Math.floor(i.y) + "px";
  }
  reset() {
    this.nodes.wrapper.style.left = "0", this.nodes.wrapper.style.top = "0";
  }
  allowedToShow() {
    const e = ["IMG", "INPUT"], t = b.get(), o = b.text;
    if (!t || !t.anchorNode || t.isCollapsed || o.length < 1)
      return false;
    const i = d.isElement(t.anchorNode) ? t.anchorNode : t.anchorNode.parentElement;
    if (i === null || t !== null && e.includes(i.tagName))
      return false;
    const s = this.Editor.BlockManager.getBlock(t.anchorNode);
    return !s || this.getTools().some((c) => s.tool.inlineTools.has(c.name)) === false ? false : i.closest("[contenteditable]") !== null;
  }
  getTools() {
    const e = this.Editor.BlockManager.currentBlock;
    return e ? Array.from(e.tool.inlineTools.values()).filter((o) => !(this.Editor.ReadOnly.isEnabled && o.isReadOnlySupported !== true)) : [];
  }
  createToolsInstances() {
    this.tools = /* @__PURE__ */ new Map, this.getTools().forEach((t) => {
      const o = t.create();
      this.tools.set(t, o);
    });
  }
  async getPopoverItems() {
    const e = [];
    let t = 0;
    for (const [o, i] of this.tools) {
      const s = await i.render(), r = this.getToolShortcut(o.name);
      if (r !== undefined)
        try {
          this.enableShortcuts(o.name, r);
        } catch {
        }
      const a = r !== undefined ? vt(r) : undefined, l = z.t(K.toolNames, o.title || je(o.name));
      [s].flat().forEach((c) => {
        var h, p;
        const u = {
          name: o.name,
          onActivate: () => {
            this.toolClicked(i);
          },
          hint: {
            title: l,
            description: a
          }
        };
        if (d.isElement(c)) {
          const g = {
            ...u,
            element: c,
            type: _.Html
          };
          if (A(i.renderActions)) {
            const f = i.renderActions();
            g.children = {
              isOpen: (h = i.checkState) == null ? undefined : h.call(i, b.get()),
              isFlippable: false,
              items: [
                {
                  type: _.Html,
                  element: f
                }
              ]
            };
          } else
            (p = i.checkState) == null || p.call(i, b.get());
          e.push(g);
        } else if (c.type === _.Html)
          e.push({
            ...u,
            ...c,
            type: _.Html
          });
        else if (c.type === _.Separator)
          e.push({
            type: _.Separator
          });
        else {
          const g = {
            ...u,
            ...c,
            type: _.Default
          };
          "children" in g && t !== 0 && e.push({
            type: _.Separator
          }), e.push(g), "children" in g && t < this.tools.size - 1 && e.push({
            type: _.Separator
          });
        }
      }), t++;
    }
    return e;
  }
  getToolShortcut(e) {
    const { Tools: t } = this.Editor, o = t.inlineTools.get(e), i = t.internal.inlineTools;
    return Array.from(i.keys()).includes(e) ? this.inlineTools[e][cn.Shortcut] : o == null ? undefined : o.shortcut;
  }
  enableShortcuts(e, t) {
    ge.add({
      name: t,
      handler: (o) => {
        var s;
        const { currentBlock: i } = this.Editor.BlockManager;
        i && i.tool.enabledInlineTools && (o.preventDefault(), (s = this.popover) == null || s.activateItemByName(e));
      },
      on: document
    });
  }
  toolClicked(e) {
    var o;
    const t = b.range;
    (o = e.surround) == null || o.call(e, t), this.checkToolsState();
  }
  checkToolsState() {
    var e;
    (e = this.tools) == null || e.forEach((t) => {
      var o;
      (o = t.checkState) == null || o.call(t, b.get());
    });
  }
  get inlineTools() {
    const e = {};
    return Array.from(this.Editor.Tools.inlineTools.entries()).forEach(([t, o]) => {
      e[t] = o.create();
    }), e;
  }
}
function dn() {
  const n = window.getSelection();
  if (n === null)
    return [null, 0];
  let { focusNode: e, focusOffset: t } = n;
  return e === null ? [null, 0] : (e.nodeType !== Node.TEXT_NODE && e.childNodes.length > 0 && (e.childNodes[t] ? (e = e.childNodes[t], t = 0) : (e = e.childNodes[t - 1], t = e.textContent.length)), [e, t]);
}
function un(n, e, t, o) {
  const i = document.createRange();
  o === "left" ? (i.setStart(n, 0), i.setEnd(e, t)) : (i.setStart(e, t), i.setEnd(n, n.childNodes.length));
  const s = i.cloneContents(), r = document.createElement("div");
  r.appendChild(s);
  const a = r.textContent || "";
  return ai(a);
}
function Ne(n) {
  const e = d.getDeepestNode(n);
  if (e === null || d.isEmpty(n))
    return true;
  if (d.isNativeInput(e))
    return e.selectionEnd === 0;
  if (d.isEmpty(n))
    return true;
  const [t, o] = dn();
  return t === null ? false : un(n, t, o, "left");
}
function Re(n) {
  const e = d.getDeepestNode(n, true);
  if (e === null)
    return true;
  if (d.isNativeInput(e))
    return e.selectionEnd === e.value.length;
  const [t, o] = dn();
  return t === null ? false : un(n, t, o, "right");
}
var hn = {};
var St = {};
var Xe = {};
var de = {};
var It = {};
var Ot = {};
Object.defineProperty(Ot, "__esModule", { value: true });
Ot.allInputsSelector = Ts;
function Ts() {
  var n = ["text", "password", "email", "number", "search", "tel", "url"];
  return "[contenteditable=true], textarea, input:not([type]), " + n.map(function(e) {
    return 'input[type="'.concat(e, '"]');
  }).join(", ");
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.allInputsSelector = undefined;
  var e = Ot;
  Object.defineProperty(n, "allInputsSelector", { enumerable: true, get: function() {
    return e.allInputsSelector;
  } });
})(It);
var ue = {};
var _t = {};
Object.defineProperty(_t, "__esModule", { value: true });
_t.isNativeInput = Ss;
function Ss(n) {
  var e = [
    "INPUT",
    "TEXTAREA"
  ];
  return n && n.tagName ? e.includes(n.tagName) : false;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isNativeInput = undefined;
  var e = _t;
  Object.defineProperty(n, "isNativeInput", { enumerable: true, get: function() {
    return e.isNativeInput;
  } });
})(ue);
var pn = {};
var Mt = {};
Object.defineProperty(Mt, "__esModule", { value: true });
Mt.append = Is;
function Is(n, e) {
  Array.isArray(e) ? e.forEach(function(t) {
    n.appendChild(t);
  }) : n.appendChild(e);
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.append = undefined;
  var e = Mt;
  Object.defineProperty(n, "append", { enumerable: true, get: function() {
    return e.append;
  } });
})(pn);
var At = {};
var Lt = {};
Object.defineProperty(Lt, "__esModule", { value: true });
Lt.blockElements = Os;
function Os() {
  return [
    "address",
    "article",
    "aside",
    "blockquote",
    "canvas",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "hr",
    "li",
    "main",
    "nav",
    "noscript",
    "ol",
    "output",
    "p",
    "pre",
    "ruby",
    "section",
    "table",
    "tbody",
    "thead",
    "tr",
    "tfoot",
    "ul",
    "video"
  ];
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.blockElements = undefined;
  var e = Lt;
  Object.defineProperty(n, "blockElements", { enumerable: true, get: function() {
    return e.blockElements;
  } });
})(At);
var fn = {};
var Pt = {};
Object.defineProperty(Pt, "__esModule", { value: true });
Pt.calculateBaseline = _s;
function _s(n) {
  var e = window.getComputedStyle(n), t = parseFloat(e.fontSize), o = parseFloat(e.lineHeight) || t * 1.2, i = parseFloat(e.paddingTop), s = parseFloat(e.borderTopWidth), r = parseFloat(e.marginTop), a = t * 0.8, l = (o - t) / 2, c = r + s + i + l + a;
  return c;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.calculateBaseline = undefined;
  var e = Pt;
  Object.defineProperty(n, "calculateBaseline", { enumerable: true, get: function() {
    return e.calculateBaseline;
  } });
})(fn);
var gn = {};
var Nt = {};
var Rt = {};
var Dt = {};
Object.defineProperty(Dt, "__esModule", { value: true });
Dt.isContentEditable = Ms;
function Ms(n) {
  return n.contentEditable === "true";
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isContentEditable = undefined;
  var e = Dt;
  Object.defineProperty(n, "isContentEditable", { enumerable: true, get: function() {
    return e.isContentEditable;
  } });
})(Rt);
Object.defineProperty(Nt, "__esModule", { value: true });
Nt.canSetCaret = Ps;
var As = ue;
var Ls = Rt;
function Ps(n) {
  var e = true;
  if ((0, As.isNativeInput)(n))
    switch (n.type) {
      case "file":
      case "checkbox":
      case "radio":
      case "hidden":
      case "submit":
      case "button":
      case "image":
      case "reset":
        e = false;
        break;
    }
  else
    e = (0, Ls.isContentEditable)(n);
  return e;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.canSetCaret = undefined;
  var e = Nt;
  Object.defineProperty(n, "canSetCaret", { enumerable: true, get: function() {
    return e.canSetCaret;
  } });
})(gn);
var Ve = {};
var Ft = {};
function Ns(n, e, t) {
  const o = t.value !== undefined ? "value" : "get", i = t[o], s = `#${e}Cache`;
  if (t[o] = function(...r) {
    return this[s] === undefined && (this[s] = i.apply(this, r)), this[s];
  }, o === "get" && t.set) {
    const r = t.set;
    t.set = function(a) {
      delete n[s], r.apply(this, a);
    };
  }
  return t;
}
function mn() {
  const n = {
    win: false,
    mac: false,
    x11: false,
    linux: false
  }, e = Object.keys(n).find((t) => window.navigator.appVersion.toLowerCase().indexOf(t) !== -1);
  return e !== undefined && (n[e] = true), n;
}
function jt(n) {
  return n != null && n !== "" && (typeof n != "object" || Object.keys(n).length > 0);
}
function Rs(n) {
  return !jt(n);
}
var Ds = () => typeof window < "u" && window.navigator !== null && jt(window.navigator.platform) && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
function Fs(n) {
  const e = mn();
  return n = n.replace(/shift/gi, "⇧").replace(/backspace/gi, "⌫").replace(/enter/gi, "⏎").replace(/up/gi, "↑").replace(/left/gi, "→").replace(/down/gi, "↓").replace(/right/gi, "←").replace(/escape/gi, "⎋").replace(/insert/gi, "Ins").replace(/delete/gi, "␡").replace(/\+/gi, "+"), e.mac ? n = n.replace(/ctrl|cmd/gi, "⌘").replace(/alt/gi, "⌥") : n = n.replace(/cmd/gi, "Ctrl").replace(/windows/gi, "WIN"), n;
}
function js(n) {
  return n[0].toUpperCase() + n.slice(1);
}
function Hs(n) {
  const e = document.createElement("div");
  e.style.position = "absolute", e.style.left = "-999px", e.style.bottom = "-999px", e.innerHTML = n, document.body.appendChild(e);
  const t = window.getSelection(), o = document.createRange();
  if (o.selectNode(e), t === null)
    throw new Error("Cannot copy text to clipboard");
  t.removeAllRanges(), t.addRange(o), document.execCommand("copy"), document.body.removeChild(e);
}
function $s(n, e, t) {
  let o;
  return (...i) => {
    const s = this, r = () => {
      o = undefined, t !== true && n.apply(s, i);
    }, a = t === true && o !== undefined;
    window.clearTimeout(o), o = window.setTimeout(r, e), a && n.apply(s, i);
  };
}
function oe(n) {
  return Object.prototype.toString.call(n).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
}
function zs(n) {
  return oe(n) === "boolean";
}
function bn(n) {
  return oe(n) === "function" || oe(n) === "asyncfunction";
}
function Us(n) {
  return bn(n) && /^\s*class\s+/.test(n.toString());
}
function Ws(n) {
  return oe(n) === "number";
}
function De(n) {
  return oe(n) === "object";
}
function Ys(n) {
  return Promise.resolve(n) === n;
}
function Ks(n) {
  return oe(n) === "string";
}
function Xs(n) {
  return oe(n) === "undefined";
}
function bt(n, ...e) {
  if (!e.length)
    return n;
  const t = e.shift();
  if (De(n) && De(t))
    for (const o in t)
      De(t[o]) ? (n[o] === undefined && Object.assign(n, { [o]: {} }), bt(n[o], t[o])) : Object.assign(n, { [o]: t[o] });
  return bt(n, ...e);
}
function Vs(n, e, t) {
  const o = `«${e}» is deprecated and will be removed in the next major release. Please use the «${t}» instead.`;
  n && console.warn(o);
}
function qs(n) {
  try {
    return new URL(n).href;
  } catch {
  }
  return n.substring(0, 2) === "//" ? window.location.protocol + n : window.location.origin + n;
}
function Zs(n) {
  return n > 47 && n < 58 || n === 32 || n === 13 || n === 229 || n > 64 && n < 91 || n > 95 && n < 112 || n > 185 && n < 193 || n > 218 && n < 223;
}
var Gs = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  ESC: 27,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  DOWN: 40,
  RIGHT: 39,
  DELETE: 46,
  META: 91,
  SLASH: 191
};
var Qs = {
  LEFT: 0,
  WHEEL: 1,
  RIGHT: 2,
  BACKWARD: 3,
  FORWARD: 4
};
var Js = class {
  constructor() {
    this.completed = Promise.resolve();
  }
  add(e) {
    return new Promise((t, o) => {
      this.completed = this.completed.then(e).then(t).catch(o);
    });
  }
};
function er(n, e, t = undefined) {
  let o, i, s, r = null, a = 0;
  t || (t = {});
  const l = function() {
    a = t.leading === false ? 0 : Date.now(), r = null, s = n.apply(o, i), r === null && (o = i = null);
  };
  return function() {
    const c = Date.now();
    !a && t.leading === false && (a = c);
    const u = e - (c - a);
    return o = this, i = arguments, u <= 0 || u > e ? (r && (clearTimeout(r), r = null), a = c, s = n.apply(o, i), r === null && (o = i = null)) : !r && t.trailing !== false && (r = setTimeout(l, u)), s;
  };
}
var tr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PromiseQueue: Js,
  beautifyShortcut: Fs,
  cacheable: Ns,
  capitalize: js,
  copyTextToClipboard: Hs,
  debounce: $s,
  deepMerge: bt,
  deprecationAssert: Vs,
  getUserOS: mn,
  getValidUrl: qs,
  isBoolean: zs,
  isClass: Us,
  isEmpty: Rs,
  isFunction: bn,
  isIosDevice: Ds,
  isNumber: Ws,
  isObject: De,
  isPrintableKey: Zs,
  isPromise: Ys,
  isString: Ks,
  isUndefined: Xs,
  keyCodes: Gs,
  mouseButtons: Qs,
  notEmpty: jt,
  throttle: er,
  typeOf: oe
}, Symbol.toStringTag, { value: "Module" }));
var Ht = /* @__PURE__ */ Xn(tr);
Object.defineProperty(Ft, "__esModule", { value: true });
Ft.containsOnlyInlineElements = ir;
var or = Ht;
var nr = At;
function ir(n) {
  var e;
  (0, or.isString)(n) ? (e = document.createElement("div"), e.innerHTML = n) : e = n;
  var t = function(o) {
    return !(0, nr.blockElements)().includes(o.tagName.toLowerCase()) && Array.from(o.children).every(t);
  };
  return Array.from(e.children).every(t);
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.containsOnlyInlineElements = undefined;
  var e = Ft;
  Object.defineProperty(n, "containsOnlyInlineElements", { enumerable: true, get: function() {
    return e.containsOnlyInlineElements;
  } });
})(Ve);
var vn = {};
var $t = {};
var qe = {};
var zt = {};
Object.defineProperty(zt, "__esModule", { value: true });
zt.make = sr;
function sr(n, e, t) {
  var o;
  e === undefined && (e = null), t === undefined && (t = {});
  var i = document.createElement(n);
  if (Array.isArray(e)) {
    var s = e.filter(function(a) {
      return a !== undefined;
    });
    (o = i.classList).add.apply(o, s);
  } else
    e !== null && i.classList.add(e);
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]);
  return i;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.make = undefined;
  var e = zt;
  Object.defineProperty(n, "make", { enumerable: true, get: function() {
    return e.make;
  } });
})(qe);
Object.defineProperty($t, "__esModule", { value: true });
$t.fragmentToString = ar;
var rr = qe;
function ar(n) {
  var e = (0, rr.make)("div");
  return e.appendChild(n), e.innerHTML;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.fragmentToString = undefined;
  var e = $t;
  Object.defineProperty(n, "fragmentToString", { enumerable: true, get: function() {
    return e.fragmentToString;
  } });
})(vn);
var kn = {};
var Ut = {};
Object.defineProperty(Ut, "__esModule", { value: true });
Ut.getContentLength = cr;
var lr = ue;
function cr(n) {
  var e, t;
  return (0, lr.isNativeInput)(n) ? n.value.length : n.nodeType === Node.TEXT_NODE ? n.length : (t = (e = n.textContent) === null || e === undefined ? undefined : e.length) !== null && t !== undefined ? t : 0;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.getContentLength = undefined;
  var e = Ut;
  Object.defineProperty(n, "getContentLength", { enumerable: true, get: function() {
    return e.getContentLength;
  } });
})(kn);
var Wt = {};
var Yt = {};
var Io = Ce && Ce.__spreadArray || function(n, e, t) {
  if (t || arguments.length === 2)
    for (var o = 0, i = e.length, s;o < i; o++)
      (s || !(o in e)) && (s || (s = Array.prototype.slice.call(e, 0, o)), s[o] = e[o]);
  return n.concat(s || Array.prototype.slice.call(e));
};
Object.defineProperty(Yt, "__esModule", { value: true });
Yt.getDeepestBlockElements = yn;
var dr = Ve;
function yn(n) {
  return (0, dr.containsOnlyInlineElements)(n) ? [n] : Array.from(n.children).reduce(function(e, t) {
    return Io(Io([], e, true), yn(t), true);
  }, []);
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.getDeepestBlockElements = undefined;
  var e = Yt;
  Object.defineProperty(n, "getDeepestBlockElements", { enumerable: true, get: function() {
    return e.getDeepestBlockElements;
  } });
})(Wt);
var wn = {};
var Kt = {};
var Ze = {};
var Xt = {};
Object.defineProperty(Xt, "__esModule", { value: true });
Xt.isLineBreakTag = ur;
function ur(n) {
  return [
    "BR",
    "WBR"
  ].includes(n.tagName);
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isLineBreakTag = undefined;
  var e = Xt;
  Object.defineProperty(n, "isLineBreakTag", { enumerable: true, get: function() {
    return e.isLineBreakTag;
  } });
})(Ze);
var Ge = {};
var Vt = {};
Object.defineProperty(Vt, "__esModule", { value: true });
Vt.isSingleTag = hr;
function hr(n) {
  return [
    "AREA",
    "BASE",
    "BR",
    "COL",
    "COMMAND",
    "EMBED",
    "HR",
    "IMG",
    "INPUT",
    "KEYGEN",
    "LINK",
    "META",
    "PARAM",
    "SOURCE",
    "TRACK",
    "WBR"
  ].includes(n.tagName);
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isSingleTag = undefined;
  var e = Vt;
  Object.defineProperty(n, "isSingleTag", { enumerable: true, get: function() {
    return e.isSingleTag;
  } });
})(Ge);
Object.defineProperty(Kt, "__esModule", { value: true });
Kt.getDeepestNode = En;
var pr = ue;
var fr = Ze;
var gr = Ge;
function En(n, e) {
  e === undefined && (e = false);
  var t = e ? "lastChild" : "firstChild", o = e ? "previousSibling" : "nextSibling";
  if (n.nodeType === Node.ELEMENT_NODE && n[t]) {
    var i = n[t];
    if ((0, gr.isSingleTag)(i) && !(0, pr.isNativeInput)(i) && !(0, fr.isLineBreakTag)(i))
      if (i[o])
        i = i[o];
      else if (i.parentNode !== null && i.parentNode[o])
        i = i.parentNode[o];
      else
        return i.parentNode;
    return En(i, e);
  }
  return n;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.getDeepestNode = undefined;
  var e = Kt;
  Object.defineProperty(n, "getDeepestNode", { enumerable: true, get: function() {
    return e.getDeepestNode;
  } });
})(wn);
var xn = {};
var qt = {};
var Me = Ce && Ce.__spreadArray || function(n, e, t) {
  if (t || arguments.length === 2)
    for (var o = 0, i = e.length, s;o < i; o++)
      (s || !(o in e)) && (s || (s = Array.prototype.slice.call(e, 0, o)), s[o] = e[o]);
  return n.concat(s || Array.prototype.slice.call(e));
};
Object.defineProperty(qt, "__esModule", { value: true });
qt.findAllInputs = yr;
var mr = Ve;
var br = Wt;
var vr = It;
var kr = ue;
function yr(n) {
  return Array.from(n.querySelectorAll((0, vr.allInputsSelector)())).reduce(function(e, t) {
    return (0, kr.isNativeInput)(t) || (0, mr.containsOnlyInlineElements)(t) ? Me(Me([], e, true), [t], false) : Me(Me([], e, true), (0, br.getDeepestBlockElements)(t), true);
  }, []);
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.findAllInputs = undefined;
  var e = qt;
  Object.defineProperty(n, "findAllInputs", { enumerable: true, get: function() {
    return e.findAllInputs;
  } });
})(xn);
var Bn = {};
var Zt = {};
Object.defineProperty(Zt, "__esModule", { value: true });
Zt.isCollapsedWhitespaces = wr;
function wr(n) {
  return !/[^\t\n\r ]/.test(n);
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isCollapsedWhitespaces = undefined;
  var e = Zt;
  Object.defineProperty(n, "isCollapsedWhitespaces", { enumerable: true, get: function() {
    return e.isCollapsedWhitespaces;
  } });
})(Bn);
var Gt = {};
var Qt = {};
Object.defineProperty(Qt, "__esModule", { value: true });
Qt.isElement = xr;
var Er = Ht;
function xr(n) {
  return (0, Er.isNumber)(n) ? false : !!n && !!n.nodeType && n.nodeType === Node.ELEMENT_NODE;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isElement = undefined;
  var e = Qt;
  Object.defineProperty(n, "isElement", { enumerable: true, get: function() {
    return e.isElement;
  } });
})(Gt);
var Cn = {};
var Jt = {};
var eo = {};
var to = {};
Object.defineProperty(to, "__esModule", { value: true });
to.isLeaf = Br;
function Br(n) {
  return n === null ? false : n.childNodes.length === 0;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isLeaf = undefined;
  var e = to;
  Object.defineProperty(n, "isLeaf", { enumerable: true, get: function() {
    return e.isLeaf;
  } });
})(eo);
var oo = {};
var no = {};
Object.defineProperty(no, "__esModule", { value: true });
no.isNodeEmpty = Or;
var Cr = Ze;
var Tr = Gt;
var Sr = ue;
var Ir = Ge;
function Or(n, e) {
  var t = "";
  return (0, Ir.isSingleTag)(n) && !(0, Cr.isLineBreakTag)(n) ? false : ((0, Tr.isElement)(n) && (0, Sr.isNativeInput)(n) ? t = n.value : n.textContent !== null && (t = n.textContent.replace("​", "")), e !== undefined && (t = t.replace(new RegExp(e, "g"), "")), t.trim().length === 0);
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isNodeEmpty = undefined;
  var e = no;
  Object.defineProperty(n, "isNodeEmpty", { enumerable: true, get: function() {
    return e.isNodeEmpty;
  } });
})(oo);
Object.defineProperty(Jt, "__esModule", { value: true });
Jt.isEmpty = Ar;
var _r = eo;
var Mr = oo;
function Ar(n, e) {
  n.normalize();
  for (var t = [n];t.length > 0; ) {
    var o = t.shift();
    if (o) {
      if (n = o, (0, _r.isLeaf)(n) && !(0, Mr.isNodeEmpty)(n, e))
        return false;
      t.push.apply(t, Array.from(n.childNodes));
    }
  }
  return true;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isEmpty = undefined;
  var e = Jt;
  Object.defineProperty(n, "isEmpty", { enumerable: true, get: function() {
    return e.isEmpty;
  } });
})(Cn);
var Tn = {};
var io = {};
Object.defineProperty(io, "__esModule", { value: true });
io.isFragment = Pr;
var Lr = Ht;
function Pr(n) {
  return (0, Lr.isNumber)(n) ? false : !!n && !!n.nodeType && n.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isFragment = undefined;
  var e = io;
  Object.defineProperty(n, "isFragment", { enumerable: true, get: function() {
    return e.isFragment;
  } });
})(Tn);
var Sn = {};
var so = {};
Object.defineProperty(so, "__esModule", { value: true });
so.isHTMLString = Rr;
var Nr = qe;
function Rr(n) {
  var e = (0, Nr.make)("div");
  return e.innerHTML = n, e.childElementCount > 0;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isHTMLString = undefined;
  var e = so;
  Object.defineProperty(n, "isHTMLString", { enumerable: true, get: function() {
    return e.isHTMLString;
  } });
})(Sn);
var In = {};
var ro = {};
Object.defineProperty(ro, "__esModule", { value: true });
ro.offset = Dr;
function Dr(n) {
  var e = n.getBoundingClientRect(), t = window.pageXOffset || document.documentElement.scrollLeft, o = window.pageYOffset || document.documentElement.scrollTop, i = e.top + o, s = e.left + t;
  return {
    top: i,
    left: s,
    bottom: i + e.height,
    right: s + e.width
  };
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.offset = undefined;
  var e = ro;
  Object.defineProperty(n, "offset", { enumerable: true, get: function() {
    return e.offset;
  } });
})(In);
var On = {};
var ao = {};
Object.defineProperty(ao, "__esModule", { value: true });
ao.prepend = Fr;
function Fr(n, e) {
  Array.isArray(e) ? (e = e.reverse(), e.forEach(function(t) {
    return n.prepend(t);
  })) : n.prepend(e);
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.prepend = undefined;
  var e = ao;
  Object.defineProperty(n, "prepend", { enumerable: true, get: function() {
    return e.prepend;
  } });
})(On);
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.prepend = n.offset = n.make = n.isLineBreakTag = n.isSingleTag = n.isNodeEmpty = n.isLeaf = n.isHTMLString = n.isFragment = n.isEmpty = n.isElement = n.isContentEditable = n.isCollapsedWhitespaces = n.findAllInputs = n.isNativeInput = n.allInputsSelector = n.getDeepestNode = n.getDeepestBlockElements = n.getContentLength = n.fragmentToString = n.containsOnlyInlineElements = n.canSetCaret = n.calculateBaseline = n.blockElements = n.append = undefined;
  var e = It;
  Object.defineProperty(n, "allInputsSelector", { enumerable: true, get: function() {
    return e.allInputsSelector;
  } });
  var t = ue;
  Object.defineProperty(n, "isNativeInput", { enumerable: true, get: function() {
    return t.isNativeInput;
  } });
  var o = pn;
  Object.defineProperty(n, "append", { enumerable: true, get: function() {
    return o.append;
  } });
  var i = At;
  Object.defineProperty(n, "blockElements", { enumerable: true, get: function() {
    return i.blockElements;
  } });
  var s = fn;
  Object.defineProperty(n, "calculateBaseline", { enumerable: true, get: function() {
    return s.calculateBaseline;
  } });
  var r = gn;
  Object.defineProperty(n, "canSetCaret", { enumerable: true, get: function() {
    return r.canSetCaret;
  } });
  var a = Ve;
  Object.defineProperty(n, "containsOnlyInlineElements", { enumerable: true, get: function() {
    return a.containsOnlyInlineElements;
  } });
  var l = vn;
  Object.defineProperty(n, "fragmentToString", { enumerable: true, get: function() {
    return l.fragmentToString;
  } });
  var c = kn;
  Object.defineProperty(n, "getContentLength", { enumerable: true, get: function() {
    return c.getContentLength;
  } });
  var u = Wt;
  Object.defineProperty(n, "getDeepestBlockElements", { enumerable: true, get: function() {
    return u.getDeepestBlockElements;
  } });
  var h = wn;
  Object.defineProperty(n, "getDeepestNode", { enumerable: true, get: function() {
    return h.getDeepestNode;
  } });
  var p = xn;
  Object.defineProperty(n, "findAllInputs", { enumerable: true, get: function() {
    return p.findAllInputs;
  } });
  var g = Bn;
  Object.defineProperty(n, "isCollapsedWhitespaces", { enumerable: true, get: function() {
    return g.isCollapsedWhitespaces;
  } });
  var f = Rt;
  Object.defineProperty(n, "isContentEditable", { enumerable: true, get: function() {
    return f.isContentEditable;
  } });
  var v = Gt;
  Object.defineProperty(n, "isElement", { enumerable: true, get: function() {
    return v.isElement;
  } });
  var O = Cn;
  Object.defineProperty(n, "isEmpty", { enumerable: true, get: function() {
    return O.isEmpty;
  } });
  var T = Tn;
  Object.defineProperty(n, "isFragment", { enumerable: true, get: function() {
    return T.isFragment;
  } });
  var M = Sn;
  Object.defineProperty(n, "isHTMLString", { enumerable: true, get: function() {
    return M.isHTMLString;
  } });
  var q = eo;
  Object.defineProperty(n, "isLeaf", { enumerable: true, get: function() {
    return q.isLeaf;
  } });
  var F = oo;
  Object.defineProperty(n, "isNodeEmpty", { enumerable: true, get: function() {
    return F.isNodeEmpty;
  } });
  var H = Ze;
  Object.defineProperty(n, "isLineBreakTag", { enumerable: true, get: function() {
    return H.isLineBreakTag;
  } });
  var Q = Ge;
  Object.defineProperty(n, "isSingleTag", { enumerable: true, get: function() {
    return Q.isSingleTag;
  } });
  var ie = qe;
  Object.defineProperty(n, "make", { enumerable: true, get: function() {
    return ie.make;
  } });
  var k = In;
  Object.defineProperty(n, "offset", { enumerable: true, get: function() {
    return k.offset;
  } });
  var m = On;
  Object.defineProperty(n, "prepend", { enumerable: true, get: function() {
    return m.prepend;
  } });
})(de);
var Qe = {};
Object.defineProperty(Qe, "__esModule", { value: true });
Qe.getContenteditableSlice = Hr;
var jr = de;
function Hr(n, e, t, o, i) {
  var s;
  i === undefined && (i = false);
  var r = document.createRange();
  if (o === "left" ? (r.setStart(n, 0), r.setEnd(e, t)) : (r.setStart(e, t), r.setEnd(n, n.childNodes.length)), i === true) {
    var a = r.extractContents();
    return (0, jr.fragmentToString)(a);
  }
  var l = r.cloneContents(), c = document.createElement("div");
  c.appendChild(l);
  var u = (s = c.textContent) !== null && s !== undefined ? s : "";
  return u;
}
Object.defineProperty(Xe, "__esModule", { value: true });
Xe.checkContenteditableSliceForEmptiness = Ur;
var $r = de;
var zr = Qe;
function Ur(n, e, t, o) {
  var i = (0, zr.getContenteditableSlice)(n, e, t, o);
  return (0, $r.isCollapsedWhitespaces)(i);
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.checkContenteditableSliceForEmptiness = undefined;
  var e = Xe;
  Object.defineProperty(n, "checkContenteditableSliceForEmptiness", { enumerable: true, get: function() {
    return e.checkContenteditableSliceForEmptiness;
  } });
})(St);
var _n = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.getContenteditableSlice = undefined;
  var e = Qe;
  Object.defineProperty(n, "getContenteditableSlice", { enumerable: true, get: function() {
    return e.getContenteditableSlice;
  } });
})(_n);
var Mn = {};
var lo = {};
Object.defineProperty(lo, "__esModule", { value: true });
lo.focus = Yr;
var Wr = de;
function Yr(n, e) {
  var t, o;
  if (e === undefined && (e = true), (0, Wr.isNativeInput)(n)) {
    n.focus();
    var i = e ? 0 : n.value.length;
    n.setSelectionRange(i, i);
  } else {
    var s = document.createRange(), r = window.getSelection();
    if (!r)
      return;
    var a = function(p) {
      var g = document.createTextNode("");
      p.appendChild(g), s.setStart(g, 0), s.setEnd(g, 0);
    }, l = function(p) {
      return p != null;
    }, c = n.childNodes, u = e ? c[0] : c[c.length - 1];
    if (l(u)) {
      for (;l(u) && u.nodeType !== Node.TEXT_NODE; )
        u = e ? u.firstChild : u.lastChild;
      if (l(u) && u.nodeType === Node.TEXT_NODE) {
        var h = (o = (t = u.textContent) === null || t === undefined ? undefined : t.length) !== null && o !== undefined ? o : 0, i = e ? 0 : h;
        s.setStart(u, i), s.setEnd(u, i);
      } else
        a(n);
    } else
      a(n);
    r.removeAllRanges(), r.addRange(s);
  }
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.focus = undefined;
  var e = lo;
  Object.defineProperty(n, "focus", { enumerable: true, get: function() {
    return e.focus;
  } });
})(Mn);
var co = {};
var Je = {};
Object.defineProperty(Je, "__esModule", { value: true });
Je.getCaretNodeAndOffset = Kr;
function Kr() {
  var n = window.getSelection();
  if (n === null)
    return [null, 0];
  var { focusNode: e, focusOffset: t } = n;
  return e === null ? [null, 0] : (e.nodeType !== Node.TEXT_NODE && e.childNodes.length > 0 && (e.childNodes[t] !== undefined ? (e = e.childNodes[t], t = 0) : (e = e.childNodes[t - 1], e.textContent !== null && (t = e.textContent.length))), [e, t]);
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.getCaretNodeAndOffset = undefined;
  var e = Je;
  Object.defineProperty(n, "getCaretNodeAndOffset", { enumerable: true, get: function() {
    return e.getCaretNodeAndOffset;
  } });
})(co);
var An = {};
var et = {};
Object.defineProperty(et, "__esModule", { value: true });
et.getRange = Xr;
function Xr() {
  var n = window.getSelection();
  return n && n.rangeCount ? n.getRangeAt(0) : null;
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.getRange = undefined;
  var e = et;
  Object.defineProperty(n, "getRange", { enumerable: true, get: function() {
    return e.getRange;
  } });
})(An);
var Ln = {};
var uo = {};
Object.defineProperty(uo, "__esModule", { value: true });
uo.isCaretAtEndOfInput = Zr;
var Oo = de;
var Vr = co;
var qr = St;
function Zr(n) {
  var e = (0, Oo.getDeepestNode)(n, true);
  if (e === null)
    return true;
  if ((0, Oo.isNativeInput)(e))
    return e.selectionEnd === e.value.length;
  var t = (0, Vr.getCaretNodeAndOffset)(), o = t[0], i = t[1];
  return o === null ? false : (0, qr.checkContenteditableSliceForEmptiness)(n, o, i, "right");
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isCaretAtEndOfInput = undefined;
  var e = uo;
  Object.defineProperty(n, "isCaretAtEndOfInput", { enumerable: true, get: function() {
    return e.isCaretAtEndOfInput;
  } });
})(Ln);
var Pn = {};
var ho = {};
Object.defineProperty(ho, "__esModule", { value: true });
ho.isCaretAtStartOfInput = Jr;
var Ae = de;
var Gr = Je;
var Qr = Xe;
function Jr(n) {
  var e = (0, Ae.getDeepestNode)(n);
  if (e === null || (0, Ae.isEmpty)(n))
    return true;
  if ((0, Ae.isNativeInput)(e))
    return e.selectionEnd === 0;
  if ((0, Ae.isEmpty)(n))
    return true;
  var t = (0, Gr.getCaretNodeAndOffset)(), o = t[0], i = t[1];
  return o === null ? false : (0, Qr.checkContenteditableSliceForEmptiness)(n, o, i, "left");
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.isCaretAtStartOfInput = undefined;
  var e = ho;
  Object.defineProperty(n, "isCaretAtStartOfInput", { enumerable: true, get: function() {
    return e.isCaretAtStartOfInput;
  } });
})(Pn);
var Nn = {};
var po = {};
Object.defineProperty(po, "__esModule", { value: true });
po.save = oa;
var ea = de;
var ta = et;
function oa() {
  var n = (0, ta.getRange)(), e = (0, ea.make)("span");
  if (e.id = "cursor", e.hidden = true, !!n)
    return n.insertNode(e), function() {
      var o = window.getSelection();
      o && (n.setStartAfter(e), n.setEndAfter(e), o.removeAllRanges(), o.addRange(n), setTimeout(function() {
        e.remove();
      }, 150));
    };
}
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.save = undefined;
  var e = po;
  Object.defineProperty(n, "save", { enumerable: true, get: function() {
    return e.save;
  } });
})(Nn);
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.save = n.isCaretAtStartOfInput = n.isCaretAtEndOfInput = n.getRange = n.getCaretNodeAndOffset = n.focus = n.getContenteditableSlice = n.checkContenteditableSliceForEmptiness = undefined;
  var e = St;
  Object.defineProperty(n, "checkContenteditableSliceForEmptiness", { enumerable: true, get: function() {
    return e.checkContenteditableSliceForEmptiness;
  } });
  var t = _n;
  Object.defineProperty(n, "getContenteditableSlice", { enumerable: true, get: function() {
    return t.getContenteditableSlice;
  } });
  var o = Mn;
  Object.defineProperty(n, "focus", { enumerable: true, get: function() {
    return o.focus;
  } });
  var i = co;
  Object.defineProperty(n, "getCaretNodeAndOffset", { enumerable: true, get: function() {
    return i.getCaretNodeAndOffset;
  } });
  var s = An;
  Object.defineProperty(n, "getRange", { enumerable: true, get: function() {
    return s.getRange;
  } });
  var r = Ln;
  Object.defineProperty(n, "isCaretAtEndOfInput", { enumerable: true, get: function() {
    return r.isCaretAtEndOfInput;
  } });
  var a = Pn;
  Object.defineProperty(n, "isCaretAtStartOfInput", { enumerable: true, get: function() {
    return a.isCaretAtStartOfInput;
  } });
  var l = Nn;
  Object.defineProperty(n, "save", { enumerable: true, get: function() {
    return l.save;
  } });
})(hn);

class na extends E {
  keydown(e) {
    switch (this.beforeKeydownProcessing(e), e.keyCode) {
      case y.BACKSPACE:
        this.backspace(e);
        break;
      case y.DELETE:
        this.delete(e);
        break;
      case y.ENTER:
        this.enter(e);
        break;
      case y.DOWN:
      case y.RIGHT:
        this.arrowRightAndDown(e);
        break;
      case y.UP:
      case y.LEFT:
        this.arrowLeftAndUp(e);
        break;
      case y.TAB:
        this.tabPressed(e);
        break;
    }
    e.key === "/" && !e.ctrlKey && !e.metaKey && this.slashPressed(e), e.code === "Slash" && (e.ctrlKey || e.metaKey) && (e.preventDefault(), this.commandSlashPressed());
  }
  beforeKeydownProcessing(e) {
    this.needToolbarClosing(e) && Po(e.keyCode) && (this.Editor.Toolbar.close(), e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || this.Editor.BlockSelection.clearSelection(e));
  }
  keyup(e) {
    e.shiftKey || this.Editor.UI.checkEmptiness();
  }
  dragOver(e) {
    const t = this.Editor.BlockManager.getBlockByChildNode(e.target);
    t.dropTarget = true;
  }
  dragLeave(e) {
    const t = this.Editor.BlockManager.getBlockByChildNode(e.target);
    t.dropTarget = false;
  }
  handleCommandC(e) {
    const { BlockSelection: t } = this.Editor;
    t.anyBlockSelected && t.copySelectedBlocks(e);
  }
  handleCommandX(e) {
    const { BlockSelection: t, BlockManager: o, Caret: i } = this.Editor;
    t.anyBlockSelected && t.copySelectedBlocks(e).then(() => {
      const s = o.removeSelectedBlocks(), r = o.insertDefaultBlockAtIndex(s, true);
      i.setToBlock(r, i.positions.START), t.clearSelection(e);
    });
  }
  tabPressed(e) {
    const { InlineToolbar: t, Caret: o } = this.Editor;
    if (t.opened)
      return;
    (e.shiftKey ? o.navigatePrevious(true) : o.navigateNext(true)) && e.preventDefault();
  }
  commandSlashPressed() {
    this.Editor.BlockSelection.selectedBlocks.length > 1 || this.activateBlockSettings();
  }
  slashPressed(e) {
    this.Editor.BlockManager.currentBlock.isEmpty && (e.preventDefault(), this.Editor.Caret.insertContentAtCaretPosition("/"), this.activateToolbox());
  }
  enter(e) {
    const { BlockManager: t, UI: o } = this.Editor, i = t.currentBlock;
    if (i === undefined || i.tool.isLineBreaksEnabled || o.someToolbarOpened && o.someFlipperButtonFocused || e.shiftKey && !pt)
      return;
    let s = i;
    i.currentInput !== undefined && Ne(i.currentInput) && !i.hasMedia ? this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex) : i.currentInput && Re(i.currentInput) ? s = this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex + 1) : s = this.Editor.BlockManager.split(), this.Editor.Caret.setToBlock(s), this.Editor.Toolbar.moveAndOpen(s), e.preventDefault();
  }
  backspace(e) {
    const { BlockManager: t, Caret: o } = this.Editor, { currentBlock: i, previousBlock: s } = t;
    if (i === undefined || !b.isCollapsed || !i.currentInput || !Ne(i.currentInput))
      return;
    if (e.preventDefault(), this.Editor.Toolbar.close(), !(i.currentInput === i.firstInput)) {
      o.navigatePrevious();
      return;
    }
    if (s === null)
      return;
    if (s.isEmpty) {
      t.removeBlock(s);
      return;
    }
    if (i.isEmpty) {
      t.removeBlock(i);
      const l = t.currentBlock;
      o.setToBlock(l, o.positions.END);
      return;
    }
    xo(s, i) ? this.mergeBlocks(s, i) : o.setToBlock(s, o.positions.END);
  }
  delete(e) {
    const { BlockManager: t, Caret: o } = this.Editor, { currentBlock: i, nextBlock: s } = t;
    if (!b.isCollapsed || !Re(i.currentInput))
      return;
    if (e.preventDefault(), this.Editor.Toolbar.close(), !(i.currentInput === i.lastInput)) {
      o.navigateNext();
      return;
    }
    if (s === null)
      return;
    if (s.isEmpty) {
      t.removeBlock(s);
      return;
    }
    if (i.isEmpty) {
      t.removeBlock(i), o.setToBlock(s, o.positions.START);
      return;
    }
    xo(i, s) ? this.mergeBlocks(i, s) : o.setToBlock(s, o.positions.START);
  }
  mergeBlocks(e, t) {
    const { BlockManager: o, Toolbar: i } = this.Editor;
    e.lastInput !== undefined && (hn.focus(e.lastInput, false), o.mergeBlocks(e, t).then(() => {
      i.close();
    }));
  }
  arrowRightAndDown(e) {
    const t = ce.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === y.TAB);
    if (this.Editor.UI.someToolbarOpened && t)
      return;
    this.Editor.Toolbar.close();
    const { currentBlock: o } = this.Editor.BlockManager, s = ((o == null ? undefined : o.currentInput) !== undefined ? Re(o.currentInput) : undefined) || this.Editor.BlockSelection.anyBlockSelected;
    if (e.shiftKey && e.keyCode === y.DOWN && s) {
      this.Editor.CrossBlockSelection.toggleBlockSelectedState();
      return;
    }
    if (e.keyCode === y.DOWN || e.keyCode === y.RIGHT && !this.isRtl ? this.Editor.Caret.navigateNext() : this.Editor.Caret.navigatePrevious()) {
      e.preventDefault();
      return;
    }
    Fe(() => {
      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();
    }, 20)(), this.Editor.BlockSelection.clearSelection(e);
  }
  arrowLeftAndUp(e) {
    if (this.Editor.UI.someToolbarOpened) {
      if (ce.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === y.TAB))
        return;
      this.Editor.UI.closeAllToolbars();
    }
    this.Editor.Toolbar.close();
    const { currentBlock: t } = this.Editor.BlockManager, i = ((t == null ? undefined : t.currentInput) !== undefined ? Ne(t.currentInput) : undefined) || this.Editor.BlockSelection.anyBlockSelected;
    if (e.shiftKey && e.keyCode === y.UP && i) {
      this.Editor.CrossBlockSelection.toggleBlockSelectedState(false);
      return;
    }
    if (e.keyCode === y.UP || e.keyCode === y.LEFT && !this.isRtl ? this.Editor.Caret.navigatePrevious() : this.Editor.Caret.navigateNext()) {
      e.preventDefault();
      return;
    }
    Fe(() => {
      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();
    }, 20)(), this.Editor.BlockSelection.clearSelection(e);
  }
  needToolbarClosing(e) {
    const t = e.keyCode === y.ENTER && this.Editor.Toolbar.toolbox.opened, o = e.keyCode === y.ENTER && this.Editor.BlockSettings.opened, i = e.keyCode === y.ENTER && this.Editor.InlineToolbar.opened, s = e.keyCode === y.TAB;
    return !(e.shiftKey || s || t || o || i);
  }
  activateToolbox() {
    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open();
  }
  activateBlockSettings() {
    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.opened || this.Editor.BlockSettings.open();
  }
}

class ct {
  constructor(e) {
    this.blocks = [], this.workingArea = e;
  }
  get length() {
    return this.blocks.length;
  }
  get array() {
    return this.blocks;
  }
  get nodes() {
    return No(this.workingArea.children);
  }
  static set(e, t, o) {
    return isNaN(Number(t)) ? (Reflect.set(e, t, o), true) : (e.insert(+t, o), true);
  }
  static get(e, t) {
    return isNaN(Number(t)) ? Reflect.get(e, t) : e.get(+t);
  }
  push(e) {
    this.blocks.push(e), this.insertToDOM(e);
  }
  swap(e, t) {
    const o = this.blocks[t];
    d.swap(this.blocks[e].holder, o.holder), this.blocks[t] = this.blocks[e], this.blocks[e] = o;
  }
  move(e, t) {
    const o = this.blocks.splice(t, 1)[0], i = e - 1, s = Math.max(0, i), r = this.blocks[s];
    e > 0 ? this.insertToDOM(o, "afterend", r) : this.insertToDOM(o, "beforebegin", r), this.blocks.splice(e, 0, o);
    const a = this.composeBlockEvent("move", {
      fromIndex: t,
      toIndex: e
    });
    o.call(ee.MOVED, a);
  }
  insert(e, t, o = false) {
    if (!this.length) {
      this.push(t);
      return;
    }
    e > this.length && (e = this.length), o && (this.blocks[e].holder.remove(), this.blocks[e].call(ee.REMOVED));
    const i = o ? 1 : 0;
    if (this.blocks.splice(e, i, t), e > 0) {
      const s = this.blocks[e - 1];
      this.insertToDOM(t, "afterend", s);
    } else {
      const s = this.blocks[e + 1];
      s ? this.insertToDOM(t, "beforebegin", s) : this.insertToDOM(t);
    }
  }
  replace(e, t) {
    if (this.blocks[e] === undefined)
      throw Error("Incorrect index");
    this.blocks[e].holder.replaceWith(t.holder), this.blocks[e] = t;
  }
  insertMany(e, t) {
    const o = new DocumentFragment;
    for (const i of e)
      o.appendChild(i.holder);
    if (this.length > 0) {
      if (t > 0) {
        const i = Math.min(t - 1, this.length - 1);
        this.blocks[i].holder.after(o);
      } else
        t === 0 && this.workingArea.prepend(o);
      this.blocks.splice(t, 0, ...e);
    } else
      this.blocks.push(...e), this.workingArea.appendChild(o);
    e.forEach((i) => i.call(ee.RENDERED));
  }
  remove(e) {
    isNaN(e) && (e = this.length - 1), this.blocks[e].holder.remove(), this.blocks[e].call(ee.REMOVED), this.blocks.splice(e, 1);
  }
  removeAll() {
    this.workingArea.innerHTML = "", this.blocks.forEach((e) => e.call(ee.REMOVED)), this.blocks.length = 0;
  }
  insertAfter(e, t) {
    const o = this.blocks.indexOf(e);
    this.insert(o + 1, t);
  }
  get(e) {
    return this.blocks[e];
  }
  indexOf(e) {
    return this.blocks.indexOf(e);
  }
  insertToDOM(e, t, o) {
    t ? o.holder.insertAdjacentElement(t, e.holder) : this.workingArea.appendChild(e.holder), e.call(ee.RENDERED);
  }
  composeBlockEvent(e, t) {
    return new CustomEvent(e, {
      detail: t
    });
  }
}
var _o = "block-removed";
var Mo = "block-added";
var ia = "block-moved";
var Ao = "block-changed";

class sa {
  constructor() {
    this.completed = Promise.resolve();
  }
  add(e) {
    return new Promise((t, o) => {
      this.completed = this.completed.then(e).then(t).catch(o);
    });
  }
}

class ra extends E {
  constructor() {
    super(...arguments), this._currentBlockIndex = -1, this._blocks = null;
  }
  get currentBlockIndex() {
    return this._currentBlockIndex;
  }
  set currentBlockIndex(e) {
    this._currentBlockIndex = e;
  }
  get firstBlock() {
    return this._blocks[0];
  }
  get lastBlock() {
    return this._blocks[this._blocks.length - 1];
  }
  get currentBlock() {
    return this._blocks[this.currentBlockIndex];
  }
  set currentBlock(e) {
    this.currentBlockIndex = this.getBlockIndex(e);
  }
  get nextBlock() {
    return this.currentBlockIndex === this._blocks.length - 1 ? null : this._blocks[this.currentBlockIndex + 1];
  }
  get nextContentfulBlock() {
    return this.blocks.slice(this.currentBlockIndex + 1).find((t) => !!t.inputs.length);
  }
  get previousContentfulBlock() {
    return this.blocks.slice(0, this.currentBlockIndex).reverse().find((t) => !!t.inputs.length);
  }
  get previousBlock() {
    return this.currentBlockIndex === 0 ? null : this._blocks[this.currentBlockIndex - 1];
  }
  get blocks() {
    return this._blocks.array;
  }
  get isEditorEmpty() {
    return this.blocks.every((e) => e.isEmpty);
  }
  prepare() {
    const e = new ct(this.Editor.UI.nodes.redactor);
    this._blocks = new Proxy(e, {
      set: ct.set,
      get: ct.get
    }), this.listeners.on(document, "copy", (t) => this.Editor.BlockEvents.handleCommandC(t));
  }
  toggleReadOnly(e) {
    e ? this.disableModuleBindings() : this.enableModuleBindings();
  }
  composeBlock({
    tool: e,
    data: t = {},
    id: o = undefined,
    tunes: i = {}
  }) {
    const s = this.Editor.ReadOnly.isEnabled, r = this.Editor.Tools.blockTools.get(e), a = new R({
      id: o,
      data: t,
      tool: r,
      api: this.Editor.API,
      readOnly: s,
      tunesData: i
    }, this.eventsDispatcher);
    return s || window.requestIdleCallback(() => {
      this.bindBlockEvents(a);
    }, { timeout: 2000 }), a;
  }
  insert({
    id: e = undefined,
    tool: t = this.config.defaultBlock,
    data: o = {},
    index: i,
    needToFocus: s = true,
    replace: r = false,
    tunes: a = {}
  } = {}) {
    let l = i;
    l === undefined && (l = this.currentBlockIndex + (r ? 0 : 1));
    const c = this.composeBlock({
      id: e,
      tool: t,
      data: o,
      tunes: a
    });
    return r && this.blockDidMutated(_o, this.getBlockByIndex(l), {
      index: l
    }), this._blocks.insert(l, c, r), this.blockDidMutated(Mo, c, {
      index: l
    }), s ? this.currentBlockIndex = l : l <= this.currentBlockIndex && this.currentBlockIndex++, c;
  }
  insertMany(e, t = 0) {
    this._blocks.insertMany(e, t);
  }
  async update(e, t, o) {
    if (!t && !o)
      return e;
    const i = await e.data, s = this.composeBlock({
      id: e.id,
      tool: e.name,
      data: Object.assign({}, i, t ?? {}),
      tunes: o ?? e.tunes
    }), r = this.getBlockIndex(e);
    return this._blocks.replace(r, s), this.blockDidMutated(Ao, s, {
      index: r
    }), s;
  }
  replace(e, t, o) {
    const i = this.getBlockIndex(e);
    return this.insert({
      tool: t,
      data: o,
      index: i,
      replace: true
    });
  }
  paste(e, t, o = false) {
    const i = this.insert({
      tool: e,
      replace: o
    });
    try {
      window.requestIdleCallback(() => {
        i.call(ee.ON_PASTE, t);
      });
    } catch (s) {
      S(`${e}: onPaste callback call is failed`, "error", s);
    }
    return i;
  }
  insertDefaultBlockAtIndex(e, t = false) {
    const o = this.composeBlock({ tool: this.config.defaultBlock });
    return this._blocks[e] = o, this.blockDidMutated(Mo, o, {
      index: e
    }), t ? this.currentBlockIndex = e : e <= this.currentBlockIndex && this.currentBlockIndex++, o;
  }
  insertAtEnd() {
    return this.currentBlockIndex = this.blocks.length - 1, this.insert();
  }
  async mergeBlocks(e, t) {
    let o;
    if (e.name === t.name && e.mergeable) {
      const i = await t.data;
      if (V(i)) {
        console.error("Could not merge Block. Failed to extract original Block data.");
        return;
      }
      const [s] = yt([i], e.tool.sanitizeConfig);
      o = s;
    } else if (e.mergeable && He(t, "export") && He(e, "import")) {
      const i = await t.exportDataAsString(), s = Z(i, e.tool.sanitizeConfig);
      o = Bo(s, e.tool.conversionConfig);
    }
    o !== undefined && (await e.mergeWith(o), this.removeBlock(t), this.currentBlockIndex = this._blocks.indexOf(e));
  }
  removeBlock(e, t = true) {
    return new Promise((o) => {
      const i = this._blocks.indexOf(e);
      if (!this.validateIndex(i))
        throw new Error("Can't find a Block to remove");
      e.destroy(), this._blocks.remove(i), this.blockDidMutated(_o, e, {
        index: i
      }), this.currentBlockIndex >= i && this.currentBlockIndex--, this.blocks.length ? i === 0 && (this.currentBlockIndex = 0) : (this.unsetCurrentBlock(), t && this.insert()), o();
    });
  }
  removeSelectedBlocks() {
    let e;
    for (let t = this.blocks.length - 1;t >= 0; t--)
      this.blocks[t].selected && (this.removeBlock(this.blocks[t]), e = t);
    return e;
  }
  removeAllBlocks() {
    for (let e = this.blocks.length - 1;e >= 0; e--)
      this._blocks.remove(e);
    this.unsetCurrentBlock(), this.insert(), this.currentBlock.firstInput.focus();
  }
  split() {
    const e = this.Editor.Caret.extractFragmentFromCaretPosition(), t = d.make("div");
    t.appendChild(e);
    const o = {
      text: d.isEmpty(t) ? "" : t.innerHTML
    };
    return this.insert({ data: o });
  }
  getBlockByIndex(e) {
    return e === -1 && (e = this._blocks.length - 1), this._blocks[e];
  }
  getBlockIndex(e) {
    return this._blocks.indexOf(e);
  }
  getBlockById(e) {
    return this._blocks.array.find((t) => t.id === e);
  }
  getBlock(e) {
    d.isElement(e) || (e = e.parentNode);
    const t = this._blocks.nodes, o = e.closest(`.${R.CSS.wrapper}`), i = t.indexOf(o);
    if (i >= 0)
      return this._blocks[i];
  }
  setCurrentBlockByChildNode(e) {
    d.isElement(e) || (e = e.parentNode);
    const t = e.closest(`.${R.CSS.wrapper}`);
    if (!t)
      return;
    const o = t.closest(`.${this.Editor.UI.CSS.editorWrapper}`);
    if (o != null && o.isEqualNode(this.Editor.UI.nodes.wrapper))
      return this.currentBlockIndex = this._blocks.nodes.indexOf(t), this.currentBlock.updateCurrentInput(), this.currentBlock;
  }
  getBlockByChildNode(e) {
    if (!e || !(e instanceof Node))
      return;
    d.isElement(e) || (e = e.parentNode);
    const t = e.closest(`.${R.CSS.wrapper}`);
    return this.blocks.find((o) => o.holder === t);
  }
  swap(e, t) {
    this._blocks.swap(e, t), this.currentBlockIndex = t;
  }
  move(e, t = this.currentBlockIndex) {
    if (isNaN(e) || isNaN(t)) {
      S("Warning during 'move' call: incorrect indices provided.", "warn");
      return;
    }
    if (!this.validateIndex(e) || !this.validateIndex(t)) {
      S("Warning during 'move' call: indices cannot be lower than 0 or greater than the amount of blocks.", "warn");
      return;
    }
    this._blocks.move(e, t), this.currentBlockIndex = e, this.blockDidMutated(ia, this.currentBlock, {
      fromIndex: t,
      toIndex: e
    });
  }
  async convert(e, t, o) {
    if (!await e.save())
      throw new Error("Could not convert Block. Failed to extract original Block data.");
    const s = this.Editor.Tools.blockTools.get(t);
    if (!s)
      throw new Error(`Could not convert Block. Tool «${t}» not found.`);
    const r = await e.exportDataAsString(), a = Z(r, s.sanitizeConfig);
    let l = Bo(a, s.conversionConfig, s.settings);
    return o && (l = Object.assign(l, o)), this.replace(e, s.name, l);
  }
  unsetCurrentBlock() {
    this.currentBlockIndex = -1;
  }
  async clear(e = false) {
    const t = new sa;
    this.blocks.forEach((o) => {
      t.add(async () => {
        await this.removeBlock(o, false);
      });
    }), await t.completed, this.unsetCurrentBlock(), e && this.insert(), this.Editor.UI.checkEmptiness();
  }
  async destroy() {
    await Promise.all(this.blocks.map((e) => e.destroy()));
  }
  bindBlockEvents(e) {
    const { BlockEvents: t } = this.Editor;
    this.readOnlyMutableListeners.on(e.holder, "keydown", (o) => {
      t.keydown(o);
    }), this.readOnlyMutableListeners.on(e.holder, "keyup", (o) => {
      t.keyup(o);
    }), this.readOnlyMutableListeners.on(e.holder, "dragover", (o) => {
      t.dragOver(o);
    }), this.readOnlyMutableListeners.on(e.holder, "dragleave", (o) => {
      t.dragLeave(o);
    }), e.on("didMutated", (o) => this.blockDidMutated(Ao, o, {
      index: this.getBlockIndex(o)
    }));
  }
  disableModuleBindings() {
    this.readOnlyMutableListeners.clearAll();
  }
  enableModuleBindings() {
    this.readOnlyMutableListeners.on(document, "cut", (e) => this.Editor.BlockEvents.handleCommandX(e)), this.blocks.forEach((e) => {
      this.bindBlockEvents(e);
    });
  }
  validateIndex(e) {
    return !(e < 0 || e >= this._blocks.length);
  }
  blockDidMutated(e, t, o) {
    const i = new CustomEvent(e, {
      detail: {
        target: new J(t),
        ...o
      }
    });
    return this.eventsDispatcher.emit($o, {
      event: i
    }), t;
  }
}

class aa extends E {
  constructor() {
    super(...arguments), this.anyBlockSelectedCache = null, this.needToSelectAll = false, this.nativeInputSelected = false, this.readyToBlockSelection = false;
  }
  get sanitizerConfig() {
    return {
      p: {},
      h1: {},
      h2: {},
      h3: {},
      h4: {},
      h5: {},
      h6: {},
      ol: {},
      ul: {},
      li: {},
      br: true,
      img: {
        src: true,
        width: true,
        height: true
      },
      a: {
        href: true
      },
      b: {},
      i: {},
      u: {}
    };
  }
  get allBlocksSelected() {
    const { BlockManager: e } = this.Editor;
    return e.blocks.every((t) => t.selected === true);
  }
  set allBlocksSelected(e) {
    const { BlockManager: t } = this.Editor;
    t.blocks.forEach((o) => {
      o.selected = e;
    }), this.clearCache();
  }
  get anyBlockSelected() {
    const { BlockManager: e } = this.Editor;
    return this.anyBlockSelectedCache === null && (this.anyBlockSelectedCache = e.blocks.some((t) => t.selected === true)), this.anyBlockSelectedCache;
  }
  get selectedBlocks() {
    return this.Editor.BlockManager.blocks.filter((e) => e.selected);
  }
  prepare() {
    this.selection = new b, ge.add({
      name: "CMD+A",
      handler: (e) => {
        const { BlockManager: t, ReadOnly: o } = this.Editor;
        if (o.isEnabled) {
          e.preventDefault(), this.selectAllBlocks();
          return;
        }
        t.currentBlock && this.handleCommandA(e);
      },
      on: this.Editor.UI.nodes.redactor
    });
  }
  toggleReadOnly() {
    b.get().removeAllRanges(), this.allBlocksSelected = false;
  }
  unSelectBlockByIndex(e) {
    const { BlockManager: t } = this.Editor;
    let o;
    isNaN(e) ? o = t.currentBlock : o = t.getBlockByIndex(e), o.selected = false, this.clearCache();
  }
  clearSelection(e, t = false) {
    const { BlockManager: o, Caret: i, RectangleSelection: s } = this.Editor;
    this.needToSelectAll = false, this.nativeInputSelected = false, this.readyToBlockSelection = false;
    const r = e && e instanceof KeyboardEvent, a = r && Po(e.keyCode);
    if (this.anyBlockSelected && r && a && !b.isSelectionExists) {
      const l = o.removeSelectedBlocks();
      o.insertDefaultBlockAtIndex(l, true), i.setToBlock(o.currentBlock), Fe(() => {
        const c = e.key;
        i.insertContentAtCaretPosition(c.length > 1 ? "" : c);
      }, 20)();
    }
    if (this.Editor.CrossBlockSelection.clear(e), !this.anyBlockSelected || s.isRectActivated()) {
      this.Editor.RectangleSelection.clearSelection();
      return;
    }
    t && this.selection.restore(), this.allBlocksSelected = false;
  }
  copySelectedBlocks(e) {
    e.preventDefault();
    const t = d.make("div");
    this.selectedBlocks.forEach((s) => {
      const r = Z(s.holder.innerHTML, this.sanitizerConfig), a = d.make("p");
      a.innerHTML = r, t.appendChild(a);
    });
    const o = Array.from(t.childNodes).map((s) => s.textContent).join(`

`), i = t.innerHTML;
    return e.clipboardData.setData("text/plain", o), e.clipboardData.setData("text/html", i), Promise.all(this.selectedBlocks.map((s) => s.save())).then((s) => {
      try {
        e.clipboardData.setData(this.Editor.Paste.MIME_TYPE, JSON.stringify(s));
      } catch {
      }
    });
  }
  selectBlockByIndex(e) {
    const { BlockManager: t } = this.Editor, o = t.getBlockByIndex(e);
    o !== undefined && this.selectBlock(o);
  }
  selectBlock(e) {
    this.selection.save(), b.get().removeAllRanges(), e.selected = true, this.clearCache(), this.Editor.InlineToolbar.close();
  }
  unselectBlock(e) {
    e.selected = false, this.clearCache();
  }
  clearCache() {
    this.anyBlockSelectedCache = null;
  }
  destroy() {
    ge.remove(this.Editor.UI.nodes.redactor, "CMD+A");
  }
  handleCommandA(e) {
    if (this.Editor.RectangleSelection.clearSelection(), d.isNativeInput(e.target) && !this.readyToBlockSelection) {
      this.readyToBlockSelection = true;
      return;
    }
    const t = this.Editor.BlockManager.getBlock(e.target), o = t.inputs;
    if (o.length > 1 && !this.readyToBlockSelection) {
      this.readyToBlockSelection = true;
      return;
    }
    if (o.length === 1 && !this.needToSelectAll) {
      this.needToSelectAll = true;
      return;
    }
    this.needToSelectAll ? (e.preventDefault(), this.selectAllBlocks(), this.needToSelectAll = false, this.readyToBlockSelection = false) : this.readyToBlockSelection && (e.preventDefault(), this.selectBlock(t), this.needToSelectAll = true);
  }
  selectAllBlocks() {
    this.selection.save(), b.get().removeAllRanges(), this.allBlocksSelected = true, this.Editor.InlineToolbar.close();
  }
}

class Ye extends E {
  get positions() {
    return {
      START: "start",
      END: "end",
      DEFAULT: "default"
    };
  }
  static get CSS() {
    return {
      shadowCaret: "cdx-shadow-caret"
    };
  }
  setToBlock(e, t = this.positions.DEFAULT, o = 0) {
    var c;
    const { BlockManager: i, BlockSelection: s } = this.Editor;
    if (s.clearSelection(), !e.focusable) {
      (c = window.getSelection()) == null || c.removeAllRanges(), s.selectBlock(e), i.currentBlock = e;
      return;
    }
    let r;
    switch (t) {
      case this.positions.START:
        r = e.firstInput;
        break;
      case this.positions.END:
        r = e.lastInput;
        break;
      default:
        r = e.currentInput;
    }
    if (!r)
      return;
    const a = d.getDeepestNode(r, t === this.positions.END), l = d.getContentLength(a);
    switch (true) {
      case t === this.positions.START:
        o = 0;
        break;
      case t === this.positions.END:
      case o > l:
        o = l;
        break;
    }
    this.set(a, o), i.setCurrentBlockByChildNode(e.holder), i.currentBlock.currentInput = r;
  }
  setToInput(e, t = this.positions.DEFAULT, o = 0) {
    const { currentBlock: i } = this.Editor.BlockManager, s = d.getDeepestNode(e);
    switch (t) {
      case this.positions.START:
        this.set(s, 0);
        break;
      case this.positions.END:
        this.set(s, d.getContentLength(s));
        break;
      default:
        o && this.set(s, o);
    }
    i.currentInput = e;
  }
  set(e, t = 0) {
    const { top: i, bottom: s } = b.setCursor(e, t), { innerHeight: r } = window;
    i < 0 ? window.scrollBy(0, i - 30) : s > r && window.scrollBy(0, s - r + 30);
  }
  setToTheLastBlock() {
    const e = this.Editor.BlockManager.lastBlock;
    if (e)
      if (e.tool.isDefault && e.isEmpty)
        this.setToBlock(e);
      else {
        const t = this.Editor.BlockManager.insertAtEnd();
        this.setToBlock(t);
      }
  }
  extractFragmentFromCaretPosition() {
    const e = b.get();
    if (e.rangeCount) {
      const t = e.getRangeAt(0), o = this.Editor.BlockManager.currentBlock.currentInput;
      if (t.deleteContents(), o)
        if (d.isNativeInput(o)) {
          const i = o, s = document.createDocumentFragment(), r = i.value.substring(0, i.selectionStart), a = i.value.substring(i.selectionStart);
          return s.textContent = a, i.value = r, s;
        } else {
          const i = t.cloneRange();
          return i.selectNodeContents(o), i.setStart(t.endContainer, t.endOffset), i.extractContents();
        }
    }
  }
  navigateNext(e = false) {
    const { BlockManager: t } = this.Editor, { currentBlock: o, nextBlock: i } = t;
    if (o === undefined)
      return false;
    const { nextInput: s, currentInput: r } = o, a = r !== undefined ? Re(r) : undefined;
    let l = i;
    const c = e || a || !o.focusable;
    if (s && c)
      return this.setToInput(s, this.positions.START), true;
    if (l === null) {
      if (o.tool.isDefault || !c)
        return false;
      l = t.insertAtEnd();
    }
    return c ? (this.setToBlock(l, this.positions.START), true) : false;
  }
  navigatePrevious(e = false) {
    const { currentBlock: t, previousBlock: o } = this.Editor.BlockManager;
    if (!t)
      return false;
    const { previousInput: i, currentInput: s } = t, r = s !== undefined ? Ne(s) : undefined, a = e || r || !t.focusable;
    return i && a ? (this.setToInput(i, this.positions.END), true) : o !== null && a ? (this.setToBlock(o, this.positions.END), true) : false;
  }
  createShadow(e) {
    const t = document.createElement("span");
    t.classList.add(Ye.CSS.shadowCaret), e.insertAdjacentElement("beforeend", t);
  }
  restoreCaret(e) {
    const t = e.querySelector(`.${Ye.CSS.shadowCaret}`);
    if (!t)
      return;
    new b().expandToTag(t);
    const i = document.createRange();
    i.selectNode(t), i.extractContents();
  }
  insertContentAtCaretPosition(e) {
    const t = document.createDocumentFragment(), o = document.createElement("div"), i = b.get(), s = b.range;
    o.innerHTML = e, Array.from(o.childNodes).forEach((c) => t.appendChild(c)), t.childNodes.length === 0 && t.appendChild(new Text);
    const r = t.lastChild;
    s.deleteContents(), s.insertNode(t);
    const a = document.createRange(), l = r.nodeType === Node.TEXT_NODE ? r : r.firstChild;
    l !== null && l.textContent !== null && a.setStart(l, l.textContent.length), i.removeAllRanges(), i.addRange(a);
  }
}

class la extends E {
  constructor() {
    super(...arguments), this.onMouseUp = () => {
      this.listeners.off(document, "mouseover", this.onMouseOver), this.listeners.off(document, "mouseup", this.onMouseUp);
    }, this.onMouseOver = (e) => {
      const { BlockManager: t, BlockSelection: o } = this.Editor;
      if (e.relatedTarget === null && e.target === null)
        return;
      const i = t.getBlockByChildNode(e.relatedTarget) || this.lastSelectedBlock, s = t.getBlockByChildNode(e.target);
      if (!(!i || !s) && s !== i) {
        if (i === this.firstSelectedBlock) {
          b.get().removeAllRanges(), i.selected = true, s.selected = true, o.clearCache();
          return;
        }
        if (s === this.firstSelectedBlock) {
          i.selected = false, s.selected = false, o.clearCache();
          return;
        }
        this.Editor.InlineToolbar.close(), this.toggleBlocksSelectedState(i, s), this.lastSelectedBlock = s;
      }
    };
  }
  async prepare() {
    this.listeners.on(document, "mousedown", (e) => {
      this.enableCrossBlockSelection(e);
    });
  }
  watchSelection(e) {
    if (e.button !== qn.LEFT)
      return;
    const { BlockManager: t } = this.Editor;
    this.firstSelectedBlock = t.getBlock(e.target), this.lastSelectedBlock = this.firstSelectedBlock, this.listeners.on(document, "mouseover", this.onMouseOver), this.listeners.on(document, "mouseup", this.onMouseUp);
  }
  get isCrossBlockSelectionStarted() {
    return !!this.firstSelectedBlock && !!this.lastSelectedBlock && this.firstSelectedBlock !== this.lastSelectedBlock;
  }
  toggleBlockSelectedState(e = true) {
    const { BlockManager: t, BlockSelection: o } = this.Editor;
    this.lastSelectedBlock || (this.lastSelectedBlock = this.firstSelectedBlock = t.currentBlock), this.firstSelectedBlock === this.lastSelectedBlock && (this.firstSelectedBlock.selected = true, o.clearCache(), b.get().removeAllRanges());
    const i = t.blocks.indexOf(this.lastSelectedBlock) + (e ? 1 : -1), s = t.blocks[i];
    s && (this.lastSelectedBlock.selected !== s.selected ? (s.selected = true, o.clearCache()) : (this.lastSelectedBlock.selected = false, o.clearCache()), this.lastSelectedBlock = s, this.Editor.InlineToolbar.close(), s.holder.scrollIntoView({
      block: "nearest"
    }));
  }
  clear(e) {
    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor, s = t.blocks.indexOf(this.firstSelectedBlock), r = t.blocks.indexOf(this.lastSelectedBlock);
    if (o.anyBlockSelected && s > -1 && r > -1 && e && e instanceof KeyboardEvent)
      switch (e.keyCode) {
        case y.DOWN:
        case y.RIGHT:
          i.setToBlock(t.blocks[Math.max(s, r)], i.positions.END);
          break;
        case y.UP:
        case y.LEFT:
          i.setToBlock(t.blocks[Math.min(s, r)], i.positions.START);
          break;
        default:
          i.setToBlock(t.blocks[Math.max(s, r)], i.positions.END);
      }
    this.firstSelectedBlock = this.lastSelectedBlock = null;
  }
  enableCrossBlockSelection(e) {
    const { UI: t } = this.Editor;
    b.isCollapsed || this.Editor.BlockSelection.clearSelection(e), t.nodes.redactor.contains(e.target) ? this.watchSelection(e) : this.Editor.BlockSelection.clearSelection(e);
  }
  toggleBlocksSelectedState(e, t) {
    const { BlockManager: o, BlockSelection: i } = this.Editor, s = o.blocks.indexOf(e), r = o.blocks.indexOf(t), a = e.selected !== t.selected;
    for (let l = Math.min(s, r);l <= Math.max(s, r); l++) {
      const c = o.blocks[l];
      c !== this.firstSelectedBlock && c !== (a ? e : t) && (o.blocks[l].selected = !o.blocks[l].selected, i.clearCache());
    }
  }
}

class ca extends E {
  constructor() {
    super(...arguments), this.isStartedAtEditor = false;
  }
  toggleReadOnly(e) {
    e ? this.disableModuleBindings() : this.enableModuleBindings();
  }
  enableModuleBindings() {
    const { UI: e } = this.Editor;
    this.readOnlyMutableListeners.on(e.nodes.holder, "drop", async (t) => {
      await this.processDrop(t);
    }, true), this.readOnlyMutableListeners.on(e.nodes.holder, "dragstart", () => {
      this.processDragStart();
    }), this.readOnlyMutableListeners.on(e.nodes.holder, "dragover", (t) => {
      this.processDragOver(t);
    }, true);
  }
  disableModuleBindings() {
    this.readOnlyMutableListeners.clearAll();
  }
  async processDrop(e) {
    const {
      BlockManager: t,
      Paste: o,
      Caret: i
    } = this.Editor;
    e.preventDefault(), t.blocks.forEach((r) => {
      r.dropTarget = false;
    }), b.isAtEditor && !b.isCollapsed && this.isStartedAtEditor && document.execCommand("delete"), this.isStartedAtEditor = false;
    const s = t.setCurrentBlockByChildNode(e.target);
    if (s)
      this.Editor.Caret.setToBlock(s, i.positions.END);
    else {
      const r = t.setCurrentBlockByChildNode(t.lastBlock.holder);
      this.Editor.Caret.setToBlock(r, i.positions.END);
    }
    await o.processDataTransfer(e.dataTransfer, true);
  }
  processDragStart() {
    b.isAtEditor && !b.isCollapsed && (this.isStartedAtEditor = true), this.Editor.InlineToolbar.close();
  }
  processDragOver(e) {
    e.preventDefault();
  }
}
var da = 180;
var ua = 400;

class ha extends E {
  constructor({ config: e, eventsDispatcher: t }) {
    super({
      config: e,
      eventsDispatcher: t
    }), this.disabled = false, this.batchingTimeout = null, this.batchingOnChangeQueue = /* @__PURE__ */ new Map, this.batchTime = ua, this.mutationObserver = new MutationObserver((o) => {
      this.redactorChanged(o);
    }), this.eventsDispatcher.on($o, (o) => {
      this.particularBlockChanged(o.event);
    }), this.eventsDispatcher.on(zo, () => {
      this.disable();
    }), this.eventsDispatcher.on(Uo, () => {
      this.enable();
    });
  }
  enable() {
    this.mutationObserver.observe(this.Editor.UI.nodes.redactor, {
      childList: true,
      subtree: true,
      characterData: true,
      attributes: true
    }), this.disabled = false;
  }
  disable() {
    this.mutationObserver.disconnect(), this.disabled = true;
  }
  particularBlockChanged(e) {
    this.disabled || !A(this.config.onChange) || (this.batchingOnChangeQueue.set(`block:${e.detail.target.id}:event:${e.type}`, e), this.batchingTimeout && clearTimeout(this.batchingTimeout), this.batchingTimeout = setTimeout(() => {
      let t;
      this.batchingOnChangeQueue.size === 1 ? t = this.batchingOnChangeQueue.values().next().value : t = Array.from(this.batchingOnChangeQueue.values()), this.config.onChange && this.config.onChange(this.Editor.API.methods, t), this.batchingOnChangeQueue.clear();
    }, this.batchTime));
  }
  redactorChanged(e) {
    this.eventsDispatcher.emit(ft, {
      mutations: e
    });
  }
}
var Rn = class Dn extends E {
  constructor() {
    super(...arguments), this.MIME_TYPE = "application/x-editor-js", this.toolsTags = {}, this.tagsByTool = {}, this.toolsPatterns = [], this.toolsFiles = {}, this.exceptionList = [], this.processTool = (e) => {
      try {
        const t = e.create({}, {}, false);
        if (e.pasteConfig === false) {
          this.exceptionList.push(e.name);
          return;
        }
        if (!A(t.onPaste))
          return;
        this.getTagsConfig(e), this.getFilesConfig(e), this.getPatternsConfig(e);
      } catch (t) {
        S(`Paste handling for «${e.name}» Tool hasn't been set up because of the error`, "warn", t);
      }
    }, this.handlePasteEvent = async (e) => {
      const { BlockManager: t, Toolbar: o } = this.Editor, i = t.setCurrentBlockByChildNode(e.target);
      !i || this.isNativeBehaviour(e.target) && !e.clipboardData.types.includes("Files") || i && this.exceptionList.includes(i.name) || (e.preventDefault(), this.processDataTransfer(e.clipboardData), o.close());
    };
  }
  async prepare() {
    this.processTools();
  }
  toggleReadOnly(e) {
    e ? this.unsetCallback() : this.setCallback();
  }
  async processDataTransfer(e, t = false) {
    const { Tools: o } = this.Editor, i = e.types;
    if ((i.includes ? i.includes("Files") : i.contains("Files")) && !V(this.toolsFiles)) {
      await this.processFiles(e.files);
      return;
    }
    const r = e.getData(this.MIME_TYPE), a = e.getData("text/plain");
    let l = e.getData("text/html");
    if (r)
      try {
        this.insertEditorJSData(JSON.parse(r));
        return;
      } catch {
      }
    t && a.trim() && l.trim() && (l = "<p>" + (l.trim() ? l : a) + "</p>");
    const c = Object.keys(this.toolsTags).reduce((p, g) => (p[g.toLowerCase()] = this.toolsTags[g].sanitizationConfig ?? {}, p), {}), u = Object.assign({}, c, o.getAllInlineToolsSanitizeConfig(), { br: {} }), h = Z(l, u);
    !h.trim() || h.trim() === a || !d.isHTMLString(h) ? await this.processText(a) : await this.processText(h, true);
  }
  async processText(e, t = false) {
    const { Caret: o, BlockManager: i } = this.Editor, s = t ? this.processHTML(e) : this.processPlain(e);
    if (!s.length)
      return;
    if (s.length === 1) {
      s[0].isBlock ? this.processSingleBlock(s.pop()) : this.processInlinePaste(s.pop());
      return;
    }
    const a = i.currentBlock && i.currentBlock.tool.isDefault && i.currentBlock.isEmpty;
    s.map(async (l, c) => this.insertBlock(l, c === 0 && a)), i.currentBlock && o.setToBlock(i.currentBlock, o.positions.END);
  }
  setCallback() {
    this.listeners.on(this.Editor.UI.nodes.holder, "paste", this.handlePasteEvent);
  }
  unsetCallback() {
    this.listeners.off(this.Editor.UI.nodes.holder, "paste", this.handlePasteEvent);
  }
  processTools() {
    const e = this.Editor.Tools.blockTools;
    Array.from(e.values()).forEach(this.processTool);
  }
  collectTagNames(e) {
    return te(e) ? [e] : D(e) ? Object.keys(e) : [];
  }
  getTagsConfig(e) {
    if (e.pasteConfig === false)
      return;
    const t = e.pasteConfig.tags || [], o = [];
    t.forEach((i) => {
      const s = this.collectTagNames(i);
      o.push(...s), s.forEach((r) => {
        if (Object.prototype.hasOwnProperty.call(this.toolsTags, r)) {
          S(`Paste handler for «${e.name}» Tool on «${r}» tag is skipped because it is already used by «${this.toolsTags[r].tool.name}» Tool.`, "warn");
          return;
        }
        const a = D(i) ? i[r] : null;
        this.toolsTags[r.toUpperCase()] = {
          tool: e,
          sanitizationConfig: a
        };
      });
    }), this.tagsByTool[e.name] = o.map((i) => i.toUpperCase());
  }
  getFilesConfig(e) {
    if (e.pasteConfig === false)
      return;
    const { files: t = {} } = e.pasteConfig;
    let { extensions: o, mimeTypes: i } = t;
    !o && !i || (o && !Array.isArray(o) && (S(`«extensions» property of the onDrop config for «${e.name}» Tool should be an array`), o = []), i && !Array.isArray(i) && (S(`«mimeTypes» property of the onDrop config for «${e.name}» Tool should be an array`), i = []), i && (i = i.filter((s) => ei(s) ? true : (S(`MIME type value «${s}» for the «${e.name}» Tool is not a valid MIME type`, "warn"), false))), this.toolsFiles[e.name] = {
      extensions: o || [],
      mimeTypes: i || []
    });
  }
  getPatternsConfig(e) {
    e.pasteConfig === false || !e.pasteConfig.patterns || V(e.pasteConfig.patterns) || Object.entries(e.pasteConfig.patterns).forEach(([t, o]) => {
      o instanceof RegExp || S(`Pattern ${o} for «${e.name}» Tool is skipped because it should be a Regexp instance.`, "warn"), this.toolsPatterns.push({
        key: t,
        pattern: o,
        tool: e
      });
    });
  }
  isNativeBehaviour(e) {
    return d.isNativeInput(e);
  }
  async processFiles(e) {
    const { BlockManager: t } = this.Editor;
    let o;
    o = await Promise.all(Array.from(e).map((r) => this.processFile(r))), o = o.filter((r) => !!r);
    const s = t.currentBlock.tool.isDefault && t.currentBlock.isEmpty;
    o.forEach((r, a) => {
      t.paste(r.type, r.event, a === 0 && s);
    });
  }
  async processFile(e) {
    const t = Jn(e), o = Object.entries(this.toolsFiles).find(([r, { mimeTypes: a, extensions: l }]) => {
      const [c, u] = e.type.split("/"), h = l.find((g) => g.toLowerCase() === t.toLowerCase()), p = a.find((g) => {
        const [f, v] = g.split("/");
        return f === c && (v === u || v === "*");
      });
      return !!h || !!p;
    });
    if (!o)
      return;
    const [i] = o;
    return {
      event: this.composePasteEvent("file", {
        file: e
      }),
      type: i
    };
  }
  processHTML(e) {
    const { Tools: t } = this.Editor, o = d.make("DIV");
    return o.innerHTML = e, this.getNodes(o).map((s) => {
      let r, a = t.defaultTool, l = false;
      switch (s.nodeType) {
        case Node.DOCUMENT_FRAGMENT_NODE:
          r = d.make("div"), r.appendChild(s);
          break;
        case Node.ELEMENT_NODE:
          r = s, l = true, this.toolsTags[r.tagName] && (a = this.toolsTags[r.tagName].tool);
          break;
      }
      const { tags: c } = a.pasteConfig || { tags: [] }, u = c.reduce((g, f) => (this.collectTagNames(f).forEach((O) => {
        const T = D(f) ? f[O] : null;
        g[O.toLowerCase()] = T || {};
      }), g), {}), h = Object.assign({}, u, a.baseSanitizeConfig);
      if (r.tagName.toLowerCase() === "table") {
        const g = Z(r.outerHTML, h);
        r = d.make("div", undefined, {
          innerHTML: g
        }).firstChild;
      } else
        r.innerHTML = Z(r.innerHTML, h);
      const p = this.composePasteEvent("tag", {
        data: r
      });
      return {
        content: r,
        isBlock: l,
        tool: a.name,
        event: p
      };
    }).filter((s) => {
      const r = d.isEmpty(s.content), a = d.isSingleTag(s.content);
      return !r || a;
    });
  }
  processPlain(e) {
    const { defaultBlock: t } = this.config;
    if (!e)
      return [];
    const o = t;
    return e.split(/\r?\n/).filter((i) => i.trim()).map((i) => {
      const s = d.make("div");
      s.textContent = i;
      const r = this.composePasteEvent("tag", {
        data: s
      });
      return {
        content: s,
        tool: o,
        isBlock: false,
        event: r
      };
    });
  }
  async processSingleBlock(e) {
    const { Caret: t, BlockManager: o } = this.Editor, { currentBlock: i } = o;
    if (!i || e.tool !== i.name || !d.containsOnlyInlineElements(e.content.innerHTML)) {
      this.insertBlock(e, (i == null ? undefined : i.tool.isDefault) && i.isEmpty);
      return;
    }
    t.insertContentAtCaretPosition(e.content.innerHTML);
  }
  async processInlinePaste(e) {
    const { BlockManager: t, Caret: o } = this.Editor, { content: i } = e;
    if (t.currentBlock && t.currentBlock.tool.isDefault && i.textContent.length < Dn.PATTERN_PROCESSING_MAX_LENGTH) {
      const r = await this.processPattern(i.textContent);
      if (r) {
        const a = t.currentBlock && t.currentBlock.tool.isDefault && t.currentBlock.isEmpty, l = t.paste(r.tool, r.event, a);
        o.setToBlock(l, o.positions.END);
        return;
      }
    }
    if (t.currentBlock && t.currentBlock.currentInput) {
      const r = t.currentBlock.tool.baseSanitizeConfig;
      document.execCommand("insertHTML", false, Z(i.innerHTML, r));
    } else
      this.insertBlock(e);
  }
  async processPattern(e) {
    const t = this.toolsPatterns.find((i) => {
      const s = i.pattern.exec(e);
      return s ? e === s.shift() : false;
    });
    return t ? {
      event: this.composePasteEvent("pattern", {
        key: t.key,
        data: e
      }),
      tool: t.tool.name
    } : undefined;
  }
  insertBlock(e, t = false) {
    const { BlockManager: o, Caret: i } = this.Editor, { currentBlock: s } = o;
    let r;
    if (t && s && s.isEmpty) {
      r = o.paste(e.tool, e.event, true), i.setToBlock(r, i.positions.END);
      return;
    }
    r = o.paste(e.tool, e.event), i.setToBlock(r, i.positions.END);
  }
  insertEditorJSData(e) {
    const { BlockManager: t, Caret: o, Tools: i } = this.Editor;
    yt(e, (r) => i.blockTools.get(r).sanitizeConfig).forEach(({ tool: r, data: a }, l) => {
      let c = false;
      l === 0 && (c = t.currentBlock && t.currentBlock.tool.isDefault && t.currentBlock.isEmpty);
      const u = t.insert({
        tool: r,
        data: a,
        replace: c
      });
      o.setToBlock(u, o.positions.END);
    });
  }
  processElementNode(e, t, o) {
    const i = Object.keys(this.toolsTags), s = e, { tool: r } = this.toolsTags[s.tagName] || {}, a = this.tagsByTool[r == null ? undefined : r.name] || [], l = i.includes(s.tagName), c = d.blockElements.includes(s.tagName.toLowerCase()), u = Array.from(s.children).some(({ tagName: p }) => i.includes(p) && !a.includes(p)), h = Array.from(s.children).some(({ tagName: p }) => d.blockElements.includes(p.toLowerCase()));
    if (!c && !l && !u)
      return o.appendChild(s), [...t, o];
    if (l && !u || c && !h && !u)
      return [...t, o, s];
  }
  getNodes(e) {
    const t = Array.from(e.childNodes);
    let o;
    const i = (s, r) => {
      if (d.isEmpty(r) && !d.isSingleTag(r))
        return s;
      const a = s[s.length - 1];
      let l = new DocumentFragment;
      switch (a && d.isFragment(a) && (l = s.pop()), r.nodeType) {
        case Node.ELEMENT_NODE:
          if (o = this.processElementNode(r, s, l), o)
            return o;
          break;
        case Node.TEXT_NODE:
          return l.appendChild(r), [...s, l];
        default:
          return [...s, l];
      }
      return [...s, ...Array.from(r.childNodes).reduce(i, [])];
    };
    return t.reduce(i, []);
  }
  composePasteEvent(e, t) {
    return new CustomEvent(e, {
      detail: t
    });
  }
};
Rn.PATTERN_PROCESSING_MAX_LENGTH = 450;
var pa = Rn;

class fa extends E {
  constructor() {
    super(...arguments), this.toolsDontSupportReadOnly = [], this.readOnlyEnabled = false;
  }
  get isEnabled() {
    return this.readOnlyEnabled;
  }
  async prepare() {
    const { Tools: e } = this.Editor, { blockTools: t } = e, o = [];
    Array.from(t.entries()).forEach(([i, s]) => {
      s.isReadOnlySupported || o.push(i);
    }), this.toolsDontSupportReadOnly = o, this.config.readOnly && o.length > 0 && this.throwCriticalError(), this.toggle(this.config.readOnly, true);
  }
  async toggle(e = !this.readOnlyEnabled, t = false) {
    e && this.toolsDontSupportReadOnly.length > 0 && this.throwCriticalError();
    const o = this.readOnlyEnabled;
    this.readOnlyEnabled = e;
    for (const s in this.Editor)
      this.Editor[s].toggleReadOnly && this.Editor[s].toggleReadOnly(e);
    if (o === e)
      return this.readOnlyEnabled;
    if (t)
      return this.readOnlyEnabled;
    this.Editor.ModificationsObserver.disable();
    const i = await this.Editor.Saver.save();
    return await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(i.blocks), this.Editor.ModificationsObserver.enable(), this.readOnlyEnabled;
  }
  throwCriticalError() {
    throw new Ho(`To enable read-only mode all connected tools should support it. Tools ${this.toolsDontSupportReadOnly.join(", ")} don't support read-only mode.`);
  }
}

class Be extends E {
  constructor() {
    super(...arguments), this.isRectSelectionActivated = false, this.SCROLL_SPEED = 3, this.HEIGHT_OF_SCROLL_ZONE = 40, this.BOTTOM_SCROLL_ZONE = 1, this.TOP_SCROLL_ZONE = 2, this.MAIN_MOUSE_BUTTON = 0, this.mousedown = false, this.isScrolling = false, this.inScrollZone = null, this.startX = 0, this.startY = 0, this.mouseX = 0, this.mouseY = 0, this.stackOfSelected = [], this.listenerIds = [];
  }
  static get CSS() {
    return {
      overlay: "codex-editor-overlay",
      overlayContainer: "codex-editor-overlay__container",
      rect: "codex-editor-overlay__rectangle",
      topScrollZone: "codex-editor-overlay__scroll-zone--top",
      bottomScrollZone: "codex-editor-overlay__scroll-zone--bottom"
    };
  }
  prepare() {
    this.enableModuleBindings();
  }
  startSelection(e, t) {
    const o = document.elementFromPoint(e - window.pageXOffset, t - window.pageYOffset);
    o.closest(`.${this.Editor.Toolbar.CSS.toolbar}`) || (this.Editor.BlockSelection.allBlocksSelected = false, this.clearSelection(), this.stackOfSelected = []);
    const s = [
      `.${R.CSS.content}`,
      `.${this.Editor.Toolbar.CSS.toolbar}`,
      `.${this.Editor.InlineToolbar.CSS.inlineToolbar}`
    ], r = o.closest("." + this.Editor.UI.CSS.editorWrapper), a = s.some((l) => !!o.closest(l));
    !r || a || (this.mousedown = true, this.startX = e, this.startY = t);
  }
  endSelection() {
    this.mousedown = false, this.startX = 0, this.startY = 0, this.overlayRectangle.style.display = "none";
  }
  isRectActivated() {
    return this.isRectSelectionActivated;
  }
  clearSelection() {
    this.isRectSelectionActivated = false;
  }
  enableModuleBindings() {
    const { container: e } = this.genHTML();
    this.listeners.on(e, "mousedown", (t) => {
      this.processMouseDown(t);
    }, false), this.listeners.on(document.body, "mousemove", dt((t) => {
      this.processMouseMove(t);
    }, 10), {
      passive: true
    }), this.listeners.on(document.body, "mouseleave", () => {
      this.processMouseLeave();
    }), this.listeners.on(window, "scroll", dt((t) => {
      this.processScroll(t);
    }, 10), {
      passive: true
    }), this.listeners.on(document.body, "mouseup", () => {
      this.processMouseUp();
    }, false);
  }
  processMouseDown(e) {
    if (e.button !== this.MAIN_MOUSE_BUTTON)
      return;
    e.target.closest(d.allInputsSelector) !== null || this.startSelection(e.pageX, e.pageY);
  }
  processMouseMove(e) {
    this.changingRectangle(e), this.scrollByZones(e.clientY);
  }
  processMouseLeave() {
    this.clearSelection(), this.endSelection();
  }
  processScroll(e) {
    this.changingRectangle(e);
  }
  processMouseUp() {
    this.clearSelection(), this.endSelection();
  }
  scrollByZones(e) {
    if (this.inScrollZone = null, e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.TOP_SCROLL_ZONE), document.documentElement.clientHeight - e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.BOTTOM_SCROLL_ZONE), !this.inScrollZone) {
      this.isScrolling = false;
      return;
    }
    this.isScrolling || (this.scrollVertical(this.inScrollZone === this.TOP_SCROLL_ZONE ? -this.SCROLL_SPEED : this.SCROLL_SPEED), this.isScrolling = true);
  }
  genHTML() {
    const { UI: e } = this.Editor, t = e.nodes.holder.querySelector("." + e.CSS.editorWrapper), o = d.make("div", Be.CSS.overlay, {}), i = d.make("div", Be.CSS.overlayContainer, {}), s = d.make("div", Be.CSS.rect, {});
    return i.appendChild(s), o.appendChild(i), t.appendChild(o), this.overlayRectangle = s, {
      container: t,
      overlay: o
    };
  }
  scrollVertical(e) {
    if (!(this.inScrollZone && this.mousedown))
      return;
    const t = window.pageYOffset;
    window.scrollBy(0, e), this.mouseY += window.pageYOffset - t, setTimeout(() => {
      this.scrollVertical(e);
    }, 0);
  }
  changingRectangle(e) {
    if (!this.mousedown)
      return;
    e.pageY !== undefined && (this.mouseX = e.pageX, this.mouseY = e.pageY);
    const { rightPos: t, leftPos: o, index: i } = this.genInfoForMouseSelection(), s = this.startX > t && this.mouseX > t, r = this.startX < o && this.mouseX < o;
    this.rectCrossesBlocks = !(s || r), this.isRectSelectionActivated || (this.rectCrossesBlocks = false, this.isRectSelectionActivated = true, this.shrinkRectangleToPoint(), this.overlayRectangle.style.display = "block"), this.updateRectangleSize(), this.Editor.Toolbar.close(), i !== undefined && (this.trySelectNextBlock(i), this.inverseSelection(), b.get().removeAllRanges());
  }
  shrinkRectangleToPoint() {
    this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`;
  }
  inverseSelection() {
    const t = this.Editor.BlockManager.getBlockByIndex(this.stackOfSelected[0]).selected;
    if (this.rectCrossesBlocks && !t)
      for (const o of this.stackOfSelected)
        this.Editor.BlockSelection.selectBlockByIndex(o);
    if (!this.rectCrossesBlocks && t)
      for (const o of this.stackOfSelected)
        this.Editor.BlockSelection.unSelectBlockByIndex(o);
  }
  updateRectangleSize() {
    this.mouseY >= this.startY ? (this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.mouseY - window.pageYOffset}px`) : (this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.top = `${this.mouseY - window.pageYOffset}px`), this.mouseX >= this.startX ? (this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.mouseX - window.pageXOffset}px`) : (this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.left = `${this.mouseX - window.pageXOffset}px`);
  }
  genInfoForMouseSelection() {
    const t = document.body.offsetWidth / 2, o = this.mouseY - window.pageYOffset, i = document.elementFromPoint(t, o), s = this.Editor.BlockManager.getBlockByChildNode(i);
    let r;
    s !== undefined && (r = this.Editor.BlockManager.blocks.findIndex((h) => h.holder === s.holder));
    const a = this.Editor.BlockManager.lastBlock.holder.querySelector("." + R.CSS.content), l = Number.parseInt(window.getComputedStyle(a).width, 10) / 2, c = t - l, u = t + l;
    return {
      index: r,
      leftPos: c,
      rightPos: u
    };
  }
  addBlockInSelection(e) {
    this.rectCrossesBlocks && this.Editor.BlockSelection.selectBlockByIndex(e), this.stackOfSelected.push(e);
  }
  trySelectNextBlock(e) {
    const t = this.stackOfSelected[this.stackOfSelected.length - 1] === e, o = this.stackOfSelected.length, i = 1, s = -1, r = 0;
    if (t)
      return;
    const a = this.stackOfSelected[o - 1] - this.stackOfSelected[o - 2] > 0;
    let l = r;
    o > 1 && (l = a ? i : s);
    const c = e > this.stackOfSelected[o - 1] && l === i, u = e < this.stackOfSelected[o - 1] && l === s, p = !(c || u || l === r);
    if (!p && (e > this.stackOfSelected[o - 1] || this.stackOfSelected[o - 1] === undefined)) {
      let v = this.stackOfSelected[o - 1] + 1 || e;
      for (v;v <= e; v++)
        this.addBlockInSelection(v);
      return;
    }
    if (!p && e < this.stackOfSelected[o - 1]) {
      for (let v = this.stackOfSelected[o - 1] - 1;v >= e; v--)
        this.addBlockInSelection(v);
      return;
    }
    if (!p)
      return;
    let g = o - 1, f;
    for (e > this.stackOfSelected[o - 1] ? f = () => e > this.stackOfSelected[g] : f = () => e < this.stackOfSelected[g];f(); )
      this.rectCrossesBlocks && this.Editor.BlockSelection.unSelectBlockByIndex(this.stackOfSelected[g]), this.stackOfSelected.pop(), g--;
  }
}

class ga extends E {
  async render(e) {
    return new Promise((t) => {
      const { Tools: o, BlockManager: i } = this.Editor;
      if (e.length === 0)
        i.insert();
      else {
        const s = e.map(({ type: r, data: a, tunes: l, id: c }) => {
          o.available.has(r) === false && (X(`Tool «${r}» is not found. Check 'tools' property at the Editor.js config.`, "warn"), a = this.composeStubDataForTool(r, a, c), r = o.stubTool);
          let u;
          try {
            u = i.composeBlock({
              id: c,
              tool: r,
              data: a,
              tunes: l
            });
          } catch (h) {
            S(`Block «${r}» skipped because of plugins error`, "error", {
              data: a,
              error: h
            }), a = this.composeStubDataForTool(r, a, c), r = o.stubTool, u = i.composeBlock({
              id: c,
              tool: r,
              data: a,
              tunes: l
            });
          }
          return u;
        });
        i.insertMany(s);
      }
      window.requestIdleCallback(() => {
        t();
      }, { timeout: 2000 });
    });
  }
  composeStubDataForTool(e, t, o) {
    const { Tools: i } = this.Editor;
    let s = e;
    if (i.unavailable.has(e)) {
      const r = i.unavailable.get(e).toolbox;
      r !== undefined && r[0].title !== undefined && (s = r[0].title);
    }
    return {
      savedData: {
        id: o,
        type: e,
        data: t
      },
      title: s
    };
  }
}

class ma extends E {
  async save() {
    const { BlockManager: e, Tools: t } = this.Editor, o = e.blocks, i = [];
    try {
      o.forEach((a) => {
        i.push(this.getSavedData(a));
      });
      const s = await Promise.all(i), r = await yt(s, (a) => t.blockTools.get(a).sanitizeConfig);
      return this.makeOutput(r);
    } catch (s) {
      X("Saving failed due to the Error %o", "error", s);
    }
  }
  async getSavedData(e) {
    const t = await e.save(), o = t && await e.validate(t.data);
    return {
      ...t,
      isValid: o
    };
  }
  makeOutput(e) {
    const t = [];
    return e.forEach(({ id: o, tool: i, data: s, tunes: r, isValid: a }) => {
      if (!a) {
        S(`Block «${i}» skipped because saved data is invalid`);
        return;
      }
      if (i === this.Editor.Tools.stubTool) {
        t.push(s);
        return;
      }
      const l = {
        id: o,
        type: i,
        data: s,
        ...!V(r) && {
          tunes: r
        }
      };
      t.push(l);
    }), {
      time: +/* @__PURE__ */ new Date,
      blocks: t,
      version: "2.31.0-rc.7"
    };
  }
}
(function() {
  try {
    if (typeof document < "u") {
      var n = document.createElement("style");
      n.appendChild(document.createTextNode(".ce-paragraph{line-height:1.6em;outline:none}.ce-block:only-of-type .ce-paragraph[data-placeholder-active]:empty:before,.ce-block:only-of-type .ce-paragraph[data-placeholder-active][data-empty=true]:before{content:attr(data-placeholder-active)}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}")), document.head.appendChild(n);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
var ba = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14"/></svg>';
function va(n) {
  const e = document.createElement("div");
  e.innerHTML = n.trim();
  const t = document.createDocumentFragment();
  return t.append(...Array.from(e.childNodes)), t;
}

class fo {
  static get DEFAULT_PLACEHOLDER() {
    return "";
  }
  constructor({ data: e, config: t, api: o, readOnly: i }) {
    this.api = o, this.readOnly = i, this._CSS = {
      block: this.api.styles.block,
      wrapper: "ce-paragraph"
    }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = t.placeholder ? t.placeholder : fo.DEFAULT_PLACEHOLDER, this._data = e ?? {}, this._element = null, this._preserveBlank = t.preserveBlank ?? false;
  }
  onKeyUp(e) {
    if (e.code !== "Backspace" && e.code !== "Delete" || !this._element)
      return;
    const { textContent: t } = this._element;
    t === "" && (this._element.innerHTML = "");
  }
  drawView() {
    const e = document.createElement("DIV");
    return e.classList.add(this._CSS.wrapper, this._CSS.block), e.contentEditable = "false", e.dataset.placeholderActive = this.api.i18n.t(this._placeholder), this._data.text && (e.innerHTML = this._data.text), this.readOnly || (e.contentEditable = "true", e.addEventListener("keyup", this.onKeyUp)), e;
  }
  render() {
    return this._element = this.drawView(), this._element;
  }
  merge(e) {
    if (!this._element)
      return;
    this._data.text += e.text;
    const t = va(e.text);
    this._element.appendChild(t), this._element.normalize();
  }
  validate(e) {
    return !(e.text.trim() === "" && !this._preserveBlank);
  }
  save(e) {
    return {
      text: e.innerHTML
    };
  }
  onPaste(e) {
    const t = {
      text: e.detail.data.innerHTML
    };
    this._data = t, window.requestAnimationFrame(() => {
      this._element && (this._element.innerHTML = this._data.text || "");
    });
  }
  static get conversionConfig() {
    return {
      export: "text",
      import: "text"
    };
  }
  static get sanitize() {
    return {
      text: {
        br: true
      }
    };
  }
  static get isReadOnlySupported() {
    return true;
  }
  static get pasteConfig() {
    return {
      tags: ["P"]
    };
  }
  static get toolbox() {
    return {
      icon: ba,
      title: "Text"
    };
  }
}

class go {
  constructor() {
    this.commandName = "bold";
  }
  static get sanitize() {
    return {
      b: {}
    };
  }
  render() {
    return {
      icon: Ki,
      name: "bold",
      onActivate: () => {
        document.execCommand(this.commandName);
      },
      isActive: () => document.queryCommandState(this.commandName)
    };
  }
  get shortcut() {
    return "CMD+B";
  }
}
go.isInline = true;
go.title = "Bold";

class mo {
  constructor() {
    this.commandName = "italic", this.CSS = {
      button: "ce-inline-tool",
      buttonActive: "ce-inline-tool--active",
      buttonModifier: "ce-inline-tool--italic"
    }, this.nodes = {
      button: null
    };
  }
  static get sanitize() {
    return {
      i: {}
    };
  }
  render() {
    return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Ji, this.nodes.button;
  }
  surround() {
    document.execCommand(this.commandName);
  }
  checkState() {
    const e = document.queryCommandState(this.commandName);
    return this.nodes.button.classList.toggle(this.CSS.buttonActive, e), e;
  }
  get shortcut() {
    return "CMD+I";
  }
}
mo.isInline = true;
mo.title = "Italic";

class bo {
  constructor({ api: e }) {
    this.commandLink = "createLink", this.commandUnlink = "unlink", this.ENTER_KEY = 13, this.CSS = {
      button: "ce-inline-tool",
      buttonActive: "ce-inline-tool--active",
      buttonModifier: "ce-inline-tool--link",
      buttonUnlink: "ce-inline-tool--unlink",
      input: "ce-inline-tool-input",
      inputShowed: "ce-inline-tool-input--showed"
    }, this.nodes = {
      button: null,
      input: null
    }, this.inputOpened = false, this.toolbar = e.toolbar, this.inlineToolbar = e.inlineToolbar, this.notifier = e.notifier, this.i18n = e.i18n, this.selection = new b;
  }
  static get sanitize() {
    return {
      a: {
        href: true,
        target: "_blank",
        rel: "nofollow"
      }
    };
  }
  render() {
    return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Co, this.nodes.button;
  }
  renderActions() {
    return this.nodes.input = document.createElement("input"), this.nodes.input.placeholder = this.i18n.t("Add a link"), this.nodes.input.enterKeyHint = "done", this.nodes.input.classList.add(this.CSS.input), this.nodes.input.addEventListener("keydown", (e) => {
      e.keyCode === this.ENTER_KEY && this.enterPressed(e);
    }), this.nodes.input;
  }
  surround(e) {
    if (e) {
      this.inputOpened ? (this.selection.restore(), this.selection.removeFakeBackground()) : (this.selection.setFakeBackground(), this.selection.save());
      const t = this.selection.findParentTag("A");
      if (t) {
        this.selection.expandToTag(t), this.unlink(), this.closeActions(), this.checkState(), this.toolbar.close();
        return;
      }
    }
    this.toggleActions();
  }
  checkState() {
    const e = this.selection.findParentTag("A");
    if (e) {
      this.nodes.button.innerHTML = ns, this.nodes.button.classList.add(this.CSS.buttonUnlink), this.nodes.button.classList.add(this.CSS.buttonActive), this.openActions();
      const t = e.getAttribute("href");
      this.nodes.input.value = t !== "null" ? t : "", this.selection.save();
    } else
      this.nodes.button.innerHTML = Co, this.nodes.button.classList.remove(this.CSS.buttonUnlink), this.nodes.button.classList.remove(this.CSS.buttonActive);
    return !!e;
  }
  clear() {
    this.closeActions();
  }
  get shortcut() {
    return "CMD+K";
  }
  toggleActions() {
    this.inputOpened ? this.closeActions(false) : this.openActions(true);
  }
  openActions(e = false) {
    this.nodes.input.classList.add(this.CSS.inputShowed), e && this.nodes.input.focus(), this.inputOpened = true;
  }
  closeActions(e = true) {
    if (this.selection.isFakeBackgroundEnabled) {
      const t = new b;
      t.save(), this.selection.restore(), this.selection.removeFakeBackground(), t.restore();
    }
    this.nodes.input.classList.remove(this.CSS.inputShowed), this.nodes.input.value = "", e && this.selection.clearSaved(), this.inputOpened = false;
  }
  enterPressed(e) {
    let t = this.nodes.input.value || "";
    if (!t.trim()) {
      this.selection.restore(), this.unlink(), e.preventDefault(), this.closeActions();
      return;
    }
    if (!this.validateURL(t)) {
      this.notifier.show({
        message: "Pasted link is not valid.",
        style: "error"
      }), S("Incorrect Link pasted", "warn", t);
      return;
    }
    t = this.prepareLink(t), this.selection.restore(), this.selection.removeFakeBackground(), this.insertLink(t), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation(), this.selection.collapseToEnd(), this.inlineToolbar.close();
  }
  validateURL(e) {
    return !/\s/.test(e);
  }
  prepareLink(e) {
    return e = e.trim(), e = this.addProtocol(e), e;
  }
  addProtocol(e) {
    if (/^(\w+):(\/\/)?/.test(e))
      return e;
    const t = /^\/[^/\s]/.test(e), o = e.substring(0, 1) === "#", i = /^\/\/[^/\s]/.test(e);
    return !t && !o && !i && (e = "http://" + e), e;
  }
  insertLink(e) {
    const t = this.selection.findParentTag("A");
    t && this.selection.expandToTag(t), document.execCommand(this.commandLink, false, e);
  }
  unlink() {
    document.execCommand(this.commandUnlink);
  }
}
bo.isInline = true;
bo.title = "Link";

class Fn {
  constructor({ api: e }) {
    this.i18nAPI = e.i18n, this.blocksAPI = e.blocks, this.selectionAPI = e.selection, this.toolsAPI = e.tools, this.caretAPI = e.caret;
  }
  async render() {
    const e = b.get(), t = this.blocksAPI.getBlockByElement(e.anchorNode);
    if (t === undefined)
      return [];
    const o = this.toolsAPI.getBlockTools(), i = await Yo(t, o);
    if (i.length === 0)
      return [];
    const s = i.reduce((c, u) => {
      var h;
      return (h = u.toolbox) == null || h.forEach((p) => {
        c.push({
          icon: p.icon,
          title: z.t(K.toolNames, p.title),
          name: u.name,
          closeOnActivate: true,
          onActivate: async () => {
            const g = await this.blocksAPI.convert(t.id, u.name, p.data);
            this.caretAPI.setToBlock(g, "end");
          }
        });
      }), c;
    }, []), r = await t.getActiveToolboxEntry(), a = r !== undefined ? r.icon : Go, l = !be();
    return {
      icon: a,
      name: "convert-to",
      hint: {
        title: this.i18nAPI.t("Convert to")
      },
      children: {
        searchable: l,
        items: s,
        onOpen: () => {
          l && (this.selectionAPI.setFakeBackground(), this.selectionAPI.save());
        },
        onClose: () => {
          l && (this.selectionAPI.restore(), this.selectionAPI.removeFakeBackground());
        }
      }
    };
  }
}
Fn.isInline = true;

class jn {
  constructor({ data: e, api: t }) {
    this.CSS = {
      wrapper: "ce-stub",
      info: "ce-stub__info",
      title: "ce-stub__title",
      subtitle: "ce-stub__subtitle"
    }, this.api = t, this.title = e.title || this.api.i18n.t("Error"), this.subtitle = this.api.i18n.t("The block can not be displayed correctly."), this.savedData = e.savedData, this.wrapper = this.make();
  }
  render() {
    return this.wrapper;
  }
  save() {
    return this.savedData;
  }
  make() {
    const e = d.make("div", this.CSS.wrapper), t = is, o = d.make("div", this.CSS.info), i = d.make("div", this.CSS.title, {
      textContent: this.title
    }), s = d.make("div", this.CSS.subtitle, {
      textContent: this.subtitle
    });
    return e.innerHTML = t, o.appendChild(i), o.appendChild(s), e.appendChild(o), e;
  }
}
jn.isReadOnlySupported = true;

class ka extends Tt {
  constructor() {
    super(...arguments), this.type = ae.Inline;
  }
  get title() {
    return this.constructable[We.Title];
  }
  create() {
    return new this.constructable({
      api: this.api,
      config: this.settings
    });
  }
  get isReadOnlySupported() {
    return this.constructable[We.IsReadOnlySupported] ?? false;
  }
}

class ya extends Tt {
  constructor() {
    super(...arguments), this.type = ae.Tune;
  }
  create(e, t) {
    return new this.constructable({
      api: this.api,
      config: this.settings,
      block: t,
      data: e
    });
  }
}

class j extends Map {
  get blockTools() {
    const e = Array.from(this.entries()).filter(([, t]) => t.isBlock());
    return new j(e);
  }
  get inlineTools() {
    const e = Array.from(this.entries()).filter(([, t]) => t.isInline());
    return new j(e);
  }
  get blockTunes() {
    const e = Array.from(this.entries()).filter(([, t]) => t.isTune());
    return new j(e);
  }
  get internalTools() {
    const e = Array.from(this.entries()).filter(([, t]) => t.isInternal);
    return new j(e);
  }
  get externalTools() {
    const e = Array.from(this.entries()).filter(([, t]) => !t.isInternal);
    return new j(e);
  }
}
var wa = Object.defineProperty;
var Ea = Object.getOwnPropertyDescriptor;
var Hn = (n, e, t, o) => {
  for (var i = o > 1 ? undefined : o ? Ea(e, t) : e, s = n.length - 1, r;s >= 0; s--)
    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);
  return o && i && wa(e, t, i), i;
};

class vo extends Tt {
  constructor() {
    super(...arguments), this.type = ae.Block, this.inlineTools = new j, this.tunes = new j;
  }
  create(e, t, o) {
    return new this.constructable({
      data: e,
      block: t,
      readOnly: o,
      api: this.api,
      config: this.settings
    });
  }
  get isReadOnlySupported() {
    return this.constructable[pe.IsReadOnlySupported] === true;
  }
  get isLineBreaksEnabled() {
    return this.constructable[pe.IsEnabledLineBreaks];
  }
  get toolbox() {
    const e = this.constructable[pe.Toolbox], t = this.config[Pe.Toolbox];
    if (!V(e) && t !== false)
      return t ? Array.isArray(e) ? Array.isArray(t) ? t.map((o, i) => {
        const s = e[i];
        return s ? {
          ...s,
          ...o
        } : o;
      }) : [t] : Array.isArray(t) ? t : [
        {
          ...e,
          ...t
        }
      ] : Array.isArray(e) ? e : [e];
  }
  get conversionConfig() {
    return this.constructable[pe.ConversionConfig];
  }
  get enabledInlineTools() {
    return this.config[Pe.EnabledInlineTools] || false;
  }
  get enabledBlockTunes() {
    return this.config[Pe.EnabledBlockTunes];
  }
  get pasteConfig() {
    return this.constructable[pe.PasteConfig] ?? {};
  }
  get sanitizeConfig() {
    const e = super.sanitizeConfig, t = this.baseSanitizeConfig;
    if (V(e))
      return t;
    const o = {};
    for (const i in e)
      if (Object.prototype.hasOwnProperty.call(e, i)) {
        const s = e[i];
        D(s) ? o[i] = Object.assign({}, t, s) : o[i] = s;
      }
    return o;
  }
  get baseSanitizeConfig() {
    const e = {};
    return Array.from(this.inlineTools.values()).forEach((t) => Object.assign(e, t.sanitizeConfig)), Array.from(this.tunes.values()).forEach((t) => Object.assign(e, t.sanitizeConfig)), e;
  }
}
Hn([
  me
], vo.prototype, "sanitizeConfig", 1);
Hn([
  me
], vo.prototype, "baseSanitizeConfig", 1);

class xa {
  constructor(e, t, o) {
    this.api = o, this.config = e, this.editorConfig = t;
  }
  get(e) {
    const { class: t, isInternal: o = false, ...i } = this.config[e], s = this.getConstructor(t), r = t[mt.IsTune];
    return new s({
      name: e,
      constructable: t,
      config: i,
      api: this.api.getMethodsForTool(e, r),
      isDefault: e === this.editorConfig.defaultBlock,
      defaultPlaceholder: this.editorConfig.placeholder,
      isInternal: o
    });
  }
  getConstructor(e) {
    switch (true) {
      case e[We.IsInline]:
        return ka;
      case e[mt.IsTune]:
        return ya;
      default:
        return vo;
    }
  }
}

class $n {
  constructor({ api: e }) {
    this.CSS = {
      animation: "wobble"
    }, this.api = e;
  }
  render() {
    return {
      icon: Xi,
      title: this.api.i18n.t("Move down"),
      onActivate: () => this.handleClick(),
      name: "move-down"
    };
  }
  handleClick() {
    const e = this.api.blocks.getCurrentBlockIndex(), t = this.api.blocks.getBlockByIndex(e + 1);
    if (!t)
      throw new Error("Unable to move Block down since it is already the last");
    const o = t.holder, i = o.getBoundingClientRect();
    let s = Math.abs(window.innerHeight - o.offsetHeight);
    i.top < window.innerHeight && (s = window.scrollY + o.offsetHeight), window.scrollTo(0, s), this.api.blocks.move(e + 1), this.api.toolbar.toggleBlockSettings(true);
  }
}
$n.isTune = true;

class zn {
  constructor({ api: e }) {
    this.api = e;
  }
  render() {
    return {
      icon: Gi,
      title: this.api.i18n.t("Delete"),
      name: "delete",
      confirmation: {
        title: this.api.i18n.t("Click to delete"),
        onActivate: () => this.handleClick()
      }
    };
  }
  handleClick() {
    this.api.blocks.delete();
  }
}
zn.isTune = true;

class Un {
  constructor({ api: e }) {
    this.CSS = {
      animation: "wobble"
    }, this.api = e;
  }
  render() {
    return {
      icon: Zi,
      title: this.api.i18n.t("Move up"),
      onActivate: () => this.handleClick(),
      name: "move-up"
    };
  }
  handleClick() {
    const e = this.api.blocks.getCurrentBlockIndex(), t = this.api.blocks.getBlockByIndex(e), o = this.api.blocks.getBlockByIndex(e - 1);
    if (e === 0 || !t || !o)
      throw new Error("Unable to move Block up since it is already the first");
    const i = t.holder, s = o.holder, r = i.getBoundingClientRect(), a = s.getBoundingClientRect();
    let l;
    a.top > 0 ? l = Math.abs(r.top) - Math.abs(a.top) : l = Math.abs(r.top) + a.height, window.scrollBy(0, -1 * l), this.api.blocks.move(e - 1), this.api.toolbar.toggleBlockSettings(true);
  }
}
Un.isTune = true;
var Ba = Object.defineProperty;
var Ca = Object.getOwnPropertyDescriptor;
var Ta = (n, e, t, o) => {
  for (var i = o > 1 ? undefined : o ? Ca(e, t) : e, s = n.length - 1, r;s >= 0; s--)
    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);
  return o && i && Ba(e, t, i), i;
};

class Wn extends E {
  constructor() {
    super(...arguments), this.stubTool = "stub", this.toolsAvailable = new j, this.toolsUnavailable = new j;
  }
  get available() {
    return this.toolsAvailable;
  }
  get unavailable() {
    return this.toolsUnavailable;
  }
  get inlineTools() {
    return this.available.inlineTools;
  }
  get blockTools() {
    return this.available.blockTools;
  }
  get blockTunes() {
    return this.available.blockTunes;
  }
  get defaultTool() {
    return this.blockTools.get(this.config.defaultBlock);
  }
  get internal() {
    return this.available.internalTools;
  }
  async prepare() {
    if (this.validateTools(), this.config.tools = ut({}, this.internalTools, this.config.tools), !Object.prototype.hasOwnProperty.call(this.config, "tools") || Object.keys(this.config.tools).length === 0)
      throw Error("Can't start without tools");
    const e = this.prepareConfig();
    this.factory = new xa(e, this.config, this.Editor.API);
    const t = this.getListOfPrepareFunctions(e);
    if (t.length === 0)
      return Promise.resolve();
    await Qn(t, (o) => {
      this.toolPrepareMethodSuccess(o);
    }, (o) => {
      this.toolPrepareMethodFallback(o);
    }), this.prepareBlockTools();
  }
  getAllInlineToolsSanitizeConfig() {
    const e = {};
    return Array.from(this.inlineTools.values()).forEach((t) => {
      Object.assign(e, t.sanitizeConfig);
    }), e;
  }
  destroy() {
    Object.values(this.available).forEach(async (e) => {
      A(e.reset) && await e.reset();
    });
  }
  get internalTools() {
    return {
      convertTo: {
        class: Fn,
        isInternal: true
      },
      link: {
        class: bo,
        isInternal: true
      },
      bold: {
        class: go,
        isInternal: true
      },
      italic: {
        class: mo,
        isInternal: true
      },
      paragraph: {
        class: fo,
        inlineToolbar: true,
        isInternal: true
      },
      stub: {
        class: jn,
        isInternal: true
      },
      moveUp: {
        class: Un,
        isInternal: true
      },
      delete: {
        class: zn,
        isInternal: true
      },
      moveDown: {
        class: $n,
        isInternal: true
      }
    };
  }
  toolPrepareMethodSuccess(e) {
    const t = this.factory.get(e.toolName);
    if (t.isInline()) {
      const i = ["render"].filter((s) => !t.create()[s]);
      if (i.length) {
        S(`Incorrect Inline Tool: ${t.name}. Some of required methods is not implemented %o`, "warn", i), this.toolsUnavailable.set(t.name, t);
        return;
      }
    }
    this.toolsAvailable.set(t.name, t);
  }
  toolPrepareMethodFallback(e) {
    this.toolsUnavailable.set(e.toolName, this.factory.get(e.toolName));
  }
  getListOfPrepareFunctions(e) {
    const t = [];
    return Object.entries(e).forEach(([o, i]) => {
      t.push({
        function: A(i.class.prepare) ? i.class.prepare : () => {
        },
        data: {
          toolName: o,
          config: i.config
        }
      });
    }), t;
  }
  prepareBlockTools() {
    Array.from(this.blockTools.values()).forEach((e) => {
      this.assignInlineToolsToBlockTool(e), this.assignBlockTunesToBlockTool(e);
    });
  }
  assignInlineToolsToBlockTool(e) {
    if (this.config.inlineToolbar !== false) {
      if (e.enabledInlineTools === true) {
        e.inlineTools = new j(Array.isArray(this.config.inlineToolbar) ? this.config.inlineToolbar.map((t) => [t, this.inlineTools.get(t)]) : Array.from(this.inlineTools.entries()));
        return;
      }
      Array.isArray(e.enabledInlineTools) && (e.inlineTools = new j(["convertTo", ...e.enabledInlineTools].map((t) => [t, this.inlineTools.get(t)])));
    }
  }
  assignBlockTunesToBlockTool(e) {
    if (e.enabledBlockTunes !== false) {
      if (Array.isArray(e.enabledBlockTunes)) {
        const t = new j(e.enabledBlockTunes.map((o) => [o, this.blockTunes.get(o)]));
        e.tunes = new j([...t, ...this.blockTunes.internalTools]);
        return;
      }
      if (Array.isArray(this.config.tunes)) {
        const t = new j(this.config.tunes.map((o) => [o, this.blockTunes.get(o)]));
        e.tunes = new j([...t, ...this.blockTunes.internalTools]);
        return;
      }
      e.tunes = this.blockTunes.internalTools;
    }
  }
  validateTools() {
    for (const e in this.config.tools)
      if (Object.prototype.hasOwnProperty.call(this.config.tools, e)) {
        if (e in this.internalTools)
          return;
        const t = this.config.tools[e];
        if (!A(t) && !A(t.class))
          throw Error(`Tool «${e}» must be a constructor function or an object with function in the «class» property`);
      }
  }
  prepareConfig() {
    const e = {};
    for (const t in this.config.tools)
      D(this.config.tools[t]) ? e[t] = this.config.tools[t] : e[t] = { class: this.config.tools[t] };
    return e;
  }
}
Ta([
  me
], Wn.prototype, "getAllInlineToolsSanitizeConfig", 1);
var Sa = `:root{--selectionColor: #e1f2ff;--inlineSelectionColor: #d4ecff;--bg-light: #eff2f5;--grayText: #707684;--color-dark: #1D202B;--color-active-icon: #388AE5;--color-gray-border: rgba(201, 201, 204, .48);--content-width: 650px;--narrow-mode-right-padding: 50px;--toolbox-buttons-size: 26px;--toolbox-buttons-size--mobile: 36px;--icon-size: 20px;--icon-size--mobile: 28px;--block-padding-vertical: .4em;--color-line-gray: #EFF0F1 }.codex-editor{position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.codex-editor .hide{display:none}.codex-editor__redactor [contenteditable]:empty:after{content:"\\feff"}@media (min-width: 651px){.codex-editor--narrow .codex-editor__redactor{margin-right:50px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .codex-editor__redactor{margin-left:50px;margin-right:0}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__actions{right:-5px}}.codex-editor-copyable{position:absolute;height:1px;width:1px;top:-400%;opacity:.001}.codex-editor-overlay{position:fixed;top:0;left:0;right:0;bottom:0;z-index:999;pointer-events:none;overflow:hidden}.codex-editor-overlay__container{position:relative;pointer-events:auto;z-index:0}.codex-editor-overlay__rectangle{position:absolute;pointer-events:none;background-color:#2eaadc33;border:1px solid transparent}.codex-editor svg{max-height:100%}.codex-editor path{stroke:currentColor}.codex-editor ::-moz-selection{background-color:#d4ecff}.codex-editor ::selection{background-color:#d4ecff}.codex-editor--toolbox-opened [contentEditable=true][data-placeholder]:focus:before{opacity:0!important}.ce-scroll-locked{overflow:hidden}.ce-scroll-locked--hard{overflow:hidden;top:calc(-1 * var(--window-scroll-offset));position:fixed;width:100%}.ce-toolbar{position:absolute;left:0;right:0;top:0;-webkit-transition:opacity .1s ease;transition:opacity .1s ease;will-change:opacity,top;display:none}.ce-toolbar--opened{display:block}.ce-toolbar__content{max-width:650px;margin:0 auto;position:relative}.ce-toolbar__plus{color:#1d202b;cursor:pointer;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-flex-negative:0;flex-shrink:0}@media (max-width: 650px){.ce-toolbar__plus{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__plus:hover{background-color:#eff2f5}}.ce-toolbar__plus--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-toolbar__plus-shortcut{opacity:.6;word-spacing:-2px;margin-top:5px}@media (max-width: 650px){.ce-toolbar__plus{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__plus--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__plus--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__actions{position:absolute;right:100%;opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;padding-right:5px}.ce-toolbar__actions--opened{opacity:1}@media (max-width: 650px){.ce-toolbar__actions{right:auto}}.ce-toolbar__settings-btn{color:#1d202b;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;margin-left:3px;cursor:pointer;user-select:none}@media (max-width: 650px){.ce-toolbar__settings-btn{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__settings-btn:hover{background-color:#eff2f5}}.ce-toolbar__settings-btn--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}@media (min-width: 651px){.ce-toolbar__settings-btn{width:24px}}.ce-toolbar__settings-btn--hidden{display:none}@media (max-width: 650px){.ce-toolbar__settings-btn{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__settings-btn--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__settings-btn--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__plus svg,.ce-toolbar__settings-btn svg{width:24px;height:24px}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__plus{left:5px}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbox .ce-popover{right:0;left:auto;left:initial}}.ce-inline-toolbar{--y-offset: 8px;--color-background-icon-active: rgba(56, 138, 229, .1);--color-text-icon-active: #388AE5;--color-text-primary: black;position:absolute;visibility:hidden;-webkit-transition:opacity .25s ease;transition:opacity .25s ease;will-change:opacity,left,top;top:0;left:0;z-index:3;opacity:1;visibility:visible}.ce-inline-toolbar [hidden]{display:none!important}.ce-inline-toolbar__toggler-and-button-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;padding:0 6px}.ce-inline-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown{display:-webkit-box;display:-ms-flexbox;display:flex;padding:6px;margin:0 6px 0 -6px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-right:1px solid rgba(201,201,204,.48);-webkit-box-sizing:border-box;box-sizing:border-box}@media (hover: hover){.ce-inline-toolbar__dropdown:hover{background:#eff2f5}}.ce-inline-toolbar__dropdown--hidden{display:none}.ce-inline-toolbar__dropdown-content,.ce-inline-toolbar__dropdown-arrow{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown-content svg,.ce-inline-toolbar__dropdown-arrow svg{width:20px;height:20px}.ce-inline-toolbar__shortcut{opacity:.6;word-spacing:-3px;margin-top:3px}.ce-inline-tool{color:var(--color-text-primary);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border:0;border-radius:4px;line-height:normal;height:100%;padding:0;width:28px;background-color:transparent;cursor:pointer}@media (max-width: 650px){.ce-inline-tool{width:36px;height:36px}}@media (hover: hover){.ce-inline-tool:hover{background-color:#f8f8f8}}.ce-inline-tool svg{display:block;width:20px;height:20px}@media (max-width: 650px){.ce-inline-tool svg{width:28px;height:28px}}.ce-inline-tool--link .icon--unlink,.ce-inline-tool--unlink .icon--link{display:none}.ce-inline-tool--unlink .icon--unlink{display:inline-block;margin-bottom:-1px}.ce-inline-tool-input{background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:4px 8px;font-size:14px;line-height:22px;outline:none;margin:0;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:none;font-weight:500;-webkit-appearance:none;font-family:inherit}@media (max-width: 650px){.ce-inline-tool-input{font-size:15px;font-weight:500}}.ce-inline-tool-input::-webkit-input-placeholder{color:#707684}.ce-inline-tool-input::-moz-placeholder{color:#707684}.ce-inline-tool-input:-ms-input-placeholder{color:#707684}.ce-inline-tool-input::-ms-input-placeholder{color:#707684}.ce-inline-tool-input::placeholder{color:#707684}.ce-inline-tool-input--showed{display:block}.ce-inline-tool--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}@-webkit-keyframes fade-in{0%{opacity:0}to{opacity:1}}@keyframes fade-in{0%{opacity:0}to{opacity:1}}.ce-block{-webkit-animation:fade-in .3s ease;animation:fade-in .3s ease;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-animation-fill-mode:initial;animation-fill-mode:initial}.ce-block:first-of-type{margin-top:0}.ce-block--selected .ce-block__content{background:#e1f2ff}.ce-block--selected .ce-block__content [contenteditable]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ce-block--selected .ce-block__content img,.ce-block--selected .ce-block__content .ce-stub{opacity:.55}.ce-block--stretched .ce-block__content{max-width:none}.ce-block__content{position:relative;max-width:650px;margin:0 auto;-webkit-transition:background-color .15s ease;transition:background-color .15s ease}.ce-block--drop-target .ce-block__content:before{content:"";position:absolute;top:100%;left:-20px;margin-top:-1px;height:8px;width:8px;border:solid #388AE5;border-width:1px 1px 0 0;-webkit-transform-origin:right;transform-origin:right;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.ce-block--drop-target .ce-block__content:after{content:"";position:absolute;top:100%;height:1px;width:100%;color:#388ae5;background:repeating-linear-gradient(90deg,#388AE5,#388AE5 1px,#fff 1px,#fff 6px)}.ce-block a{cursor:pointer;-webkit-text-decoration:underline;text-decoration:underline}.ce-block b{font-weight:700}.ce-block i{font-style:italic}@-webkit-keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}.cdx-block{padding:.4em 0}.cdx-block::-webkit-input-placeholder{line-height:normal!important}.cdx-input{border:1px solid rgba(201,201,204,.48);-webkit-box-shadow:inset 0 1px 2px 0 rgba(35,44,72,.06);box-shadow:inset 0 1px 2px #232c480f;border-radius:3px;padding:10px 12px;outline:none;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.cdx-input[data-placeholder]:before{position:static!important}.cdx-input[data-placeholder]:before{display:inline-block;width:0;white-space:nowrap;pointer-events:none}.cdx-settings-button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;min-width:26px;min-height:26px}.cdx-settings-button--focused{background:rgba(34,186,255,.08)!important}.cdx-settings-button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.cdx-settings-button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.cdx-settings-button--active{color:#388ae5}.cdx-settings-button svg{width:auto;height:auto}@media (max-width: 650px){.cdx-settings-button svg{width:28px;height:28px}}@media (max-width: 650px){.cdx-settings-button{width:36px;height:36px;border-radius:8px}}@media (hover: hover){.cdx-settings-button:hover{background-color:#eff2f5}}.cdx-loader{position:relative;border:1px solid rgba(201,201,204,.48)}.cdx-loader:before{content:"";position:absolute;left:50%;top:50%;width:18px;height:18px;margin:-11px 0 0 -11px;border:2px solid rgba(201,201,204,.48);border-left-color:#388ae5;border-radius:50%;-webkit-animation:cdxRotation 1.2s infinite linear;animation:cdxRotation 1.2s infinite linear}@-webkit-keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.cdx-button{padding:13px;border-radius:3px;border:1px solid rgba(201,201,204,.48);font-size:14.9px;background:#fff;-webkit-box-shadow:0 2px 2px 0 rgba(18,30,57,.04);box-shadow:0 2px 2px #121e390a;color:#707684;text-align:center;cursor:pointer}@media (hover: hover){.cdx-button:hover{background:#FBFCFE;-webkit-box-shadow:0 1px 3px 0 rgba(18,30,57,.08);box-shadow:0 1px 3px #121e3914}}.cdx-button svg{height:20px;margin-right:.2em;margin-top:-2px}.ce-stub{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:12px 18px;margin:10px 0;border-radius:10px;background:#eff2f5;border:1px solid #EFF0F1;color:#707684;font-size:14px}.ce-stub svg{width:20px;height:20px}.ce-stub__info{margin-left:14px}.ce-stub__title{font-weight:500;text-transform:capitalize}.codex-editor.codex-editor--rtl{direction:rtl}.codex-editor.codex-editor--rtl .cdx-list{padding-left:0;padding-right:40px}.codex-editor.codex-editor--rtl .ce-toolbar__plus{right:-26px;left:auto}.codex-editor.codex-editor--rtl .ce-toolbar__actions{right:auto;left:-26px}@media (max-width: 650px){.codex-editor.codex-editor--rtl .ce-toolbar__actions{margin-left:0;margin-right:auto;padding-right:0;padding-left:10px}}.codex-editor.codex-editor--rtl .ce-settings{left:5px;right:auto}.codex-editor.codex-editor--rtl .ce-settings:before{right:auto;left:25px}.codex-editor.codex-editor--rtl .ce-settings__button:not(:nth-child(3n+3)){margin-left:3px;margin-right:0}.codex-editor.codex-editor--rtl .ce-conversion-tool__icon{margin-right:0;margin-left:10px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown{border-right:0px solid transparent;border-left:1px solid rgba(201,201,204,.48);margin:0 -6px 0 6px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown .icon--toggler-down{margin-left:0;margin-right:4px}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__plus{left:0;right:5px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__actions{left:-5px}}.cdx-search-field{--icon-margin-right: 10px;background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-search-field__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:var(--icon-margin-right)}.cdx-search-field__icon svg{width:20px;height:20px;color:#707684}.cdx-search-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - 26px - var(--icon-margin-right))}.cdx-search-field__input::-webkit-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-moz-placeholder{color:#707684;font-weight:500}.cdx-search-field__input:-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::placeholder{color:#707684;font-weight:500}.ce-popover{--border-radius: 6px;--width: 200px;--max-height: 270px;--padding: 6px;--offset-from-target: 8px;--color-border: #EFF0F1;--color-shadow: rgba(13, 20, 33, .1);--color-background: white;--color-text-primary: black;--color-text-secondary: #707684;--color-border-icon: rgba(201, 201, 204, .48);--color-border-icon-disabled: #EFF0F1;--color-text-icon-active: #388AE5;--color-background-icon-active: rgba(56, 138, 229, .1);--color-background-item-focus: rgba(34, 186, 255, .08);--color-shadow-item-focus: rgba(7, 161, 227, .08);--color-background-item-hover: #F8F8F8;--color-background-item-confirm: #E24A4A;--color-background-item-confirm-hover: #CE4343;--popover-top: calc(100% + var(--offset-from-target));--popover-left: 0;--nested-popover-overlap: 4px;--icon-size: 20px;--item-padding: 3px;--item-height: calc(var(--icon-size) + 2 * var(--item-padding))}.ce-popover__container{min-width:var(--width);width:var(--width);max-height:var(--max-height);border-radius:var(--border-radius);overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-shadow:0px 3px 15px -3px var(--color-shadow);box-shadow:0 3px 15px -3px var(--color-shadow);position:absolute;left:var(--popover-left);top:var(--popover-top);background:var(--color-background);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:4;opacity:0;max-height:0;pointer-events:none;padding:0;border:none}.ce-popover--opened>.ce-popover__container{opacity:1;padding:var(--padding);max-height:var(--max-height);pointer-events:auto;-webkit-animation:panelShowing .1s ease;animation:panelShowing .1s ease;border:1px solid var(--color-border)}@media (max-width: 650px){.ce-popover--opened>.ce-popover__container{-webkit-animation:panelShowingMobile .25s ease;animation:panelShowingMobile .25s ease}}.ce-popover--open-top .ce-popover__container{--popover-top: calc(-1 * (var(--offset-from-target) + var(--popover-height)))}.ce-popover--open-left .ce-popover__container{--popover-left: calc(-1 * var(--width) + 100%)}.ce-popover__items{overflow-y:auto;-ms-scroll-chaining:none;overscroll-behavior:contain}@media (max-width: 650px){.ce-popover__overlay{position:fixed;top:0;bottom:0;left:0;right:0;background:#1D202B;z-index:3;opacity:.5;-webkit-transition:opacity .12s ease-in;transition:opacity .12s ease-in;will-change:opacity;visibility:visible}}.ce-popover__overlay--hidden{display:none}@media (max-width: 650px){.ce-popover .ce-popover__container{--offset: 5px;position:fixed;max-width:none;min-width:calc(100% - var(--offset) * 2);left:var(--offset);right:var(--offset);bottom:calc(var(--offset) + env(safe-area-inset-bottom));top:auto;border-radius:10px}}.ce-popover__search{margin-bottom:5px}.ce-popover__nothing-found-message{color:#707684;display:none;cursor:default;padding:3px;font-size:14px;line-height:20px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ce-popover__nothing-found-message--displayed{display:block}.ce-popover--nested .ce-popover__container{--popover-left: calc(var(--nesting-level) * (var(--width) - var(--nested-popover-overlap)));top:calc(var(--trigger-item-top) - var(--nested-popover-overlap));position:absolute}.ce-popover--open-top.ce-popover--nested .ce-popover__container{top:calc(var(--trigger-item-top) - var(--popover-height) + var(--item-height) + var(--offset-from-target) + var(--nested-popover-overlap))}.ce-popover--open-left .ce-popover--nested .ce-popover__container{--popover-left: calc(-1 * (var(--nesting-level) + 1) * var(--width) + 100%)}.ce-popover-item-separator{padding:4px 3px}.ce-popover-item-separator--hidden{display:none}.ce-popover-item-separator__line{height:1px;background:var(--color-border);width:100%}.ce-popover-item-html--hidden{display:none}.ce-popover-item{--border-radius: 6px;border-radius:var(--border-radius);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:var(--item-padding);color:var(--color-text-primary);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border:none;background:transparent}@media (max-width: 650px){.ce-popover-item{padding:4px}}.ce-popover-item:not(:last-of-type){margin-bottom:1px}.ce-popover-item__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover-item__icon{width:36px;height:36px;border-radius:8px}.ce-popover-item__icon svg{width:28px;height:28px}}.ce-popover-item__icon--tool{margin-right:4px}.ce-popover-item__title{font-size:14px;line-height:20px;font-weight:500;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin-right:auto}@media (max-width: 650px){.ce-popover-item__title{font-size:16px}}.ce-popover-item__secondary-title{color:var(--color-text-secondary);font-size:12px;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;opacity:.6}@media (max-width: 650px){.ce-popover-item__secondary-title{display:none}}.ce-popover-item--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}.ce-popover-item--disabled{color:var(--color-text-secondary);cursor:default;pointer-events:none}.ce-popover-item--focused:not(.ce-popover-item--no-focus){background:var(--color-background-item-focus)!important}.ce-popover-item--hidden{display:none}@media (hover: hover){.ce-popover-item:hover{cursor:pointer}.ce-popover-item:hover:not(.ce-popover-item--no-hover){background-color:var(--color-background-item-hover)}}.ce-popover-item--confirmation{background:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__title,.ce-popover-item--confirmation .ce-popover-item__icon{color:#fff}@media (hover: hover){.ce-popover-item--confirmation:not(.ce-popover-item--no-hover):hover{background:var(--color-background-item-confirm-hover)}}.ce-popover-item--confirmation:not(.ce-popover-item--no-focus).ce-popover-item--focused{background:var(--color-background-item-confirm-hover)!important}@-webkit-keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}.wobble{-webkit-animation-name:wobble;animation-name:wobble;-webkit-animation-duration:.4s;animation-duration:.4s}@-webkit-keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}@keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}.ce-popover-header{margin-bottom:8px;margin-top:4px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-popover-header__text{font-size:18px;font-weight:600}.ce-popover-header__back-button{border:0;background:transparent;width:36px;height:36px;color:var(--color-text-primary)}.ce-popover-header__back-button svg{display:block;width:28px;height:28px}.ce-popover--inline{--height: 38px;--height-mobile: 46px;--container-padding: 4px;position:relative}.ce-popover--inline .ce-popover__custom-content{margin-bottom:0}.ce-popover--inline .ce-popover__items{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-popover--inline .ce-popover__container{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:var(--container-padding);height:var(--height);top:0;min-width:-webkit-max-content;min-width:-moz-max-content;min-width:max-content;width:-webkit-max-content;width:-moz-max-content;width:max-content;-webkit-animation:none;animation:none}@media (max-width: 650px){.ce-popover--inline .ce-popover__container{height:var(--height-mobile);position:absolute}}.ce-popover--inline .ce-popover-item-separator{padding:0 4px}.ce-popover--inline .ce-popover-item-separator__line{height:100%;width:1px}.ce-popover--inline .ce-popover-item{border-radius:4px;padding:4px}.ce-popover--inline .ce-popover-item__icon--tool{-webkit-box-shadow:none;box-shadow:none;background:transparent;margin-right:0}.ce-popover--inline .ce-popover-item__icon{width:auto;width:initial;height:auto;height:initial}.ce-popover--inline .ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover--inline .ce-popover-item__icon svg{width:28px;height:28px}}.ce-popover--inline .ce-popover-item:not(:last-of-type){margin-bottom:0;margin-bottom:initial}.ce-popover--inline .ce-popover-item-html{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-popover--inline .ce-popover-item__icon--chevron-right{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.ce-popover--inline .ce-popover--nested-level-1 .ce-popover__container{--offset: 3px;left:0;top:calc(var(--height) + var(--offset))}@media (max-width: 650px){.ce-popover--inline .ce-popover--nested-level-1 .ce-popover__container{top:calc(var(--height-mobile) + var(--offset))}}.ce-popover--inline .ce-popover--nested .ce-popover__container{min-width:var(--width);width:var(--width);height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;padding:6px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.ce-popover--inline .ce-popover--nested .ce-popover__items{display:block;width:100%}.ce-popover--inline .ce-popover--nested .ce-popover-item{border-radius:6px;padding:3px}@media (max-width: 650px){.ce-popover--inline .ce-popover--nested .ce-popover-item{padding:4px}}.ce-popover--inline .ce-popover--nested .ce-popover-item__icon--tool{margin-right:4px}.ce-popover--inline .ce-popover--nested .ce-popover-item__icon{width:26px;height:26px}.ce-popover--inline .ce-popover--nested .ce-popover-item-separator{padding:4px 3px}.ce-popover--inline .ce-popover--nested .ce-popover-item-separator__line{width:100%;height:1px}.codex-editor [data-placeholder]:empty:before,.codex-editor [data-placeholder][data-empty=true]:before{pointer-events:none;color:#707684;cursor:text;content:attr(data-placeholder)}.codex-editor [data-placeholder-active]:empty:before,.codex-editor [data-placeholder-active][data-empty=true]:before{pointer-events:none;color:#707684;cursor:text}.codex-editor [data-placeholder-active]:empty:focus:before,.codex-editor [data-placeholder-active][data-empty=true]:focus:before{content:attr(data-placeholder-active)}
`;

class Ia extends E {
  constructor() {
    super(...arguments), this.isMobile = false, this.contentRectCache = null, this.resizeDebouncer = Eo(() => {
      this.windowResize();
    }, 200), this.selectionChangeDebounced = Eo(() => {
      this.selectionChanged();
    }, da), this.documentTouchedListener = (e) => {
      this.documentTouched(e);
    };
  }
  get CSS() {
    return {
      editorWrapper: "codex-editor",
      editorWrapperNarrow: "codex-editor--narrow",
      editorZone: "codex-editor__redactor",
      editorZoneHidden: "codex-editor__redactor--hidden",
      editorEmpty: "codex-editor--empty",
      editorRtlFix: "codex-editor--rtl"
    };
  }
  get contentRect() {
    if (this.contentRectCache !== null)
      return this.contentRectCache;
    const e = this.nodes.wrapper.querySelector(`.${R.CSS.content}`);
    return e ? (this.contentRectCache = e.getBoundingClientRect(), this.contentRectCache) : {
      width: 650,
      left: 0,
      right: 0
    };
  }
  async prepare() {
    this.setIsMobile(), this.make(), this.loadStyles();
  }
  toggleReadOnly(e) {
    e ? this.unbindReadOnlySensitiveListeners() : window.requestIdleCallback(() => {
      this.bindReadOnlySensitiveListeners();
    }, {
      timeout: 2000
    });
  }
  checkEmptiness() {
    const { BlockManager: e } = this.Editor;
    this.nodes.wrapper.classList.toggle(this.CSS.editorEmpty, e.isEditorEmpty);
  }
  get someToolbarOpened() {
    const { Toolbar: e, BlockSettings: t, InlineToolbar: o } = this.Editor;
    return !!(t.opened || o.opened || e.toolbox.opened);
  }
  get someFlipperButtonFocused() {
    return this.Editor.Toolbar.toolbox.hasFocus() ? true : Object.entries(this.Editor).filter(([e, t]) => t.flipper instanceof ce).some(([e, t]) => t.flipper.hasFocus());
  }
  destroy() {
    this.nodes.holder.innerHTML = "", this.unbindReadOnlyInsensitiveListeners();
  }
  closeAllToolbars() {
    const { Toolbar: e, BlockSettings: t, InlineToolbar: o } = this.Editor;
    t.close(), o.close(), e.toolbox.close();
  }
  setIsMobile() {
    const e = window.innerWidth < Ro;
    e !== this.isMobile && this.eventsDispatcher.emit(Te, {
      isEnabled: this.isMobile
    }), this.isMobile = e;
  }
  make() {
    this.nodes.holder = d.getHolder(this.config.holder), this.nodes.wrapper = d.make("div", [
      this.CSS.editorWrapper,
      ...this.isRtl ? [this.CSS.editorRtlFix] : []
    ]), this.nodes.redactor = d.make("div", this.CSS.editorZone), this.nodes.holder.offsetWidth < this.contentRect.width && this.nodes.wrapper.classList.add(this.CSS.editorWrapperNarrow), this.nodes.redactor.style.paddingBottom = this.config.minHeight + "px", this.nodes.wrapper.appendChild(this.nodes.redactor), this.nodes.holder.appendChild(this.nodes.wrapper), this.bindReadOnlyInsensitiveListeners();
  }
  loadStyles() {
    const e = "editor-js-styles";
    if (d.get(e))
      return;
    const t = d.make("style", null, {
      id: e,
      textContent: Sa.toString()
    });
    this.config.style && !V(this.config.style) && this.config.style.nonce && t.setAttribute("nonce", this.config.style.nonce), d.prepend(document.head, t);
  }
  bindReadOnlyInsensitiveListeners() {
    this.listeners.on(document, "selectionchange", this.selectionChangeDebounced), this.listeners.on(window, "resize", this.resizeDebouncer, {
      passive: true
    }), this.listeners.on(this.nodes.redactor, "mousedown", this.documentTouchedListener, {
      capture: true,
      passive: true
    }), this.listeners.on(this.nodes.redactor, "touchstart", this.documentTouchedListener, {
      capture: true,
      passive: true
    });
  }
  unbindReadOnlyInsensitiveListeners() {
    this.listeners.off(document, "selectionchange", this.selectionChangeDebounced), this.listeners.off(window, "resize", this.resizeDebouncer), this.listeners.off(this.nodes.redactor, "mousedown", this.documentTouchedListener), this.listeners.off(this.nodes.redactor, "touchstart", this.documentTouchedListener);
  }
  bindReadOnlySensitiveListeners() {
    this.readOnlyMutableListeners.on(this.nodes.redactor, "click", (e) => {
      this.redactorClicked(e);
    }, false), this.readOnlyMutableListeners.on(document, "keydown", (e) => {
      this.documentKeydown(e);
    }, true), this.readOnlyMutableListeners.on(document, "mousedown", (e) => {
      this.documentClicked(e);
    }, true), this.watchBlockHoveredEvents(), this.enableInputsEmptyMark();
  }
  watchBlockHoveredEvents() {
    let e;
    this.readOnlyMutableListeners.on(this.nodes.redactor, "mousemove", dt((t) => {
      const o = t.target.closest(".ce-block");
      this.Editor.BlockSelection.anyBlockSelected || o && e !== o && (e = o, this.eventsDispatcher.emit(ln, {
        block: this.Editor.BlockManager.getBlockByChildNode(o)
      }));
    }, 20), {
      passive: true
    });
  }
  unbindReadOnlySensitiveListeners() {
    this.readOnlyMutableListeners.clearAll();
  }
  windowResize() {
    this.contentRectCache = null, this.setIsMobile();
  }
  documentKeydown(e) {
    switch (e.keyCode) {
      case y.ENTER:
        this.enterPressed(e);
        break;
      case y.BACKSPACE:
      case y.DELETE:
        this.backspacePressed(e);
        break;
      case y.ESC:
        this.escapePressed(e);
        break;
      default:
        this.defaultBehaviour(e);
        break;
    }
  }
  defaultBehaviour(e) {
    const { currentBlock: t } = this.Editor.BlockManager, o = e.target.closest(`.${this.CSS.editorWrapper}`), i = e.altKey || e.ctrlKey || e.metaKey || e.shiftKey;
    if (t !== undefined && o === null) {
      this.Editor.BlockEvents.keydown(e);
      return;
    }
    o || t && i || (this.Editor.BlockManager.unsetCurrentBlock(), this.Editor.Toolbar.close());
  }
  backspacePressed(e) {
    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor;
    if (o.anyBlockSelected && !b.isSelectionExists) {
      const s = t.removeSelectedBlocks(), r = t.insertDefaultBlockAtIndex(s, true);
      i.setToBlock(r, i.positions.START), o.clearSelection(e), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation();
    }
  }
  escapePressed(e) {
    this.Editor.BlockSelection.clearSelection(e), this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.toolbox.close(), this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END)) : this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.InlineToolbar.opened ? this.Editor.InlineToolbar.close() : this.Editor.Toolbar.close();
  }
  enterPressed(e) {
    const { BlockManager: t, BlockSelection: o } = this.Editor;
    if (this.someToolbarOpened)
      return;
    const i = t.currentBlockIndex >= 0;
    if (o.anyBlockSelected && !b.isSelectionExists) {
      o.clearSelection(e), e.preventDefault(), e.stopImmediatePropagation(), e.stopPropagation();
      return;
    }
    if (!this.someToolbarOpened && i && e.target.tagName === "BODY") {
      const s = this.Editor.BlockManager.insert();
      e.preventDefault(), this.Editor.Caret.setToBlock(s), this.Editor.Toolbar.moveAndOpen(s);
    }
    this.Editor.BlockSelection.clearSelection(e);
  }
  documentClicked(e) {
    var a, l;
    if (!e.isTrusted)
      return;
    const t = e.target;
    this.nodes.holder.contains(t) || b.isAtEditor || (this.Editor.BlockManager.unsetCurrentBlock(), this.Editor.Toolbar.close());
    const i = (a = this.Editor.BlockSettings.nodes.wrapper) == null ? undefined : a.contains(t), s = (l = this.Editor.Toolbar.nodes.settingsToggler) == null ? undefined : l.contains(t), r = i || s;
    if (this.Editor.BlockSettings.opened && !r) {
      this.Editor.BlockSettings.close();
      const c = this.Editor.BlockManager.getBlockByChildNode(t);
      this.Editor.Toolbar.moveAndOpen(c);
    }
    this.Editor.BlockSelection.clearSelection(e);
  }
  documentTouched(e) {
    let t = e.target;
    if (t === this.nodes.redactor) {
      const o = e instanceof MouseEvent ? e.clientX : e.touches[0].clientX, i = e instanceof MouseEvent ? e.clientY : e.touches[0].clientY;
      t = document.elementFromPoint(o, i);
    }
    try {
      this.Editor.BlockManager.setCurrentBlockByChildNode(t);
    } catch {
      this.Editor.RectangleSelection.isRectActivated() || this.Editor.Caret.setToTheLastBlock();
    }
    this.Editor.ReadOnly.isEnabled || this.Editor.Toolbar.moveAndOpen();
  }
  redactorClicked(e) {
    if (!b.isCollapsed)
      return;
    const t = e.target, o = e.metaKey || e.ctrlKey;
    if (d.isAnchor(t) && o) {
      e.stopImmediatePropagation(), e.stopPropagation();
      const i = t.getAttribute("href"), s = oi(i);
      ii(s);
      return;
    }
    this.processBottomZoneClick(e);
  }
  processBottomZoneClick(e) {
    const t = this.Editor.BlockManager.getBlockByIndex(-1), o = d.offset(t.holder).bottom, i = e.pageY, { BlockSelection: s } = this.Editor;
    if (e.target instanceof Element && e.target.isEqualNode(this.nodes.redactor) && !s.anyBlockSelected && o < i) {
      e.stopImmediatePropagation(), e.stopPropagation();
      const { BlockManager: a, Caret: l, Toolbar: c } = this.Editor;
      (!a.lastBlock.tool.isDefault || !a.lastBlock.isEmpty) && a.insertAtEnd(), l.setToTheLastBlock(), c.moveAndOpen(a.lastBlock);
    }
  }
  selectionChanged() {
    const { CrossBlockSelection: e, BlockSelection: t } = this.Editor, o = b.anchorElement;
    if (e.isCrossBlockSelectionStarted && t.anyBlockSelected && b.get().removeAllRanges(), !o) {
      b.range || this.Editor.InlineToolbar.close();
      return;
    }
    const i = o.closest(`.${R.CSS.content}`);
    (i === null || i.closest(`.${b.CSS.editorWrapper}`) !== this.nodes.wrapper) && (this.Editor.InlineToolbar.containsNode(o) || this.Editor.InlineToolbar.close(), !(o.dataset.inlineToolbar === "true")) || (this.Editor.BlockManager.currentBlock || this.Editor.BlockManager.setCurrentBlockByChildNode(o), this.Editor.InlineToolbar.tryToShow(true));
  }
  enableInputsEmptyMark() {
    function e(t) {
      const o = t.target;
      Do(o);
    }
    this.readOnlyMutableListeners.on(this.nodes.wrapper, "input", e), this.readOnlyMutableListeners.on(this.nodes.wrapper, "focusin", e), this.readOnlyMutableListeners.on(this.nodes.wrapper, "focusout", e);
  }
}
var Oa = {
  BlocksAPI: gi,
  CaretAPI: bi,
  EventsAPI: vi,
  I18nAPI: kt,
  API: ki,
  InlineToolbarAPI: yi,
  ListenersAPI: wi,
  NotifierAPI: Ci,
  ReadOnlyAPI: Ti,
  SanitizerAPI: Li,
  SaverAPI: Pi,
  SelectionAPI: Ni,
  ToolsAPI: Ri,
  StylesAPI: Di,
  ToolbarAPI: Fi,
  TooltipAPI: Ui,
  UiAPI: Wi,
  BlockSettings: ms,
  Toolbar: Bs,
  InlineToolbar: Cs,
  BlockEvents: na,
  BlockManager: ra,
  BlockSelection: aa,
  Caret: Ye,
  CrossBlockSelection: la,
  DragNDrop: ca,
  ModificationsObserver: ha,
  Paste: pa,
  ReadOnly: fa,
  RectangleSelection: Be,
  Renderer: ga,
  Saver: ma,
  Tools: Wn,
  UI: Ia
};

class _a {
  constructor(e) {
    this.moduleInstances = {}, this.eventsDispatcher = new Oe;
    let t, o;
    this.isReady = new Promise((i, s) => {
      t = i, o = s;
    }), Promise.resolve().then(async () => {
      this.configuration = e, this.validate(), this.init(), await this.start(), await this.render();
      const { BlockManager: i, Caret: s, UI: r, ModificationsObserver: a } = this.moduleInstances;
      r.checkEmptiness(), a.enable(), this.configuration.autofocus === true && this.configuration.readOnly !== true && s.setToBlock(i.blocks[0], s.positions.START), t();
    }).catch((i) => {
      S(`Editor.js is not ready because of ${i}`, "error"), o(i);
    });
  }
  set configuration(e) {
    var o, i;
    D(e) ? this.config = {
      ...e
    } : this.config = {
      holder: e
    }, ht(!!this.config.holderId, "config.holderId", "config.holder"), this.config.holderId && !this.config.holder && (this.config.holder = this.config.holderId, this.config.holderId = null), this.config.holder == null && (this.config.holder = "editorjs"), this.config.logLevel || (this.config.logLevel = Lo.VERBOSE), Zn(this.config.logLevel), ht(!!this.config.initialBlock, "config.initialBlock", "config.defaultBlock"), this.config.defaultBlock = this.config.defaultBlock || this.config.initialBlock || "paragraph", this.config.minHeight = this.config.minHeight !== undefined ? this.config.minHeight : 300;
    const t = {
      type: this.config.defaultBlock,
      data: {}
    };
    this.config.placeholder = this.config.placeholder || false, this.config.sanitizer = this.config.sanitizer || {
      p: true,
      b: true,
      a: true
    }, this.config.hideToolbar = this.config.hideToolbar ? this.config.hideToolbar : false, this.config.tools = this.config.tools || {}, this.config.i18n = this.config.i18n || {}, this.config.data = this.config.data || { blocks: [] }, this.config.onReady = this.config.onReady || (() => {
    }), this.config.onChange = this.config.onChange || (() => {
    }), this.config.inlineToolbar = this.config.inlineToolbar !== undefined ? this.config.inlineToolbar : true, (V(this.config.data) || !this.config.data.blocks || this.config.data.blocks.length === 0) && (this.config.data = { blocks: [t] }), this.config.readOnly = this.config.readOnly || false, (o = this.config.i18n) != null && o.messages && z.setDictionary(this.config.i18n.messages), this.config.i18n.direction = ((i = this.config.i18n) == null ? undefined : i.direction) || "ltr";
  }
  get configuration() {
    return this.config;
  }
  validate() {
    const { holderId: e, holder: t } = this.config;
    if (e && t)
      throw Error("«holderId» and «holder» param can't assign at the same time.");
    if (te(t) && !d.get(t))
      throw Error(`element with ID «${t}» is missing. Pass correct holder's ID.`);
    if (t && D(t) && !d.isElement(t))
      throw Error("«holder» value must be an Element node");
  }
  init() {
    this.constructModules(), this.configureModules();
  }
  async start() {
    await [
      "Tools",
      "UI",
      "BlockManager",
      "Paste",
      "BlockSelection",
      "RectangleSelection",
      "CrossBlockSelection",
      "ReadOnly"
    ].reduce((t, o) => t.then(async () => {
      try {
        await this.moduleInstances[o].prepare();
      } catch (i) {
        if (i instanceof Ho)
          throw new Error(i.message);
        S(`Module ${o} was skipped because of %o`, "warn", i);
      }
    }), Promise.resolve());
  }
  render() {
    return this.moduleInstances.Renderer.render(this.config.data.blocks);
  }
  constructModules() {
    Object.entries(Oa).forEach(([e, t]) => {
      try {
        this.moduleInstances[e] = new t({
          config: this.configuration,
          eventsDispatcher: this.eventsDispatcher
        });
      } catch (o) {
        S("[constructModules]", `Module ${e} skipped because`, "error", o);
      }
    });
  }
  configureModules() {
    for (const e in this.moduleInstances)
      Object.prototype.hasOwnProperty.call(this.moduleInstances, e) && (this.moduleInstances[e].state = this.getModulesDiff(e));
  }
  getModulesDiff(e) {
    const t = {};
    for (const o in this.moduleInstances)
      o !== e && (t[o] = this.moduleInstances[o]);
    return t;
  }
}

class Aa {
  static get version() {
    return "2.31.0-rc.7";
  }
  constructor(e) {
    let t = () => {
    };
    D(e) && A(e.onReady) && (t = e.onReady);
    const o = new _a(e);
    this.isReady = o.isReady.then(() => {
      this.exportAPI(o), t();
    });
  }
  exportAPI(e) {
    const t = ["configuration"], o = () => {
      Object.values(e.moduleInstances).forEach((s) => {
        A(s.destroy) && s.destroy(), s.listeners.removeAll();
      }), zi(), e = null;
      for (const s in this)
        Object.prototype.hasOwnProperty.call(this, s) && delete this[s];
      Object.setPrototypeOf(this, null);
    };
    t.forEach((s) => {
      this[s] = e[s];
    }), this.destroy = o, Object.setPrototypeOf(this, e.moduleInstances.API.methods), delete this.exportAPI, Object.entries({
      blocks: {
        clear: "clear",
        render: "render"
      },
      caret: {
        focus: "focus"
      },
      events: {
        on: "on",
        off: "off",
        emit: "emit"
      },
      saver: {
        save: "save"
      }
    }).forEach(([s, r]) => {
      Object.entries(r).forEach(([a, l]) => {
        this[l] = e.moduleInstances.API.methods[s][a];
      });
    });
  }
}

// node_modules/@editorjs/header/dist/header.mjs
(function() {
  try {
    if (typeof document < "u") {
      var e = document.createElement("style");
      e.appendChild(document.createTextNode(".ce-header{padding:.6em 0 3px;margin:0;line-height:1.25em;outline:none}.ce-header p,.ce-header div{padding:0!important;margin:0!important}")), document.head.appendChild(e);
    }
  } catch (n) {
    console.error("vite-plugin-css-injected-by-js", n);
  }
})();
var a = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M19 17V10.2135C19 10.1287 18.9011 10.0824 18.836 10.1367L16 12.5"/></svg>';
var l = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 11C16 10 19 9.5 19 12C19 13.9771 16.0684 13.9997 16.0012 16.8981C15.9999 16.9533 16.0448 17 16.1 17L19.3 17"/></svg>';
var o = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 11C16 10.5 16.8323 10 17.6 10C18.3677 10 19.5 10.311 19.5 11.5C19.5 12.5315 18.7474 12.9022 18.548 12.9823C18.5378 12.9864 18.5395 13.0047 18.5503 13.0063C18.8115 13.0456 20 13.3065 20 14.8C20 16 19.5 17 17.8 17C17.8 17 16 17 16 16.3"/></svg>';
var h = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M18 10L15.2834 14.8511C15.246 14.9178 15.294 15 15.3704 15C16.8489 15 18.7561 15 20.2 15M19 17C19 15.7187 19 14.8813 19 13.6"/></svg>';
var d2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 15.9C16 15.9 16.3768 17 17.8 17C19.5 17 20 15.6199 20 14.7C20 12.7323 17.6745 12.0486 16.1635 12.9894C16.094 13.0327 16 12.9846 16 12.9027V10.1C16 10.0448 16.0448 10 16.1 10H19.8"/></svg>';
var u = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M19.5 10C16.5 10.5 16 13.3285 16 15M16 15V15C16 16.1046 16.8954 17 18 17H18.3246C19.3251 17 20.3191 16.3492 20.2522 15.3509C20.0612 12.4958 16 12.6611 16 15Z"/></svg>';
var g = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9 7L9 12M9 17V12M9 12L15 12M15 7V12M15 17L15 12"/></svg>';

class v {
  constructor({ data: e, config: t, api: s, readOnly: r }) {
    this.api = s, this.readOnly = r, this._settings = t, this._data = this.normalizeData(e), this._element = this.getTag();
  }
  get _CSS() {
    return {
      block: this.api.styles.block,
      wrapper: "ce-header"
    };
  }
  isHeaderData(e) {
    return e.text !== undefined;
  }
  normalizeData(e) {
    const t = { text: "", level: this.defaultLevel.number };
    return this.isHeaderData(e) && (t.text = e.text || "", e.level !== undefined && !isNaN(parseInt(e.level.toString())) && (t.level = parseInt(e.level.toString()))), t;
  }
  render() {
    return this._element;
  }
  renderSettings() {
    return this.levels.map((e) => ({
      icon: e.svg,
      label: this.api.i18n.t(`Heading ${e.number}`),
      onActivate: () => this.setLevel(e.number),
      closeOnActivate: true,
      isActive: this.currentLevel.number === e.number,
      render: () => document.createElement("div")
    }));
  }
  setLevel(e) {
    this.data = {
      level: e,
      text: this.data.text
    };
  }
  merge(e) {
    this._element.insertAdjacentHTML("beforeend", e.text);
  }
  validate(e) {
    return e.text.trim() !== "";
  }
  save(e) {
    return {
      text: e.innerHTML,
      level: this.currentLevel.number
    };
  }
  static get conversionConfig() {
    return {
      export: "text",
      import: "text"
    };
  }
  static get sanitize() {
    return {
      level: false,
      text: {}
    };
  }
  static get isReadOnlySupported() {
    return true;
  }
  get data() {
    return this._data.text = this._element.innerHTML, this._data.level = this.currentLevel.number, this._data;
  }
  set data(e) {
    if (this._data = this.normalizeData(e), e.level !== undefined && this._element.parentNode) {
      const t = this.getTag();
      t.innerHTML = this._element.innerHTML, this._element.parentNode.replaceChild(t, this._element), this._element = t;
    }
    e.text !== undefined && (this._element.innerHTML = this._data.text || "");
  }
  getTag() {
    const e = document.createElement(this.currentLevel.tag);
    return e.innerHTML = this._data.text || "", e.classList.add(this._CSS.wrapper), e.contentEditable = this.readOnly ? "false" : "true", e.dataset.placeholder = this.api.i18n.t(this._settings.placeholder || ""), e;
  }
  get currentLevel() {
    let e = this.levels.find((t) => t.number === this._data.level);
    return e || (e = this.defaultLevel), e;
  }
  get defaultLevel() {
    if (this._settings.defaultLevel) {
      const e = this.levels.find((t) => t.number === this._settings.defaultLevel);
      if (e)
        return e;
      console.warn("(ง'̀-'́)ง Heading Tool: the default level specified was not found in available levels");
    }
    return this.levels[1];
  }
  get levels() {
    const e = [
      {
        number: 1,
        tag: "H1",
        svg: a
      },
      {
        number: 2,
        tag: "H2",
        svg: l
      },
      {
        number: 3,
        tag: "H3",
        svg: o
      },
      {
        number: 4,
        tag: "H4",
        svg: h
      },
      {
        number: 5,
        tag: "H5",
        svg: d2
      },
      {
        number: 6,
        tag: "H6",
        svg: u
      }
    ];
    return this._settings.levels ? e.filter((t) => this._settings.levels.includes(t.number)) : e;
  }
  onPaste(e) {
    const t = e.detail;
    if ("data" in t) {
      const s = t.data;
      let r = this.defaultLevel.number;
      switch (s.tagName) {
        case "H1":
          r = 1;
          break;
        case "H2":
          r = 2;
          break;
        case "H3":
          r = 3;
          break;
        case "H4":
          r = 4;
          break;
        case "H5":
          r = 5;
          break;
        case "H6":
          r = 6;
          break;
      }
      this._settings.levels && (r = this._settings.levels.reduce((n, i) => Math.abs(i - r) < Math.abs(n - r) ? i : n)), this.data = {
        level: r,
        text: s.innerHTML
      };
    }
  }
  static get pasteConfig() {
    return {
      tags: ["H1", "H2", "H3", "H4", "H5", "H6"]
    };
  }
  static get toolbox() {
    return {
      icon: g,
      title: "Heading"
    };
  }
}

// node_modules/@editorjs/quote/dist/quote.mjs
(function() {
  try {
    if (typeof document < "u") {
      var t = document.createElement("style");
      t.appendChild(document.createTextNode(".cdx-quote-icon svg{transform:rotate(180deg)}.cdx-quote{margin:0}.cdx-quote__text{min-height:158px;margin-bottom:10px}.cdx-quote [contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.cdx-quote [contentEditable=true][data-placeholder]:empty:before{opacity:1}.cdx-quote [contentEditable=true][data-placeholder]:empty:focus:before{opacity:0}.cdx-quote-settings{display:flex}.cdx-quote-settings .cdx-settings-button{width:50%}")), document.head.appendChild(t);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
var De2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M18 7L6 7"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M18 17H6"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 12L8 12"/></svg>';
var He2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M17 7L5 7"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M17 17H5"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M13 12L5 12"/></svg>';
var Re2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 10.8182L9 10.8182C8.80222 10.8182 8.60888 10.7649 8.44443 10.665C8.27998 10.5651 8.15181 10.4231 8.07612 10.257C8.00043 10.0909 7.98063 9.90808 8.01922 9.73174C8.0578 9.55539 8.15304 9.39341 8.29289 9.26627C8.43275 9.13913 8.61093 9.05255 8.80491 9.01747C8.99889 8.98239 9.19996 9.00039 9.38268 9.0692C9.56541 9.13801 9.72159 9.25453 9.83147 9.40403C9.94135 9.55353 10 9.72929 10 9.90909L10 12.1818C10 12.664 9.78929 13.1265 9.41421 13.4675C9.03914 13.8084 8.53043 14 8 14"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 10.8182L15 10.8182C14.8022 10.8182 14.6089 10.7649 14.4444 10.665C14.28 10.5651 14.1518 10.4231 14.0761 10.257C14.0004 10.0909 13.9806 9.90808 14.0192 9.73174C14.0578 9.55539 14.153 9.39341 14.2929 9.26627C14.4327 9.13913 14.6109 9.05255 14.8049 9.01747C14.9989 8.98239 15.2 9.00039 15.3827 9.0692C15.5654 9.13801 15.7216 9.25453 15.8315 9.40403C15.9414 9.55353 16 9.72929 16 9.90909L16 12.1818C16 12.664 15.7893 13.1265 15.4142 13.4675C15.0391 13.8084 14.5304 14 14 14"/></svg>';
var b2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Fe2(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: true }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: true,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var v2 = {};
var P2 = {};
var j2 = {};
Object.defineProperty(j2, "__esModule", { value: true });
j2.allInputsSelector = We2;
function We2() {
  var e = ["text", "password", "email", "number", "search", "tel", "url"];
  return "[contenteditable=true], textarea, input:not([type]), " + e.map(function(t) {
    return 'input[type="'.concat(t, '"]');
  }).join(", ");
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.allInputsSelector = undefined;
  var t = j2;
  Object.defineProperty(e, "allInputsSelector", { enumerable: true, get: function() {
    return t.allInputsSelector;
  } });
})(P2);
var c = {};
var T = {};
Object.defineProperty(T, "__esModule", { value: true });
T.isNativeInput = Ue2;
function Ue2(e) {
  var t = [
    "INPUT",
    "TEXTAREA"
  ];
  return e && e.tagName ? t.includes(e.tagName) : false;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isNativeInput = undefined;
  var t = T;
  Object.defineProperty(e, "isNativeInput", { enumerable: true, get: function() {
    return t.isNativeInput;
  } });
})(c);
var ie = {};
var C = {};
Object.defineProperty(C, "__esModule", { value: true });
C.append = qe2;
function qe2(e, t) {
  Array.isArray(t) ? t.forEach(function(n) {
    e.appendChild(n);
  }) : e.appendChild(t);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.append = undefined;
  var t = C;
  Object.defineProperty(e, "append", { enumerable: true, get: function() {
    return t.append;
  } });
})(ie);
var L2 = {};
var S2 = {};
Object.defineProperty(S2, "__esModule", { value: true });
S2.blockElements = ze2;
function ze2() {
  return [
    "address",
    "article",
    "aside",
    "blockquote",
    "canvas",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "hr",
    "li",
    "main",
    "nav",
    "noscript",
    "ol",
    "output",
    "p",
    "pre",
    "ruby",
    "section",
    "table",
    "tbody",
    "thead",
    "tr",
    "tfoot",
    "ul",
    "video"
  ];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.blockElements = undefined;
  var t = S2;
  Object.defineProperty(e, "blockElements", { enumerable: true, get: function() {
    return t.blockElements;
  } });
})(L2);
var ae2 = {};
var M = {};
Object.defineProperty(M, "__esModule", { value: true });
M.calculateBaseline = Ge2;
function Ge2(e) {
  var t = window.getComputedStyle(e), n = parseFloat(t.fontSize), r = parseFloat(t.lineHeight) || n * 1.2, i = parseFloat(t.paddingTop), a2 = parseFloat(t.borderTopWidth), l2 = parseFloat(t.marginTop), u2 = n * 0.8, d3 = (r - n) / 2, s = l2 + a2 + i + d3 + u2;
  return s;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.calculateBaseline = undefined;
  var t = M;
  Object.defineProperty(e, "calculateBaseline", { enumerable: true, get: function() {
    return t.calculateBaseline;
  } });
})(ae2);
var le2 = {};
var k = {};
var w = {};
var N = {};
Object.defineProperty(N, "__esModule", { value: true });
N.isContentEditable = Ke2;
function Ke2(e) {
  return e.contentEditable === "true";
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isContentEditable = undefined;
  var t = N;
  Object.defineProperty(e, "isContentEditable", { enumerable: true, get: function() {
    return t.isContentEditable;
  } });
})(w);
Object.defineProperty(k, "__esModule", { value: true });
k.canSetCaret = Qe2;
var Xe2 = c;
var Ye2 = w;
function Qe2(e) {
  var t = true;
  if ((0, Xe2.isNativeInput)(e))
    switch (e.type) {
      case "file":
      case "checkbox":
      case "radio":
      case "hidden":
      case "submit":
      case "button":
      case "image":
      case "reset":
        t = false;
        break;
    }
  else
    t = (0, Ye2.isContentEditable)(e);
  return t;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.canSetCaret = undefined;
  var t = k;
  Object.defineProperty(e, "canSetCaret", { enumerable: true, get: function() {
    return t.canSetCaret;
  } });
})(le2);
var y2 = {};
var I = {};
function Ve2(e, t, n) {
  const r = n.value !== undefined ? "value" : "get", i = n[r], a2 = `#${t}Cache`;
  if (n[r] = function(...l2) {
    return this[a2] === undefined && (this[a2] = i.apply(this, l2)), this[a2];
  }, r === "get" && n.set) {
    const l2 = n.set;
    n.set = function(u2) {
      delete e[a2], l2.apply(this, u2);
    };
  }
  return n;
}
function ue2() {
  const e = {
    win: false,
    mac: false,
    x11: false,
    linux: false
  }, t = Object.keys(e).find((n) => window.navigator.appVersion.toLowerCase().indexOf(n) !== -1);
  return t !== undefined && (e[t] = true), e;
}
function A2(e) {
  return e != null && e !== "" && (typeof e != "object" || Object.keys(e).length > 0);
}
function Ze2(e) {
  return !A2(e);
}
var Je2 = () => typeof window < "u" && window.navigator !== null && A2(window.navigator.platform) && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
function xe2(e) {
  const t = ue2();
  return e = e.replace(/shift/gi, "⇧").replace(/backspace/gi, "⌫").replace(/enter/gi, "⏎").replace(/up/gi, "↑").replace(/left/gi, "→").replace(/down/gi, "↓").replace(/right/gi, "←").replace(/escape/gi, "⎋").replace(/insert/gi, "Ins").replace(/delete/gi, "␡").replace(/\+/gi, "+"), t.mac ? e = e.replace(/ctrl|cmd/gi, "⌘").replace(/alt/gi, "⌥") : e = e.replace(/cmd/gi, "Ctrl").replace(/windows/gi, "WIN"), e;
}
function et2(e) {
  return e[0].toUpperCase() + e.slice(1);
}
function tt(e) {
  const t = document.createElement("div");
  t.style.position = "absolute", t.style.left = "-999px", t.style.bottom = "-999px", t.innerHTML = e, document.body.appendChild(t);
  const n = window.getSelection(), r = document.createRange();
  if (r.selectNode(t), n === null)
    throw new Error("Cannot copy text to clipboard");
  n.removeAllRanges(), n.addRange(r), document.execCommand("copy"), document.body.removeChild(t);
}
function nt2(e, t, n) {
  let r;
  return (...i) => {
    const a2 = this, l2 = () => {
      r = undefined, n !== true && e.apply(a2, i);
    }, u2 = n === true && r !== undefined;
    window.clearTimeout(r), r = window.setTimeout(l2, t), u2 && e.apply(a2, i);
  };
}
function o2(e) {
  return Object.prototype.toString.call(e).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
}
function rt2(e) {
  return o2(e) === "boolean";
}
function oe2(e) {
  return o2(e) === "function" || o2(e) === "asyncfunction";
}
function it2(e) {
  return oe2(e) && /^\s*class\s+/.test(e.toString());
}
function at2(e) {
  return o2(e) === "number";
}
function g2(e) {
  return o2(e) === "object";
}
function lt2(e) {
  return Promise.resolve(e) === e;
}
function ut2(e) {
  return o2(e) === "string";
}
function ot2(e) {
  return o2(e) === "undefined";
}
function O(e, ...t) {
  if (!t.length)
    return e;
  const n = t.shift();
  if (g2(e) && g2(n))
    for (const r in n)
      g2(n[r]) ? (e[r] === undefined && Object.assign(e, { [r]: {} }), O(e[r], n[r])) : Object.assign(e, { [r]: n[r] });
  return O(e, ...t);
}
function st2(e, t, n) {
  const r = `«${t}» is deprecated and will be removed in the next major release. Please use the «${n}» instead.`;
  e && console.warn(r);
}
function ct2(e) {
  try {
    return new URL(e).href;
  } catch {
  }
  return e.substring(0, 2) === "//" ? window.location.protocol + e : window.location.origin + e;
}
function dt2(e) {
  return e > 47 && e < 58 || e === 32 || e === 13 || e === 229 || e > 64 && e < 91 || e > 95 && e < 112 || e > 185 && e < 193 || e > 218 && e < 223;
}
var ft2 = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  ESC: 27,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  DOWN: 40,
  RIGHT: 39,
  DELETE: 46,
  META: 91,
  SLASH: 191
};
var pt2 = {
  LEFT: 0,
  WHEEL: 1,
  RIGHT: 2,
  BACKWARD: 3,
  FORWARD: 4
};

class vt2 {
  constructor() {
    this.completed = Promise.resolve();
  }
  add(t) {
    return new Promise((n, r) => {
      this.completed = this.completed.then(t).then(n).catch(r);
    });
  }
}
function gt2(e, t, n = undefined) {
  let r, i, a2, l2 = null, u2 = 0;
  n || (n = {});
  const d3 = function() {
    u2 = n.leading === false ? 0 : Date.now(), l2 = null, a2 = e.apply(r, i), l2 === null && (r = i = null);
  };
  return function() {
    const s = Date.now();
    !u2 && n.leading === false && (u2 = s);
    const f = t - (s - u2);
    return r = this, i = arguments, f <= 0 || f > t ? (l2 && (clearTimeout(l2), l2 = null), u2 = s, a2 = e.apply(r, i), l2 === null && (r = i = null)) : !l2 && n.trailing !== false && (l2 = setTimeout(d3, f)), a2;
  };
}
var mt2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PromiseQueue: vt2,
  beautifyShortcut: xe2,
  cacheable: Ve2,
  capitalize: et2,
  copyTextToClipboard: tt,
  debounce: nt2,
  deepMerge: O,
  deprecationAssert: st2,
  getUserOS: ue2,
  getValidUrl: ct2,
  isBoolean: rt2,
  isClass: it2,
  isEmpty: Ze2,
  isFunction: oe2,
  isIosDevice: Je2,
  isNumber: at2,
  isObject: g2,
  isPrintableKey: dt2,
  isPromise: lt2,
  isString: ut2,
  isUndefined: ot2,
  keyCodes: ft2,
  mouseButtons: pt2,
  notEmpty: A2,
  throttle: gt2,
  typeOf: o2
}, Symbol.toStringTag, { value: "Module" }));
var $2 = /* @__PURE__ */ Fe2(mt2);
Object.defineProperty(I, "__esModule", { value: true });
I.containsOnlyInlineElements = _t2;
var bt2 = $2;
var yt2 = L2;
function _t2(e) {
  var t;
  (0, bt2.isString)(e) ? (t = document.createElement("div"), t.innerHTML = e) : t = e;
  var n = function(r) {
    return !(0, yt2.blockElements)().includes(r.tagName.toLowerCase()) && Array.from(r.children).every(n);
  };
  return Array.from(t.children).every(n);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.containsOnlyInlineElements = undefined;
  var t = I;
  Object.defineProperty(e, "containsOnlyInlineElements", { enumerable: true, get: function() {
    return t.containsOnlyInlineElements;
  } });
})(y2);
var se = {};
var B = {};
var _2 = {};
var D2 = {};
Object.defineProperty(D2, "__esModule", { value: true });
D2.make = ht2;
function ht2(e, t, n) {
  var r;
  t === undefined && (t = null), n === undefined && (n = {});
  var i = document.createElement(e);
  if (Array.isArray(t)) {
    var a2 = t.filter(function(u2) {
      return u2 !== undefined;
    });
    (r = i.classList).add.apply(r, a2);
  } else
    t !== null && i.classList.add(t);
  for (var l2 in n)
    Object.prototype.hasOwnProperty.call(n, l2) && (i[l2] = n[l2]);
  return i;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.make = undefined;
  var t = D2;
  Object.defineProperty(e, "make", { enumerable: true, get: function() {
    return t.make;
  } });
})(_2);
Object.defineProperty(B, "__esModule", { value: true });
B.fragmentToString = Ot2;
var Et2 = _2;
function Ot2(e) {
  var t = (0, Et2.make)("div");
  return t.appendChild(e), t.innerHTML;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.fragmentToString = undefined;
  var t = B;
  Object.defineProperty(e, "fragmentToString", { enumerable: true, get: function() {
    return t.fragmentToString;
  } });
})(se);
var ce2 = {};
var H = {};
Object.defineProperty(H, "__esModule", { value: true });
H.getContentLength = jt2;
var Pt2 = c;
function jt2(e) {
  var t, n;
  return (0, Pt2.isNativeInput)(e) ? e.value.length : e.nodeType === Node.TEXT_NODE ? e.length : (n = (t = e.textContent) === null || t === undefined ? undefined : t.length) !== null && n !== undefined ? n : 0;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.getContentLength = undefined;
  var t = H;
  Object.defineProperty(e, "getContentLength", { enumerable: true, get: function() {
    return t.getContentLength;
  } });
})(ce2);
var R2 = {};
var F = {};
var re2 = b2 && b2.__spreadArray || function(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = t.length, a2;r < i; r++)
      (a2 || !(r in t)) && (a2 || (a2 = Array.prototype.slice.call(t, 0, r)), a2[r] = t[r]);
  return e.concat(a2 || Array.prototype.slice.call(t));
};
Object.defineProperty(F, "__esModule", { value: true });
F.getDeepestBlockElements = de2;
var Tt2 = y2;
function de2(e) {
  return (0, Tt2.containsOnlyInlineElements)(e) ? [e] : Array.from(e.children).reduce(function(t, n) {
    return re2(re2([], t, true), de2(n), true);
  }, []);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.getDeepestBlockElements = undefined;
  var t = F;
  Object.defineProperty(e, "getDeepestBlockElements", { enumerable: true, get: function() {
    return t.getDeepestBlockElements;
  } });
})(R2);
var fe2 = {};
var W = {};
var h2 = {};
var U2 = {};
Object.defineProperty(U2, "__esModule", { value: true });
U2.isLineBreakTag = Ct2;
function Ct2(e) {
  return [
    "BR",
    "WBR"
  ].includes(e.tagName);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isLineBreakTag = undefined;
  var t = U2;
  Object.defineProperty(e, "isLineBreakTag", { enumerable: true, get: function() {
    return t.isLineBreakTag;
  } });
})(h2);
var E2 = {};
var q = {};
Object.defineProperty(q, "__esModule", { value: true });
q.isSingleTag = Lt2;
function Lt2(e) {
  return [
    "AREA",
    "BASE",
    "BR",
    "COL",
    "COMMAND",
    "EMBED",
    "HR",
    "IMG",
    "INPUT",
    "KEYGEN",
    "LINK",
    "META",
    "PARAM",
    "SOURCE",
    "TRACK",
    "WBR"
  ].includes(e.tagName);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isSingleTag = undefined;
  var t = q;
  Object.defineProperty(e, "isSingleTag", { enumerable: true, get: function() {
    return t.isSingleTag;
  } });
})(E2);
Object.defineProperty(W, "__esModule", { value: true });
W.getDeepestNode = pe2;
var St2 = c;
var Mt2 = h2;
var kt2 = E2;
function pe2(e, t) {
  t === undefined && (t = false);
  var n = t ? "lastChild" : "firstChild", r = t ? "previousSibling" : "nextSibling";
  if (e.nodeType === Node.ELEMENT_NODE && e[n]) {
    var i = e[n];
    if ((0, kt2.isSingleTag)(i) && !(0, St2.isNativeInput)(i) && !(0, Mt2.isLineBreakTag)(i))
      if (i[r])
        i = i[r];
      else if (i.parentNode !== null && i.parentNode[r])
        i = i.parentNode[r];
      else
        return i.parentNode;
    return pe2(i, t);
  }
  return e;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.getDeepestNode = undefined;
  var t = W;
  Object.defineProperty(e, "getDeepestNode", { enumerable: true, get: function() {
    return t.getDeepestNode;
  } });
})(fe2);
var ve = {};
var z2 = {};
var p = b2 && b2.__spreadArray || function(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = t.length, a2;r < i; r++)
      (a2 || !(r in t)) && (a2 || (a2 = Array.prototype.slice.call(t, 0, r)), a2[r] = t[r]);
  return e.concat(a2 || Array.prototype.slice.call(t));
};
Object.defineProperty(z2, "__esModule", { value: true });
z2.findAllInputs = $t2;
var wt2 = y2;
var Nt2 = R2;
var It2 = P2;
var At2 = c;
function $t2(e) {
  return Array.from(e.querySelectorAll((0, It2.allInputsSelector)())).reduce(function(t, n) {
    return (0, At2.isNativeInput)(n) || (0, wt2.containsOnlyInlineElements)(n) ? p(p([], t, true), [n], false) : p(p([], t, true), (0, Nt2.getDeepestBlockElements)(n), true);
  }, []);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.findAllInputs = undefined;
  var t = z2;
  Object.defineProperty(e, "findAllInputs", { enumerable: true, get: function() {
    return t.findAllInputs;
  } });
})(ve);
var ge2 = {};
var G2 = {};
Object.defineProperty(G2, "__esModule", { value: true });
G2.isCollapsedWhitespaces = Bt2;
function Bt2(e) {
  return !/[^\t\n\r ]/.test(e);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isCollapsedWhitespaces = undefined;
  var t = G2;
  Object.defineProperty(e, "isCollapsedWhitespaces", { enumerable: true, get: function() {
    return t.isCollapsedWhitespaces;
  } });
})(ge2);
var K2 = {};
var X2 = {};
Object.defineProperty(X2, "__esModule", { value: true });
X2.isElement = Ht2;
var Dt2 = $2;
function Ht2(e) {
  return (0, Dt2.isNumber)(e) ? false : !!e && !!e.nodeType && e.nodeType === Node.ELEMENT_NODE;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isElement = undefined;
  var t = X2;
  Object.defineProperty(e, "isElement", { enumerable: true, get: function() {
    return t.isElement;
  } });
})(K2);
var me2 = {};
var Y2 = {};
var Q = {};
var V2 = {};
Object.defineProperty(V2, "__esModule", { value: true });
V2.isLeaf = Rt2;
function Rt2(e) {
  return e === null ? false : e.childNodes.length === 0;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isLeaf = undefined;
  var t = V2;
  Object.defineProperty(e, "isLeaf", { enumerable: true, get: function() {
    return t.isLeaf;
  } });
})(Q);
var Z2 = {};
var J2 = {};
Object.defineProperty(J2, "__esModule", { value: true });
J2.isNodeEmpty = zt2;
var Ft2 = h2;
var Wt2 = K2;
var Ut2 = c;
var qt2 = E2;
function zt2(e, t) {
  var n = "";
  return (0, qt2.isSingleTag)(e) && !(0, Ft2.isLineBreakTag)(e) ? false : ((0, Wt2.isElement)(e) && (0, Ut2.isNativeInput)(e) ? n = e.value : e.textContent !== null && (n = e.textContent.replace("​", "")), t !== undefined && (n = n.replace(new RegExp(t, "g"), "")), n.trim().length === 0);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isNodeEmpty = undefined;
  var t = J2;
  Object.defineProperty(e, "isNodeEmpty", { enumerable: true, get: function() {
    return t.isNodeEmpty;
  } });
})(Z2);
Object.defineProperty(Y2, "__esModule", { value: true });
Y2.isEmpty = Xt2;
var Gt2 = Q;
var Kt2 = Z2;
function Xt2(e, t) {
  e.normalize();
  for (var n = [e];n.length > 0; ) {
    var r = n.shift();
    if (r) {
      if (e = r, (0, Gt2.isLeaf)(e) && !(0, Kt2.isNodeEmpty)(e, t))
        return false;
      n.push.apply(n, Array.from(e.childNodes));
    }
  }
  return true;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isEmpty = undefined;
  var t = Y2;
  Object.defineProperty(e, "isEmpty", { enumerable: true, get: function() {
    return t.isEmpty;
  } });
})(me2);
var be2 = {};
var x = {};
Object.defineProperty(x, "__esModule", { value: true });
x.isFragment = Qt2;
var Yt2 = $2;
function Qt2(e) {
  return (0, Yt2.isNumber)(e) ? false : !!e && !!e.nodeType && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isFragment = undefined;
  var t = x;
  Object.defineProperty(e, "isFragment", { enumerable: true, get: function() {
    return t.isFragment;
  } });
})(be2);
var ye2 = {};
var ee2 = {};
Object.defineProperty(ee2, "__esModule", { value: true });
ee2.isHTMLString = Zt2;
var Vt2 = _2;
function Zt2(e) {
  var t = (0, Vt2.make)("div");
  return t.innerHTML = e, t.childElementCount > 0;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isHTMLString = undefined;
  var t = ee2;
  Object.defineProperty(e, "isHTMLString", { enumerable: true, get: function() {
    return t.isHTMLString;
  } });
})(ye2);
var _e2 = {};
var te2 = {};
Object.defineProperty(te2, "__esModule", { value: true });
te2.offset = Jt2;
function Jt2(e) {
  var t = e.getBoundingClientRect(), n = window.pageXOffset || document.documentElement.scrollLeft, r = window.pageYOffset || document.documentElement.scrollTop, i = t.top + r, a2 = t.left + n;
  return {
    top: i,
    left: a2,
    bottom: i + t.height,
    right: a2 + t.width
  };
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.offset = undefined;
  var t = te2;
  Object.defineProperty(e, "offset", { enumerable: true, get: function() {
    return t.offset;
  } });
})(_e2);
var he2 = {};
var ne2 = {};
Object.defineProperty(ne2, "__esModule", { value: true });
ne2.prepend = xt2;
function xt2(e, t) {
  Array.isArray(t) ? (t = t.reverse(), t.forEach(function(n) {
    return e.prepend(n);
  })) : e.prepend(t);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.prepend = undefined;
  var t = ne2;
  Object.defineProperty(e, "prepend", { enumerable: true, get: function() {
    return t.prepend;
  } });
})(he2);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.prepend = e.offset = e.make = e.isLineBreakTag = e.isSingleTag = e.isNodeEmpty = e.isLeaf = e.isHTMLString = e.isFragment = e.isEmpty = e.isElement = e.isContentEditable = e.isCollapsedWhitespaces = e.findAllInputs = e.isNativeInput = e.allInputsSelector = e.getDeepestNode = e.getDeepestBlockElements = e.getContentLength = e.fragmentToString = e.containsOnlyInlineElements = e.canSetCaret = e.calculateBaseline = e.blockElements = e.append = undefined;
  var t = P2;
  Object.defineProperty(e, "allInputsSelector", { enumerable: true, get: function() {
    return t.allInputsSelector;
  } });
  var n = c;
  Object.defineProperty(e, "isNativeInput", { enumerable: true, get: function() {
    return n.isNativeInput;
  } });
  var r = ie;
  Object.defineProperty(e, "append", { enumerable: true, get: function() {
    return r.append;
  } });
  var i = L2;
  Object.defineProperty(e, "blockElements", { enumerable: true, get: function() {
    return i.blockElements;
  } });
  var a2 = ae2;
  Object.defineProperty(e, "calculateBaseline", { enumerable: true, get: function() {
    return a2.calculateBaseline;
  } });
  var l2 = le2;
  Object.defineProperty(e, "canSetCaret", { enumerable: true, get: function() {
    return l2.canSetCaret;
  } });
  var u2 = y2;
  Object.defineProperty(e, "containsOnlyInlineElements", { enumerable: true, get: function() {
    return u2.containsOnlyInlineElements;
  } });
  var d3 = se;
  Object.defineProperty(e, "fragmentToString", { enumerable: true, get: function() {
    return d3.fragmentToString;
  } });
  var s = ce2;
  Object.defineProperty(e, "getContentLength", { enumerable: true, get: function() {
    return s.getContentLength;
  } });
  var f = R2;
  Object.defineProperty(e, "getDeepestBlockElements", { enumerable: true, get: function() {
    return f.getDeepestBlockElements;
  } });
  var Oe2 = fe2;
  Object.defineProperty(e, "getDeepestNode", { enumerable: true, get: function() {
    return Oe2.getDeepestNode;
  } });
  var Pe2 = ve;
  Object.defineProperty(e, "findAllInputs", { enumerable: true, get: function() {
    return Pe2.findAllInputs;
  } });
  var je2 = ge2;
  Object.defineProperty(e, "isCollapsedWhitespaces", { enumerable: true, get: function() {
    return je2.isCollapsedWhitespaces;
  } });
  var Te2 = w;
  Object.defineProperty(e, "isContentEditable", { enumerable: true, get: function() {
    return Te2.isContentEditable;
  } });
  var Ce2 = K2;
  Object.defineProperty(e, "isElement", { enumerable: true, get: function() {
    return Ce2.isElement;
  } });
  var Le2 = me2;
  Object.defineProperty(e, "isEmpty", { enumerable: true, get: function() {
    return Le2.isEmpty;
  } });
  var Se2 = be2;
  Object.defineProperty(e, "isFragment", { enumerable: true, get: function() {
    return Se2.isFragment;
  } });
  var Me2 = ye2;
  Object.defineProperty(e, "isHTMLString", { enumerable: true, get: function() {
    return Me2.isHTMLString;
  } });
  var ke2 = Q;
  Object.defineProperty(e, "isLeaf", { enumerable: true, get: function() {
    return ke2.isLeaf;
  } });
  var we2 = Z2;
  Object.defineProperty(e, "isNodeEmpty", { enumerable: true, get: function() {
    return we2.isNodeEmpty;
  } });
  var Ne2 = h2;
  Object.defineProperty(e, "isLineBreakTag", { enumerable: true, get: function() {
    return Ne2.isLineBreakTag;
  } });
  var Ie2 = E2;
  Object.defineProperty(e, "isSingleTag", { enumerable: true, get: function() {
    return Ie2.isSingleTag;
  } });
  var Ae2 = _2;
  Object.defineProperty(e, "make", { enumerable: true, get: function() {
    return Ae2.make;
  } });
  var $e2 = _e2;
  Object.defineProperty(e, "offset", { enumerable: true, get: function() {
    return $e2.offset;
  } });
  var Be2 = he2;
  Object.defineProperty(e, "prepend", { enumerable: true, get: function() {
    return Be2.prepend;
  } });
})(v2);
var Ee2 = /* @__PURE__ */ ((e) => (e.Left = "left", e.Center = "center", e))(Ee2 || {});

class m {
  constructor({ data: t, config: n, api: r, readOnly: i, block: a2 }) {
    const { DEFAULT_ALIGNMENT: l2 } = m;
    this.api = r, this.readOnly = i, this.quotePlaceholder = r.i18n.t((n == null ? undefined : n.quotePlaceholder) ?? m.DEFAULT_QUOTE_PLACEHOLDER), this.captionPlaceholder = r.i18n.t((n == null ? undefined : n.captionPlaceholder) ?? m.DEFAULT_CAPTION_PLACEHOLDER), this.data = {
      text: t.text || "",
      caption: t.caption || "",
      alignment: Object.values(Ee2).includes(t.alignment) ? t.alignment : (n == null ? undefined : n.defaultAlignment) ?? l2
    }, this.css = {
      baseClass: this.api.styles.block,
      wrapper: "cdx-quote",
      text: "cdx-quote__text",
      input: this.api.styles.input,
      caption: "cdx-quote__caption"
    }, this.block = a2;
  }
  static get isReadOnlySupported() {
    return true;
  }
  static get toolbox() {
    return {
      icon: Re2,
      title: "Quote"
    };
  }
  static get contentless() {
    return true;
  }
  static get enableLineBreaks() {
    return true;
  }
  static get DEFAULT_QUOTE_PLACEHOLDER() {
    return "Enter a quote";
  }
  static get DEFAULT_CAPTION_PLACEHOLDER() {
    return "Enter a caption";
  }
  static get DEFAULT_ALIGNMENT() {
    return "left";
  }
  static get conversionConfig() {
    return {
      import: "text",
      export: function(t) {
        return t.caption ? `${t.text} — ${t.caption}` : t.text;
      }
    };
  }
  get CSS() {
    return {
      baseClass: this.api.styles.block,
      wrapper: "cdx-quote",
      text: "cdx-quote__text",
      input: this.api.styles.input,
      caption: "cdx-quote__caption"
    };
  }
  get settings() {
    return [
      {
        name: "left",
        icon: He2
      },
      {
        name: "center",
        icon: De2
      }
    ];
  }
  render() {
    const t = v2.make("blockquote", [
      this.css.baseClass,
      this.css.wrapper
    ]), n = v2.make("div", [this.css.input, this.css.text], {
      contentEditable: !this.readOnly,
      innerHTML: this.data.text
    }), r = v2.make("div", [this.css.input, this.css.caption], {
      contentEditable: !this.readOnly,
      innerHTML: this.data.caption
    });
    return n.dataset.placeholder = this.quotePlaceholder, r.dataset.placeholder = this.captionPlaceholder, t.appendChild(n), t.appendChild(r), t;
  }
  save(t) {
    const n = t.querySelector(`.${this.css.text}`), r = t.querySelector(`.${this.css.caption}`);
    return Object.assign(this.data, {
      text: (n == null ? undefined : n.innerHTML) ?? "",
      caption: (r == null ? undefined : r.innerHTML) ?? ""
    });
  }
  static get sanitize() {
    return {
      text: {
        br: true
      },
      caption: {
        br: true
      },
      alignment: {}
    };
  }
  renderSettings() {
    const t = (n) => n && n[0].toUpperCase() + n.slice(1);
    return this.settings.map((n) => ({
      icon: n.icon,
      label: this.api.i18n.t(`Align ${t(n.name)}`),
      onActivate: () => this._toggleTune(n.name),
      isActive: this.data.alignment === n.name,
      closeOnActivate: true
    }));
  }
  _toggleTune(t) {
    this.data.alignment = t, this.block.dispatchChange();
  }
}

// node_modules/@editorjs/list/dist/editorjs-list.mjs
(function() {
  try {
    if (typeof document < "u") {
      var e = document.createElement("style");
      e.appendChild(document.createTextNode('.cdx-list{margin:0;padding:0;outline:none;display:grid;counter-reset:item;gap:var(--spacing-s);padding:var(--spacing-xs);--spacing-s: 8px;--spacing-xs: 6px;--list-counter-type: numeric;--radius-border: 5px;--checkbox-background: #fff;--color-border: #C9C9C9;--color-bg-checked: #369FFF;--line-height: 1.45em;--color-bg-checked-hover: #0059AB;--color-tick: #fff;--size-checkbox: 1.2em}.cdx-list__item{line-height:var(--line-height);display:grid;grid-template-columns:auto 1fr;grid-template-rows:auto auto;grid-template-areas:"checkbox content" ". child"}.cdx-list__item-children{display:grid;grid-area:child;gap:var(--spacing-s);padding-top:var(--spacing-s)}.cdx-list__item [contenteditable]{outline:none}.cdx-list__item-content{word-break:break-word;white-space:pre-wrap;grid-area:content;padding-left:var(--spacing-s)}.cdx-list__item:before{counter-increment:item;white-space:nowrap}.cdx-list-ordered .cdx-list__item:before{content:counters(item,".",var(--list-counter-type)) "."}.cdx-list-ordered{counter-reset:item}.cdx-list-unordered .cdx-list__item:before{content:"•"}.cdx-list-checklist .cdx-list__item:before{content:""}.cdx-list__settings .cdx-settings-button{width:50%}.cdx-list__checkbox{padding-top:calc((var(--line-height) - var(--size-checkbox)) / 2);grid-area:checkbox;width:var(--size-checkbox);height:var(--size-checkbox);display:flex;cursor:pointer}.cdx-list__checkbox svg{opacity:0;height:var(--size-checkbox);width:var(--size-checkbox);left:-1px;top:-1px;position:absolute}@media (hover: hover){.cdx-list__checkbox:not(.cdx-list__checkbox--no-hover):hover .cdx-list__checkbox-check svg{opacity:1}}.cdx-list__checkbox--checked{line-height:var(--line-height)}@media (hover: hover){.cdx-list__checkbox--checked:not(.cdx-list__checkbox--checked--no-hover):hover .cdx-checklist__checkbox-check{background:var(--color-bg-checked-hover);border-color:var(--color-bg-checked-hover)}}.cdx-list__checkbox--checked .cdx-list__checkbox-check{background:var(--color-bg-checked);border-color:var(--color-bg-checked)}.cdx-list__checkbox--checked .cdx-list__checkbox-check svg{opacity:1}.cdx-list__checkbox--checked .cdx-list__checkbox-check svg path{stroke:var(--color-tick)}.cdx-list__checkbox--checked .cdx-list__checkbox-check:before{opacity:0;visibility:visible;transform:scale(2.5)}.cdx-list__checkbox-check{cursor:pointer;display:inline-block;position:relative;margin:0 auto;width:var(--size-checkbox);height:var(--size-checkbox);box-sizing:border-box;border-radius:var(--radius-border);border:1px solid var(--color-border);background:var(--checkbox-background)}.cdx-list__checkbox-check:before{content:"";position:absolute;top:0;right:0;bottom:0;left:0;border-radius:100%;background-color:var(--color-bg-checked);visibility:hidden;pointer-events:none;transform:scale(1);transition:transform .4s ease-out,opacity .4s}.cdx-list-start-with-field{background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-list-start-with-field--invalid{background:#FFECED;border:1px solid #E13F3F}.cdx-list-start-with-field--invalid .cdx-list-start-with-field__input{color:#e13f3f}.cdx-list-start-with-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - var(--toolbox-buttons-size) - var(--icon-margin-right))}.cdx-list-start-with-field__input::placeholder{color:var(--grayText);font-weight:500}')), document.head.appendChild(e);
    }
  } catch (c2) {
    console.error("vite-plugin-css-injected-by-js", c2);
  }
})();
var Ct3 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7 12L10.4884 15.8372C10.5677 15.9245 10.705 15.9245 10.7844 15.8372L17 9"/></svg>';
var Ae2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9.2 12L11.0586 13.8586C11.1367 13.9367 11.2633 13.9367 11.3414 13.8586L14.7 10.5"/><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/></svg>';
var $e2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><line x1="9" x2="19" y1="7" y2="7" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="9" x2="19" y1="12" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="9" x2="19" y1="17" y2="17" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5.00001 17H4.99002"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5.00001 12H4.99002"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5.00001 7H4.99002"/></svg>';
var Be2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><line x1="12" x2="19" y1="7" y2="7" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="12" x2="19" y1="12" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="12" x2="19" y1="17" y2="17" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7.79999 14L7.79999 7.2135C7.79999 7.12872 7.7011 7.0824 7.63597 7.13668L4.79999 9.5"/></svg>';
var St3 = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 14.2L10 7.4135C10 7.32872 9.90111 7.28241 9.83598 7.33668L7 9.7" stroke="black" stroke-width="1.6" stroke-linecap="round"/><path d="M13.2087 14.2H13.2" stroke="black" stroke-width="1.6" stroke-linecap="round"/></svg>';
var Ot3 = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13.2087 14.2H13.2" stroke="black" stroke-width="1.6" stroke-linecap="round"/><path d="M10 14.2L10 9.5" stroke="black" stroke-width="1.6" stroke-linecap="round"/><path d="M10 7.01L10 7" stroke="black" stroke-width="1.8" stroke-linecap="round"/></svg>';
var kt3 = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13.2087 14.2H13.2" stroke="black" stroke-width="1.6" stroke-linecap="round"/><path d="M10 14.2L10 7.2" stroke="black" stroke-width="1.6" stroke-linecap="round"/></svg>';
var _t3 = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.0087 14.2H16" stroke="black" stroke-width="1.6" stroke-linecap="round"/><path d="M7 14.2L7.78865 12M13 14.2L12.1377 12M7.78865 12C7.78865 12 9.68362 7 10 7C10.3065 7 12.1377 12 12.1377 12M7.78865 12L12.1377 12" stroke="black" stroke-width="1.6" stroke-linecap="round"/></svg>';
var Et3 = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.2087 14.2H14.2" stroke="black" stroke-width="1.6" stroke-linecap="round"/><path d="M11.5 14.5C11.5 14.5 11 13.281 11 12.5M7 9.5C7 9.5 7.5 8.5 9 8.5C10.5 8.5 11 9.5 11 10.5L11 11.5M11 11.5L11 12.5M11 11.5C11 11.5 7 11 7 13C7 15.3031 11 15 11 12.5" stroke="black" stroke-width="1.6" stroke-linecap="round"/></svg>';
var It3 = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 14.2L8 7.4135C8 7.32872 7.90111 7.28241 7.83598 7.33668L5 9.7" stroke="black" stroke-width="1.6" stroke-linecap="round"/><path d="M14 13L16.4167 10.7778M16.4167 10.7778L14 8.5M16.4167 10.7778H11.6562" stroke="black" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>';
var A3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function wt3(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: true }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: true,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var c2 = {};
var V3 = {};
var Y3 = {};
Object.defineProperty(Y3, "__esModule", { value: true });
Y3.allInputsSelector = Pt3;
function Pt3() {
  var e = ["text", "password", "email", "number", "search", "tel", "url"];
  return "[contenteditable=true], textarea, input:not([type]), " + e.map(function(t) {
    return 'input[type="'.concat(t, '"]');
  }).join(", ");
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.allInputsSelector = undefined;
  var t = Y3;
  Object.defineProperty(e, "allInputsSelector", { enumerable: true, get: function() {
    return t.allInputsSelector;
  } });
})(V3);
var k2 = {};
var J3 = {};
Object.defineProperty(J3, "__esModule", { value: true });
J3.isNativeInput = jt3;
function jt3(e) {
  var t = [
    "INPUT",
    "TEXTAREA"
  ];
  return e && e.tagName ? t.includes(e.tagName) : false;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isNativeInput = undefined;
  var t = J3;
  Object.defineProperty(e, "isNativeInput", { enumerable: true, get: function() {
    return t.isNativeInput;
  } });
})(k2);
var Fe3 = {};
var Q2 = {};
Object.defineProperty(Q2, "__esModule", { value: true });
Q2.append = Tt3;
function Tt3(e, t) {
  Array.isArray(t) ? t.forEach(function(n) {
    e.appendChild(n);
  }) : e.appendChild(t);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.append = undefined;
  var t = Q2;
  Object.defineProperty(e, "append", { enumerable: true, get: function() {
    return t.append;
  } });
})(Fe3);
var Z3 = {};
var x2 = {};
Object.defineProperty(x2, "__esModule", { value: true });
x2.blockElements = Lt3;
function Lt3() {
  return [
    "address",
    "article",
    "aside",
    "blockquote",
    "canvas",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "hr",
    "li",
    "main",
    "nav",
    "noscript",
    "ol",
    "output",
    "p",
    "pre",
    "ruby",
    "section",
    "table",
    "tbody",
    "thead",
    "tr",
    "tfoot",
    "ul",
    "video"
  ];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.blockElements = undefined;
  var t = x2;
  Object.defineProperty(e, "blockElements", { enumerable: true, get: function() {
    return t.blockElements;
  } });
})(Z3);
var Re3 = {};
var ee3 = {};
Object.defineProperty(ee3, "__esModule", { value: true });
ee3.calculateBaseline = Mt3;
function Mt3(e) {
  var t = window.getComputedStyle(e), n = parseFloat(t.fontSize), r = parseFloat(t.lineHeight) || n * 1.2, i = parseFloat(t.paddingTop), a2 = parseFloat(t.borderTopWidth), l2 = parseFloat(t.marginTop), s = n * 0.8, o3 = (r - n) / 2, d3 = l2 + a2 + i + o3 + s;
  return d3;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.calculateBaseline = undefined;
  var t = ee3;
  Object.defineProperty(e, "calculateBaseline", { enumerable: true, get: function() {
    return t.calculateBaseline;
  } });
})(Re3);
var qe3 = {};
var te3 = {};
var ne3 = {};
var re3 = {};
Object.defineProperty(re3, "__esModule", { value: true });
re3.isContentEditable = Nt3;
function Nt3(e) {
  return e.contentEditable === "true";
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isContentEditable = undefined;
  var t = re3;
  Object.defineProperty(e, "isContentEditable", { enumerable: true, get: function() {
    return t.isContentEditable;
  } });
})(ne3);
Object.defineProperty(te3, "__esModule", { value: true });
te3.canSetCaret = Bt3;
var At3 = k2;
var $t3 = ne3;
function Bt3(e) {
  var t = true;
  if ((0, At3.isNativeInput)(e))
    switch (e.type) {
      case "file":
      case "checkbox":
      case "radio":
      case "hidden":
      case "submit":
      case "button":
      case "image":
      case "reset":
        t = false;
        break;
    }
  else
    t = (0, $t3.isContentEditable)(e);
  return t;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.canSetCaret = undefined;
  var t = te3;
  Object.defineProperty(e, "canSetCaret", { enumerable: true, get: function() {
    return t.canSetCaret;
  } });
})(qe3);
var $3 = {};
var ie2 = {};
function Wt3(e, t, n) {
  const r = n.value !== undefined ? "value" : "get", i = n[r], a2 = `#${t}Cache`;
  if (n[r] = function(...l2) {
    return this[a2] === undefined && (this[a2] = i.apply(this, l2)), this[a2];
  }, r === "get" && n.set) {
    const l2 = n.set;
    n.set = function(s) {
      delete e[a2], l2.apply(this, s);
    };
  }
  return n;
}
function Ue3() {
  const e = {
    win: false,
    mac: false,
    x11: false,
    linux: false
  }, t = Object.keys(e).find((n) => window.navigator.appVersion.toLowerCase().indexOf(n) !== -1);
  return t !== undefined && (e[t] = true), e;
}
function ae3(e) {
  return e != null && e !== "" && (typeof e != "object" || Object.keys(e).length > 0);
}
function Dt3(e) {
  return !ae3(e);
}
var Ht3 = () => typeof window < "u" && window.navigator !== null && ae3(window.navigator.platform) && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
function Ft3(e) {
  const t = Ue3();
  return e = e.replace(/shift/gi, "⇧").replace(/backspace/gi, "⌫").replace(/enter/gi, "⏎").replace(/up/gi, "↑").replace(/left/gi, "→").replace(/down/gi, "↓").replace(/right/gi, "←").replace(/escape/gi, "⎋").replace(/insert/gi, "Ins").replace(/delete/gi, "␡").replace(/\+/gi, "+"), t.mac ? e = e.replace(/ctrl|cmd/gi, "⌘").replace(/alt/gi, "⌥") : e = e.replace(/cmd/gi, "Ctrl").replace(/windows/gi, "WIN"), e;
}
function Rt3(e) {
  return e[0].toUpperCase() + e.slice(1);
}
function qt3(e) {
  const t = document.createElement("div");
  t.style.position = "absolute", t.style.left = "-999px", t.style.bottom = "-999px", t.innerHTML = e, document.body.appendChild(t);
  const n = window.getSelection(), r = document.createRange();
  if (r.selectNode(t), n === null)
    throw new Error("Cannot copy text to clipboard");
  n.removeAllRanges(), n.addRange(r), document.execCommand("copy"), document.body.removeChild(t);
}
function Ut3(e, t, n) {
  let r;
  return (...i) => {
    const a2 = this, l2 = () => {
      r = undefined, n !== true && e.apply(a2, i);
    }, s = n === true && r !== undefined;
    window.clearTimeout(r), r = window.setTimeout(l2, t), s && e.apply(a2, i);
  };
}
function S3(e) {
  return Object.prototype.toString.call(e).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
}
function zt3(e) {
  return S3(e) === "boolean";
}
function ze3(e) {
  return S3(e) === "function" || S3(e) === "asyncfunction";
}
function Kt3(e) {
  return ze3(e) && /^\s*class\s+/.test(e.toString());
}
function Xt3(e) {
  return S3(e) === "number";
}
function M2(e) {
  return S3(e) === "object";
}
function Gt3(e) {
  return Promise.resolve(e) === e;
}
function Vt3(e) {
  return S3(e) === "string";
}
function Yt3(e) {
  return S3(e) === "undefined";
}
function X3(e, ...t) {
  if (!t.length)
    return e;
  const n = t.shift();
  if (M2(e) && M2(n))
    for (const r in n)
      M2(n[r]) ? (e[r] === undefined && Object.assign(e, { [r]: {} }), X3(e[r], n[r])) : Object.assign(e, { [r]: n[r] });
  return X3(e, ...t);
}
function Jt3(e, t, n) {
  const r = `«${t}» is deprecated and will be removed in the next major release. Please use the «${n}» instead.`;
  e && console.warn(r);
}
function Qt3(e) {
  try {
    return new URL(e).href;
  } catch {
  }
  return e.substring(0, 2) === "//" ? window.location.protocol + e : window.location.origin + e;
}
function Zt3(e) {
  return e > 47 && e < 58 || e === 32 || e === 13 || e === 229 || e > 64 && e < 91 || e > 95 && e < 112 || e > 185 && e < 193 || e > 218 && e < 223;
}
var xt3 = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  ESC: 27,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  DOWN: 40,
  RIGHT: 39,
  DELETE: 46,
  META: 91,
  SLASH: 191
};
var en2 = {
  LEFT: 0,
  WHEEL: 1,
  RIGHT: 2,
  BACKWARD: 3,
  FORWARD: 4
};

class tn2 {
  constructor() {
    this.completed = Promise.resolve();
  }
  add(t) {
    return new Promise((n, r) => {
      this.completed = this.completed.then(t).then(n).catch(r);
    });
  }
}
function nn2(e, t, n = undefined) {
  let r, i, a2, l2 = null, s = 0;
  n || (n = {});
  const o3 = function() {
    s = n.leading === false ? 0 : Date.now(), l2 = null, a2 = e.apply(r, i), l2 === null && (r = i = null);
  };
  return function() {
    const d3 = Date.now();
    !s && n.leading === false && (s = d3);
    const u2 = t - (d3 - s);
    return r = this, i = arguments, u2 <= 0 || u2 > t ? (l2 && (clearTimeout(l2), l2 = null), s = d3, a2 = e.apply(r, i), l2 === null && (r = i = null)) : !l2 && n.trailing !== false && (l2 = setTimeout(o3, u2)), a2;
  };
}
var rn2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PromiseQueue: tn2,
  beautifyShortcut: Ft3,
  cacheable: Wt3,
  capitalize: Rt3,
  copyTextToClipboard: qt3,
  debounce: Ut3,
  deepMerge: X3,
  deprecationAssert: Jt3,
  getUserOS: Ue3,
  getValidUrl: Qt3,
  isBoolean: zt3,
  isClass: Kt3,
  isEmpty: Dt3,
  isFunction: ze3,
  isIosDevice: Ht3,
  isNumber: Xt3,
  isObject: M2,
  isPrintableKey: Zt3,
  isPromise: Gt3,
  isString: Vt3,
  isUndefined: Yt3,
  keyCodes: xt3,
  mouseButtons: en2,
  notEmpty: ae3,
  throttle: nn2,
  typeOf: S3
}, Symbol.toStringTag, { value: "Module" }));
var le3 = /* @__PURE__ */ wt3(rn2);
Object.defineProperty(ie2, "__esModule", { value: true });
ie2.containsOnlyInlineElements = sn2;
var an2 = le3;
var ln2 = Z3;
function sn2(e) {
  var t;
  (0, an2.isString)(e) ? (t = document.createElement("div"), t.innerHTML = e) : t = e;
  var n = function(r) {
    return !(0, ln2.blockElements)().includes(r.tagName.toLowerCase()) && Array.from(r.children).every(n);
  };
  return Array.from(t.children).every(n);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.containsOnlyInlineElements = undefined;
  var t = ie2;
  Object.defineProperty(e, "containsOnlyInlineElements", { enumerable: true, get: function() {
    return t.containsOnlyInlineElements;
  } });
})($3);
var Ke3 = {};
var se2 = {};
var B2 = {};
var oe3 = {};
Object.defineProperty(oe3, "__esModule", { value: true });
oe3.make = on2;
function on2(e, t, n) {
  var r;
  t === undefined && (t = null), n === undefined && (n = {});
  var i = document.createElement(e);
  if (Array.isArray(t)) {
    var a2 = t.filter(function(s) {
      return s !== undefined;
    });
    (r = i.classList).add.apply(r, a2);
  } else
    t !== null && i.classList.add(t);
  for (var l2 in n)
    Object.prototype.hasOwnProperty.call(n, l2) && (i[l2] = n[l2]);
  return i;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.make = undefined;
  var t = oe3;
  Object.defineProperty(e, "make", { enumerable: true, get: function() {
    return t.make;
  } });
})(B2);
Object.defineProperty(se2, "__esModule", { value: true });
se2.fragmentToString = cn2;
var un2 = B2;
function cn2(e) {
  var t = (0, un2.make)("div");
  return t.appendChild(e), t.innerHTML;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.fragmentToString = undefined;
  var t = se2;
  Object.defineProperty(e, "fragmentToString", { enumerable: true, get: function() {
    return t.fragmentToString;
  } });
})(Ke3);
var Xe3 = {};
var ue3 = {};
Object.defineProperty(ue3, "__esModule", { value: true });
ue3.getContentLength = fn2;
var dn2 = k2;
function fn2(e) {
  var t, n;
  return (0, dn2.isNativeInput)(e) ? e.value.length : e.nodeType === Node.TEXT_NODE ? e.length : (n = (t = e.textContent) === null || t === undefined ? undefined : t.length) !== null && n !== undefined ? n : 0;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.getContentLength = undefined;
  var t = ue3;
  Object.defineProperty(e, "getContentLength", { enumerable: true, get: function() {
    return t.getContentLength;
  } });
})(Xe3);
var ce3 = {};
var de3 = {};
var We3 = A3 && A3.__spreadArray || function(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = t.length, a2;r < i; r++)
      (a2 || !(r in t)) && (a2 || (a2 = Array.prototype.slice.call(t, 0, r)), a2[r] = t[r]);
  return e.concat(a2 || Array.prototype.slice.call(t));
};
Object.defineProperty(de3, "__esModule", { value: true });
de3.getDeepestBlockElements = Ge3;
var pn2 = $3;
function Ge3(e) {
  return (0, pn2.containsOnlyInlineElements)(e) ? [e] : Array.from(e.children).reduce(function(t, n) {
    return We3(We3([], t, true), Ge3(n), true);
  }, []);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.getDeepestBlockElements = undefined;
  var t = de3;
  Object.defineProperty(e, "getDeepestBlockElements", { enumerable: true, get: function() {
    return t.getDeepestBlockElements;
  } });
})(ce3);
var Ve3 = {};
var fe3 = {};
var W2 = {};
var pe3 = {};
Object.defineProperty(pe3, "__esModule", { value: true });
pe3.isLineBreakTag = mn2;
function mn2(e) {
  return [
    "BR",
    "WBR"
  ].includes(e.tagName);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isLineBreakTag = undefined;
  var t = pe3;
  Object.defineProperty(e, "isLineBreakTag", { enumerable: true, get: function() {
    return t.isLineBreakTag;
  } });
})(W2);
var D3 = {};
var me3 = {};
Object.defineProperty(me3, "__esModule", { value: true });
me3.isSingleTag = hn2;
function hn2(e) {
  return [
    "AREA",
    "BASE",
    "BR",
    "COL",
    "COMMAND",
    "EMBED",
    "HR",
    "IMG",
    "INPUT",
    "KEYGEN",
    "LINK",
    "META",
    "PARAM",
    "SOURCE",
    "TRACK",
    "WBR"
  ].includes(e.tagName);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isSingleTag = undefined;
  var t = me3;
  Object.defineProperty(e, "isSingleTag", { enumerable: true, get: function() {
    return t.isSingleTag;
  } });
})(D3);
Object.defineProperty(fe3, "__esModule", { value: true });
fe3.getDeepestNode = Ye3;
var gn2 = k2;
var vn2 = W2;
var bn2 = D3;
function Ye3(e, t) {
  t === undefined && (t = false);
  var n = t ? "lastChild" : "firstChild", r = t ? "previousSibling" : "nextSibling";
  if (e.nodeType === Node.ELEMENT_NODE && e[n]) {
    var i = e[n];
    if ((0, bn2.isSingleTag)(i) && !(0, gn2.isNativeInput)(i) && !(0, vn2.isLineBreakTag)(i))
      if (i[r])
        i = i[r];
      else if (i.parentNode !== null && i.parentNode[r])
        i = i.parentNode[r];
      else
        return i.parentNode;
    return Ye3(i, t);
  }
  return e;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.getDeepestNode = undefined;
  var t = fe3;
  Object.defineProperty(e, "getDeepestNode", { enumerable: true, get: function() {
    return t.getDeepestNode;
  } });
})(Ve3);
var Je3 = {};
var he3 = {};
var j3 = A3 && A3.__spreadArray || function(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = t.length, a2;r < i; r++)
      (a2 || !(r in t)) && (a2 || (a2 = Array.prototype.slice.call(t, 0, r)), a2[r] = t[r]);
  return e.concat(a2 || Array.prototype.slice.call(t));
};
Object.defineProperty(he3, "__esModule", { value: true });
he3.findAllInputs = kn2;
var yn2 = $3;
var Cn2 = ce3;
var Sn2 = V3;
var On2 = k2;
function kn2(e) {
  return Array.from(e.querySelectorAll((0, Sn2.allInputsSelector)())).reduce(function(t, n) {
    return (0, On2.isNativeInput)(n) || (0, yn2.containsOnlyInlineElements)(n) ? j3(j3([], t, true), [n], false) : j3(j3([], t, true), (0, Cn2.getDeepestBlockElements)(n), true);
  }, []);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.findAllInputs = undefined;
  var t = he3;
  Object.defineProperty(e, "findAllInputs", { enumerable: true, get: function() {
    return t.findAllInputs;
  } });
})(Je3);
var Qe3 = {};
var ge3 = {};
Object.defineProperty(ge3, "__esModule", { value: true });
ge3.isCollapsedWhitespaces = _n2;
function _n2(e) {
  return !/[^\t\n\r ]/.test(e);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isCollapsedWhitespaces = undefined;
  var t = ge3;
  Object.defineProperty(e, "isCollapsedWhitespaces", { enumerable: true, get: function() {
    return t.isCollapsedWhitespaces;
  } });
})(Qe3);
var ve2 = {};
var be3 = {};
Object.defineProperty(be3, "__esModule", { value: true });
be3.isElement = In2;
var En2 = le3;
function In2(e) {
  return (0, En2.isNumber)(e) ? false : !!e && !!e.nodeType && e.nodeType === Node.ELEMENT_NODE;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isElement = undefined;
  var t = be3;
  Object.defineProperty(e, "isElement", { enumerable: true, get: function() {
    return t.isElement;
  } });
})(ve2);
var Ze3 = {};
var ye3 = {};
var Ce2 = {};
var Se2 = {};
Object.defineProperty(Se2, "__esModule", { value: true });
Se2.isLeaf = wn2;
function wn2(e) {
  return e === null ? false : e.childNodes.length === 0;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isLeaf = undefined;
  var t = Se2;
  Object.defineProperty(e, "isLeaf", { enumerable: true, get: function() {
    return t.isLeaf;
  } });
})(Ce2);
var Oe2 = {};
var ke2 = {};
Object.defineProperty(ke2, "__esModule", { value: true });
ke2.isNodeEmpty = Mn2;
var Pn2 = W2;
var jn2 = ve2;
var Tn2 = k2;
var Ln2 = D3;
function Mn2(e, t) {
  var n = "";
  return (0, Ln2.isSingleTag)(e) && !(0, Pn2.isLineBreakTag)(e) ? false : ((0, jn2.isElement)(e) && (0, Tn2.isNativeInput)(e) ? n = e.value : e.textContent !== null && (n = e.textContent.replace("​", "")), t !== undefined && (n = n.replace(new RegExp(t, "g"), "")), n.trim().length === 0);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isNodeEmpty = undefined;
  var t = ke2;
  Object.defineProperty(e, "isNodeEmpty", { enumerable: true, get: function() {
    return t.isNodeEmpty;
  } });
})(Oe2);
Object.defineProperty(ye3, "__esModule", { value: true });
ye3.isEmpty = $n2;
var Nn2 = Ce2;
var An2 = Oe2;
function $n2(e, t) {
  e.normalize();
  for (var n = [e];n.length > 0; ) {
    var r = n.shift();
    if (r) {
      if (e = r, (0, Nn2.isLeaf)(e) && !(0, An2.isNodeEmpty)(e, t))
        return false;
      n.push.apply(n, Array.from(e.childNodes));
    }
  }
  return true;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isEmpty = undefined;
  var t = ye3;
  Object.defineProperty(e, "isEmpty", { enumerable: true, get: function() {
    return t.isEmpty;
  } });
})(Ze3);
var xe3 = {};
var _e3 = {};
Object.defineProperty(_e3, "__esModule", { value: true });
_e3.isFragment = Wn2;
var Bn2 = le3;
function Wn2(e) {
  return (0, Bn2.isNumber)(e) ? false : !!e && !!e.nodeType && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isFragment = undefined;
  var t = _e3;
  Object.defineProperty(e, "isFragment", { enumerable: true, get: function() {
    return t.isFragment;
  } });
})(xe3);
var et3 = {};
var Ee3 = {};
Object.defineProperty(Ee3, "__esModule", { value: true });
Ee3.isHTMLString = Hn2;
var Dn2 = B2;
function Hn2(e) {
  var t = (0, Dn2.make)("div");
  return t.innerHTML = e, t.childElementCount > 0;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isHTMLString = undefined;
  var t = Ee3;
  Object.defineProperty(e, "isHTMLString", { enumerable: true, get: function() {
    return t.isHTMLString;
  } });
})(et3);
var tt2 = {};
var Ie2 = {};
Object.defineProperty(Ie2, "__esModule", { value: true });
Ie2.offset = Fn2;
function Fn2(e) {
  var t = e.getBoundingClientRect(), n = window.pageXOffset || document.documentElement.scrollLeft, r = window.pageYOffset || document.documentElement.scrollTop, i = t.top + r, a2 = t.left + n;
  return {
    top: i,
    left: a2,
    bottom: i + t.height,
    right: a2 + t.width
  };
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.offset = undefined;
  var t = Ie2;
  Object.defineProperty(e, "offset", { enumerable: true, get: function() {
    return t.offset;
  } });
})(tt2);
var nt3 = {};
var we2 = {};
Object.defineProperty(we2, "__esModule", { value: true });
we2.prepend = Rn2;
function Rn2(e, t) {
  Array.isArray(t) ? (t = t.reverse(), t.forEach(function(n) {
    return e.prepend(n);
  })) : e.prepend(t);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.prepend = undefined;
  var t = we2;
  Object.defineProperty(e, "prepend", { enumerable: true, get: function() {
    return t.prepend;
  } });
})(nt3);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.prepend = e.offset = e.make = e.isLineBreakTag = e.isSingleTag = e.isNodeEmpty = e.isLeaf = e.isHTMLString = e.isFragment = e.isEmpty = e.isElement = e.isContentEditable = e.isCollapsedWhitespaces = e.findAllInputs = e.isNativeInput = e.allInputsSelector = e.getDeepestNode = e.getDeepestBlockElements = e.getContentLength = e.fragmentToString = e.containsOnlyInlineElements = e.canSetCaret = e.calculateBaseline = e.blockElements = e.append = undefined;
  var t = V3;
  Object.defineProperty(e, "allInputsSelector", { enumerable: true, get: function() {
    return t.allInputsSelector;
  } });
  var n = k2;
  Object.defineProperty(e, "isNativeInput", { enumerable: true, get: function() {
    return n.isNativeInput;
  } });
  var r = Fe3;
  Object.defineProperty(e, "append", { enumerable: true, get: function() {
    return r.append;
  } });
  var i = Z3;
  Object.defineProperty(e, "blockElements", { enumerable: true, get: function() {
    return i.blockElements;
  } });
  var a2 = Re3;
  Object.defineProperty(e, "calculateBaseline", { enumerable: true, get: function() {
    return a2.calculateBaseline;
  } });
  var l2 = qe3;
  Object.defineProperty(e, "canSetCaret", { enumerable: true, get: function() {
    return l2.canSetCaret;
  } });
  var s = $3;
  Object.defineProperty(e, "containsOnlyInlineElements", { enumerable: true, get: function() {
    return s.containsOnlyInlineElements;
  } });
  var o3 = Ke3;
  Object.defineProperty(e, "fragmentToString", { enumerable: true, get: function() {
    return o3.fragmentToString;
  } });
  var d3 = Xe3;
  Object.defineProperty(e, "getContentLength", { enumerable: true, get: function() {
    return d3.getContentLength;
  } });
  var u2 = ce3;
  Object.defineProperty(e, "getDeepestBlockElements", { enumerable: true, get: function() {
    return u2.getDeepestBlockElements;
  } });
  var p2 = Ve3;
  Object.defineProperty(e, "getDeepestNode", { enumerable: true, get: function() {
    return p2.getDeepestNode;
  } });
  var g3 = Je3;
  Object.defineProperty(e, "findAllInputs", { enumerable: true, get: function() {
    return g3.findAllInputs;
  } });
  var w2 = Qe3;
  Object.defineProperty(e, "isCollapsedWhitespaces", { enumerable: true, get: function() {
    return w2.isCollapsedWhitespaces;
  } });
  var _3 = ne3;
  Object.defineProperty(e, "isContentEditable", { enumerable: true, get: function() {
    return _3.isContentEditable;
  } });
  var ut3 = ve2;
  Object.defineProperty(e, "isElement", { enumerable: true, get: function() {
    return ut3.isElement;
  } });
  var ct3 = Ze3;
  Object.defineProperty(e, "isEmpty", { enumerable: true, get: function() {
    return ct3.isEmpty;
  } });
  var dt3 = xe3;
  Object.defineProperty(e, "isFragment", { enumerable: true, get: function() {
    return dt3.isFragment;
  } });
  var ft3 = et3;
  Object.defineProperty(e, "isHTMLString", { enumerable: true, get: function() {
    return ft3.isHTMLString;
  } });
  var pt3 = Ce2;
  Object.defineProperty(e, "isLeaf", { enumerable: true, get: function() {
    return pt3.isLeaf;
  } });
  var mt3 = Oe2;
  Object.defineProperty(e, "isNodeEmpty", { enumerable: true, get: function() {
    return mt3.isNodeEmpty;
  } });
  var ht3 = W2;
  Object.defineProperty(e, "isLineBreakTag", { enumerable: true, get: function() {
    return ht3.isLineBreakTag;
  } });
  var gt3 = D3;
  Object.defineProperty(e, "isSingleTag", { enumerable: true, get: function() {
    return gt3.isSingleTag;
  } });
  var vt3 = B2;
  Object.defineProperty(e, "make", { enumerable: true, get: function() {
    return vt3.make;
  } });
  var bt3 = tt2;
  Object.defineProperty(e, "offset", { enumerable: true, get: function() {
    return bt3.offset;
  } });
  var yt3 = nt3;
  Object.defineProperty(e, "prepend", { enumerable: true, get: function() {
    return yt3.prepend;
  } });
})(c2);
var h3 = "cdx-list";
var m2 = {
  wrapper: h3,
  item: `${h3}__item`,
  itemContent: `${h3}__item-content`,
  itemChildren: `${h3}__item-children`
};

class v3 {
  static get CSS() {
    return {
      ...m2,
      orderedList: `${h3}-ordered`
    };
  }
  constructor(t, n) {
    this.config = n, this.readOnly = t;
  }
  renderWrapper(t) {
    let n;
    return t === true ? n = c2.make("ol", [v3.CSS.wrapper, v3.CSS.orderedList]) : n = c2.make("ol", [v3.CSS.orderedList, v3.CSS.itemChildren]), n;
  }
  renderItem(t, n) {
    const r = c2.make("li", v3.CSS.item), i = c2.make("div", v3.CSS.itemContent, {
      innerHTML: t,
      contentEditable: (!this.readOnly).toString()
    });
    return r.appendChild(i), r;
  }
  getItemContent(t) {
    const n = t.querySelector(`.${v3.CSS.itemContent}`);
    return !n || c2.isEmpty(n) ? "" : n.innerHTML;
  }
  getItemMeta() {
    return {};
  }
  composeDefaultMeta() {
    return {};
  }
}

class b3 {
  static get CSS() {
    return {
      ...m2,
      unorderedList: `${h3}-unordered`
    };
  }
  constructor(t, n) {
    this.config = n, this.readOnly = t;
  }
  renderWrapper(t) {
    let n;
    return t === true ? n = c2.make("ul", [b3.CSS.wrapper, b3.CSS.unorderedList]) : n = c2.make("ul", [b3.CSS.unorderedList, b3.CSS.itemChildren]), n;
  }
  renderItem(t, n) {
    const r = c2.make("li", b3.CSS.item), i = c2.make("div", b3.CSS.itemContent, {
      innerHTML: t,
      contentEditable: (!this.readOnly).toString()
    });
    return r.appendChild(i), r;
  }
  getItemContent(t) {
    const n = t.querySelector(`.${b3.CSS.itemContent}`);
    return !n || c2.isEmpty(n) ? "" : n.innerHTML;
  }
  getItemMeta() {
    return {};
  }
  composeDefaultMeta() {
    return {};
  }
}
function O2(e) {
  return e.nodeType === Node.ELEMENT_NODE;
}
var P3 = {};
var Pe2 = {};
var H2 = {};
var F2 = {};
Object.defineProperty(F2, "__esModule", { value: true });
F2.getContenteditableSlice = Un2;
var qn2 = c2;
function Un2(e, t, n, r, i) {
  var a2;
  i === undefined && (i = false);
  var l2 = document.createRange();
  if (r === "left" ? (l2.setStart(e, 0), l2.setEnd(t, n)) : (l2.setStart(t, n), l2.setEnd(e, e.childNodes.length)), i === true) {
    var s = l2.extractContents();
    return (0, qn2.fragmentToString)(s);
  }
  var o3 = l2.cloneContents(), d3 = document.createElement("div");
  d3.appendChild(o3);
  var u2 = (a2 = d3.textContent) !== null && a2 !== undefined ? a2 : "";
  return u2;
}
Object.defineProperty(H2, "__esModule", { value: true });
H2.checkContenteditableSliceForEmptiness = Xn2;
var zn2 = c2;
var Kn = F2;
function Xn2(e, t, n, r) {
  var i = (0, Kn.getContenteditableSlice)(e, t, n, r);
  return (0, zn2.isCollapsedWhitespaces)(i);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.checkContenteditableSliceForEmptiness = undefined;
  var t = H2;
  Object.defineProperty(e, "checkContenteditableSliceForEmptiness", { enumerable: true, get: function() {
    return t.checkContenteditableSliceForEmptiness;
  } });
})(Pe2);
var rt3 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.getContenteditableSlice = undefined;
  var t = F2;
  Object.defineProperty(e, "getContenteditableSlice", { enumerable: true, get: function() {
    return t.getContenteditableSlice;
  } });
})(rt3);
var it3 = {};
var je2 = {};
Object.defineProperty(je2, "__esModule", { value: true });
je2.focus = Vn2;
var Gn2 = c2;
function Vn2(e, t) {
  var n, r;
  if (t === undefined && (t = true), (0, Gn2.isNativeInput)(e)) {
    e.focus();
    var i = t ? 0 : e.value.length;
    e.setSelectionRange(i, i);
  } else {
    var a2 = document.createRange(), l2 = window.getSelection();
    if (!l2)
      return;
    var s = function(g3, w2) {
      w2 === undefined && (w2 = false);
      var _3 = document.createTextNode("");
      w2 ? g3.insertBefore(_3, g3.firstChild) : g3.appendChild(_3), a2.setStart(_3, 0), a2.setEnd(_3, 0);
    }, o3 = function(g3) {
      return g3 != null;
    }, d3 = e.childNodes, u2 = t ? d3[0] : d3[d3.length - 1];
    if (o3(u2)) {
      for (;o3(u2) && u2.nodeType !== Node.TEXT_NODE; )
        u2 = t ? u2.firstChild : u2.lastChild;
      if (o3(u2) && u2.nodeType === Node.TEXT_NODE) {
        var p2 = (r = (n = u2.textContent) === null || n === undefined ? undefined : n.length) !== null && r !== undefined ? r : 0, i = t ? 0 : p2;
        a2.setStart(u2, i), a2.setEnd(u2, i);
      } else
        s(e, t);
    } else
      s(e);
    l2.removeAllRanges(), l2.addRange(a2);
  }
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.focus = undefined;
  var t = je2;
  Object.defineProperty(e, "focus", { enumerable: true, get: function() {
    return t.focus;
  } });
})(it3);
var Te2 = {};
var R3 = {};
Object.defineProperty(R3, "__esModule", { value: true });
R3.getCaretNodeAndOffset = Yn;
function Yn() {
  var e = window.getSelection();
  if (e === null)
    return [null, 0];
  var { focusNode: t, focusOffset: n } = e;
  return t === null ? [null, 0] : (t.nodeType !== Node.TEXT_NODE && t.childNodes.length > 0 && (t.childNodes[n] !== undefined ? (t = t.childNodes[n], n = 0) : (t = t.childNodes[n - 1], t.textContent !== null && (n = t.textContent.length))), [t, n]);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.getCaretNodeAndOffset = undefined;
  var t = R3;
  Object.defineProperty(e, "getCaretNodeAndOffset", { enumerable: true, get: function() {
    return t.getCaretNodeAndOffset;
  } });
})(Te2);
var at3 = {};
var q2 = {};
Object.defineProperty(q2, "__esModule", { value: true });
q2.getRange = Jn2;
function Jn2() {
  var e = window.getSelection();
  return e && e.rangeCount ? e.getRangeAt(0) : null;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.getRange = undefined;
  var t = q2;
  Object.defineProperty(e, "getRange", { enumerable: true, get: function() {
    return t.getRange;
  } });
})(at3);
var lt3 = {};
var Le2 = {};
Object.defineProperty(Le2, "__esModule", { value: true });
Le2.isCaretAtEndOfInput = xn2;
var De3 = c2;
var Qn2 = Te2;
var Zn2 = Pe2;
function xn2(e) {
  var t = (0, De3.getDeepestNode)(e, true);
  if (t === null)
    return true;
  if ((0, De3.isNativeInput)(t))
    return t.selectionEnd === t.value.length;
  var n = (0, Qn2.getCaretNodeAndOffset)(), r = n[0], i = n[1];
  return r === null ? false : (0, Zn2.checkContenteditableSliceForEmptiness)(e, r, i, "right");
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isCaretAtEndOfInput = undefined;
  var t = Le2;
  Object.defineProperty(e, "isCaretAtEndOfInput", { enumerable: true, get: function() {
    return t.isCaretAtEndOfInput;
  } });
})(lt3);
var st3 = {};
var Me2 = {};
Object.defineProperty(Me2, "__esModule", { value: true });
Me2.isCaretAtStartOfInput = nr2;
var T2 = c2;
var er2 = R3;
var tr2 = H2;
function nr2(e) {
  var t = (0, T2.getDeepestNode)(e);
  if (t === null || (0, T2.isEmpty)(e))
    return true;
  if ((0, T2.isNativeInput)(t))
    return t.selectionEnd === 0;
  if ((0, T2.isEmpty)(e))
    return true;
  var n = (0, er2.getCaretNodeAndOffset)(), r = n[0], i = n[1];
  return r === null ? false : (0, tr2.checkContenteditableSliceForEmptiness)(e, r, i, "left");
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.isCaretAtStartOfInput = undefined;
  var t = Me2;
  Object.defineProperty(e, "isCaretAtStartOfInput", { enumerable: true, get: function() {
    return t.isCaretAtStartOfInput;
  } });
})(st3);
var ot3 = {};
var Ne2 = {};
Object.defineProperty(Ne2, "__esModule", { value: true });
Ne2.save = ar2;
var rr2 = c2;
var ir2 = q2;
function ar2() {
  var e = (0, ir2.getRange)(), t = (0, rr2.make)("span");
  if (t.id = "cursor", t.hidden = true, !!e)
    return e.insertNode(t), function() {
      var r = window.getSelection();
      r && (e.setStartAfter(t), e.setEndAfter(t), r.removeAllRanges(), r.addRange(e), setTimeout(function() {
        t.remove();
      }, 150));
    };
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.save = undefined;
  var t = Ne2;
  Object.defineProperty(e, "save", { enumerable: true, get: function() {
    return t.save;
  } });
})(ot3);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.save = e.isCaretAtStartOfInput = e.isCaretAtEndOfInput = e.getRange = e.getCaretNodeAndOffset = e.focus = e.getContenteditableSlice = e.checkContenteditableSliceForEmptiness = undefined;
  var t = Pe2;
  Object.defineProperty(e, "checkContenteditableSliceForEmptiness", { enumerable: true, get: function() {
    return t.checkContenteditableSliceForEmptiness;
  } });
  var n = rt3;
  Object.defineProperty(e, "getContenteditableSlice", { enumerable: true, get: function() {
    return n.getContenteditableSlice;
  } });
  var r = it3;
  Object.defineProperty(e, "focus", { enumerable: true, get: function() {
    return r.focus;
  } });
  var i = Te2;
  Object.defineProperty(e, "getCaretNodeAndOffset", { enumerable: true, get: function() {
    return i.getCaretNodeAndOffset;
  } });
  var a2 = at3;
  Object.defineProperty(e, "getRange", { enumerable: true, get: function() {
    return a2.getRange;
  } });
  var l2 = lt3;
  Object.defineProperty(e, "isCaretAtEndOfInput", { enumerable: true, get: function() {
    return l2.isCaretAtEndOfInput;
  } });
  var s = st3;
  Object.defineProperty(e, "isCaretAtStartOfInput", { enumerable: true, get: function() {
    return s.isCaretAtStartOfInput;
  } });
  var o3 = ot3;
  Object.defineProperty(e, "save", { enumerable: true, get: function() {
    return o3.save;
  } });
})(P3);

class f {
  static get CSS() {
    return {
      ...m2,
      checklist: `${h3}-checklist`,
      itemChecked: `${h3}__checkbox--checked`,
      noHover: `${h3}__checkbox--no-hover`,
      checkbox: `${h3}__checkbox-check`,
      checkboxContainer: `${h3}__checkbox`
    };
  }
  constructor(t, n) {
    this.config = n, this.readOnly = t;
  }
  renderWrapper(t) {
    let n;
    return t === true ? (n = c2.make("ul", [f.CSS.wrapper, f.CSS.checklist]), n.addEventListener("click", (r) => {
      const i = r.target;
      if (i) {
        const a2 = i.closest(`.${f.CSS.checkboxContainer}`);
        a2 && a2.contains(i) && this.toggleCheckbox(a2);
      }
    })) : n = c2.make("ul", [f.CSS.checklist, f.CSS.itemChildren]), n;
  }
  renderItem(t, n) {
    const r = c2.make("li", [f.CSS.item, f.CSS.item]), i = c2.make("div", f.CSS.itemContent, {
      innerHTML: t,
      contentEditable: (!this.readOnly).toString()
    }), a2 = c2.make("span", f.CSS.checkbox), l2 = c2.make("div", f.CSS.checkboxContainer);
    return n.checked === true && l2.classList.add(f.CSS.itemChecked), a2.innerHTML = Ct3, l2.appendChild(a2), r.appendChild(l2), r.appendChild(i), r;
  }
  getItemContent(t) {
    const n = t.querySelector(`.${f.CSS.itemContent}`);
    return !n || c2.isEmpty(n) ? "" : n.innerHTML;
  }
  getItemMeta(t) {
    const n = t.querySelector(`.${f.CSS.checkboxContainer}`);
    return {
      checked: n ? n.classList.contains(f.CSS.itemChecked) : false
    };
  }
  composeDefaultMeta() {
    return { checked: false };
  }
  toggleCheckbox(t) {
    t.classList.toggle(f.CSS.itemChecked), t.classList.add(f.CSS.noHover), t.addEventListener("mouseleave", () => this.removeSpecialHoverBehavior(t), { once: true });
  }
  removeSpecialHoverBehavior(t) {
    t.classList.remove(f.CSS.noHover);
  }
}
function U3(e, t = "after") {
  const n = [];
  let r;
  function i(a2) {
    switch (t) {
      case "after":
        return a2.nextElementSibling;
      case "before":
        return a2.previousElementSibling;
    }
  }
  for (r = i(e);r !== null; )
    n.push(r), r = i(r);
  return n.length !== 0 ? n : null;
}
function y3(e, t = true) {
  let n = e;
  return e.classList.contains(m2.item) && (n = e.querySelector(`.${m2.itemChildren}`)), n === null ? [] : t ? Array.from(n.querySelectorAll(`:scope > .${m2.item}`)) : Array.from(n.querySelectorAll(`.${m2.item}`));
}
function lr2(e) {
  return e.nextElementSibling === null;
}
function sr2(e) {
  return e.querySelector(`.${m2.itemChildren}`) !== null;
}
function C2(e) {
  return e.querySelector(`.${m2.itemChildren}`);
}
function z3(e) {
  let t = e;
  e.classList.contains(m2.item) && (t = C2(e)), t !== null && y3(t).length === 0 && t.remove();
}
function N2(e) {
  return e.querySelector(`.${m2.itemContent}`);
}
function E3(e, t = true) {
  const n = N2(e);
  n && P3.focus(n, t);
}

class K3 {
  get currentItem() {
    const t = window.getSelection();
    if (!t)
      return null;
    let n = t.anchorNode;
    return !n || (O2(n) || (n = n.parentNode), !n) || !O2(n) ? null : n.closest(`.${m2.item}`);
  }
  get currentItemLevel() {
    const t = this.currentItem;
    if (t === null)
      return null;
    let n = t.parentNode, r = 0;
    for (;n !== null && n !== this.listWrapper; )
      O2(n) && n.classList.contains(m2.item) && (r += 1), n = n.parentNode;
    return r + 1;
  }
  constructor({ data: t, config: n, api: r, readOnly: i, block: a2 }, l2) {
    this.config = n, this.data = t, this.readOnly = i, this.api = r, this.block = a2, this.renderer = l2;
  }
  render() {
    return this.listWrapper = this.renderer.renderWrapper(true), this.data.items.length ? this.appendItems(this.data.items, this.listWrapper) : this.appendItems([
      {
        content: "",
        meta: {},
        items: []
      }
    ], this.listWrapper), this.readOnly || this.listWrapper.addEventListener("keydown", (t) => {
      switch (t.key) {
        case "Enter":
          this.enterPressed(t);
          break;
        case "Backspace":
          this.backspace(t);
          break;
        case "Tab":
          t.shiftKey ? this.shiftTab(t) : this.addTab(t);
          break;
      }
    }, false), "start" in this.data.meta && this.data.meta.start !== undefined && this.changeStartWith(this.data.meta.start), "counterType" in this.data.meta && this.data.meta.counterType !== undefined && this.changeCounters(this.data.meta.counterType), this.listWrapper;
  }
  save(t) {
    const n = t ?? this.listWrapper, r = (l2) => y3(l2).map((o3) => {
      const d3 = C2(o3), u2 = this.renderer.getItemContent(o3), p2 = this.renderer.getItemMeta(o3), g3 = d3 ? r(d3) : [];
      return {
        content: u2,
        meta: p2,
        items: g3
      };
    }), i = n ? r(n) : [];
    let a2 = {
      style: this.data.style,
      meta: {},
      items: i
    };
    return this.data.style === "ordered" && (a2.meta = {
      start: this.data.meta.start,
      counterType: this.data.meta.counterType
    }), a2;
  }
  static get pasteConfig() {
    return {
      tags: ["OL", "UL", "LI"]
    };
  }
  merge(t) {
    const n = this.block.holder.querySelectorAll(`.${m2.item}`), r = n[n.length - 1], i = N2(r);
    if (r === null || i === null || (i.insertAdjacentHTML("beforeend", t.items[0].content), this.listWrapper === undefined))
      return;
    const a2 = y3(this.listWrapper);
    if (a2.length === 0)
      return;
    const l2 = a2[a2.length - 1];
    let s = C2(l2);
    const o3 = t.items.shift();
    o3 !== undefined && (o3.items.length !== 0 && (s === null && (s = this.renderer.renderWrapper(false)), this.appendItems(o3.items, s)), t.items.length > 0 && this.appendItems(t.items, this.listWrapper));
  }
  onPaste(t) {
    const n = t.detail.data;
    this.data = this.pasteHandler(n);
    const r = this.listWrapper;
    r && r.parentNode && r.parentNode.replaceChild(this.render(), r);
  }
  pasteHandler(t) {
    const { tagName: n } = t;
    let r = "unordered", i;
    switch (n) {
      case "OL":
        r = "ordered", i = "ol";
        break;
      case "UL":
      case "LI":
        r = "unordered", i = "ul";
    }
    const a2 = {
      style: r,
      meta: {},
      items: []
    };
    r === "ordered" && (this.data.meta.counterType = "numeric", this.data.meta.start = 1);
    const l2 = (s) => Array.from(s.querySelectorAll(":scope > li")).map((d3) => {
      const u2 = d3.querySelector(`:scope > ${i}`), p2 = u2 ? l2(u2) : [];
      return {
        content: d3.innerHTML ?? "",
        meta: {},
        items: p2
      };
    });
    return a2.items = l2(t), a2;
  }
  changeStartWith(t) {
    this.listWrapper.style.setProperty("counter-reset", `item ${t - 1}`), this.data.meta.start = t;
  }
  changeCounters(t) {
    this.listWrapper.style.setProperty("--list-counter-type", t), this.data.meta.counterType = t;
  }
  enterPressed(t) {
    var s;
    const n = this.currentItem;
    if (t.stopPropagation(), t.preventDefault(), t.isComposing || n === null)
      return;
    const r = ((s = this.renderer) == null ? undefined : s.getItemContent(n).trim().length) === 0, i = n.parentNode === this.listWrapper, a2 = n.previousElementSibling === null, l2 = this.api.blocks.getCurrentBlockIndex();
    if (i && r)
      if (lr2(n) && !sr2(n)) {
        a2 ? this.convertItemToDefaultBlock(l2, true) : this.convertItemToDefaultBlock();
        return;
      } else {
        this.splitList(n);
        return;
      }
    else if (r) {
      this.unshiftItem(n);
      return;
    } else
      this.splitItem(n);
  }
  backspace(t) {
    var r;
    const n = this.currentItem;
    if (n !== null && P3.isCaretAtStartOfInput(n) && ((r = window.getSelection()) == null ? undefined : r.isCollapsed) !== false) {
      if (t.stopPropagation(), n.parentNode === this.listWrapper && n.previousElementSibling === null) {
        this.convertFirstItemToDefaultBlock();
        return;
      }
      t.preventDefault(), this.mergeItemWithPrevious(n);
    }
  }
  shiftTab(t) {
    t.stopPropagation(), t.preventDefault(), this.currentItem !== null && this.unshiftItem(this.currentItem);
  }
  unshiftItem(t) {
    if (!t.parentNode || !O2(t.parentNode))
      return;
    const n = t.parentNode.closest(`.${m2.item}`);
    if (!n)
      return;
    let r = C2(t);
    if (t.parentElement === null)
      return;
    const i = U3(t);
    i !== null && (r === null && (r = this.renderer.renderWrapper(false)), i.forEach((a2) => {
      r.appendChild(a2);
    }), t.appendChild(r)), n.after(t), E3(t, false), z3(n);
  }
  splitList(t) {
    const n = y3(t), r = this.block, i = this.api.blocks.getCurrentBlockIndex();
    if (n.length !== 0) {
      const o3 = n[0];
      this.unshiftItem(o3), E3(t, false);
    }
    if (t.previousElementSibling === null && t.parentNode === this.listWrapper) {
      this.convertItemToDefaultBlock(i);
      return;
    }
    const a2 = U3(t);
    if (a2 === null)
      return;
    const l2 = this.renderer.renderWrapper(true);
    a2.forEach((o3) => {
      l2.appendChild(o3);
    });
    const s = this.save(l2);
    s.meta.start = this.data.style == "ordered" ? 1 : undefined, this.api.blocks.insert(r == null ? undefined : r.name, s, this.config, i + 1), this.convertItemToDefaultBlock(i + 1), l2.remove();
  }
  splitItem(t) {
    const [n, r] = P3.getCaretNodeAndOffset();
    if (n === null)
      return;
    const i = N2(t);
    let a2;
    i === null ? a2 = "" : a2 = P3.getContenteditableSlice(i, n, r, "right", true);
    const l2 = C2(t), s = this.renderItem(a2);
    t == null || t.after(s), l2 && s.appendChild(l2), E3(s);
  }
  mergeItemWithPrevious(t) {
    const { previousElementSibling: n, parentNode: r } = t;
    if (r === null || !O2(r))
      return;
    const i = r.closest(`.${m2.item}`);
    if (!n && !i || n && !O2(n))
      return;
    let a2;
    if (n) {
      const p2 = y3(n, false);
      p2.length !== 0 && p2.length !== 0 ? a2 = p2[p2.length - 1] : a2 = n;
    } else
      a2 = i;
    const l2 = this.renderer.getItemContent(t);
    if (!a2)
      return;
    E3(a2, false);
    const s = N2(a2);
    if (s === null)
      return;
    s.insertAdjacentHTML("beforeend", l2);
    const o3 = y3(t);
    if (o3.length === 0) {
      t.remove(), z3(a2);
      return;
    }
    const d3 = n || i, u2 = C2(d3) ?? this.renderer.renderWrapper(false);
    n ? o3.forEach((p2) => {
      u2.appendChild(p2);
    }) : o3.forEach((p2) => {
      u2.prepend(p2);
    }), C2(d3) === null && a2.appendChild(u2), t.remove();
  }
  addTab(t) {
    var a2;
    t.stopPropagation(), t.preventDefault();
    const n = this.currentItem;
    if (!n)
      return;
    if (((a2 = this.config) == null ? undefined : a2.maxLevel) !== undefined) {
      const l2 = this.currentItemLevel;
      if (l2 !== null && l2 === this.config.maxLevel)
        return;
    }
    const r = n.previousSibling;
    if (r === null || !O2(r))
      return;
    const i = C2(r);
    if (i)
      i.appendChild(n), y3(n).forEach((s) => {
        i.appendChild(s);
      });
    else {
      const l2 = this.renderer.renderWrapper(false);
      l2.appendChild(n), y3(n).forEach((o3) => {
        l2.appendChild(o3);
      }), r.appendChild(l2);
    }
    z3(n), E3(n, false);
  }
  convertItemToDefaultBlock(t, n) {
    let r;
    const i = this.currentItem, a2 = i !== null ? this.renderer.getItemContent(i) : "";
    n === true && this.api.blocks.delete(), t !== undefined ? r = this.api.blocks.insert(undefined, { text: a2 }, undefined, t) : r = this.api.blocks.insert(), i == null || i.remove(), this.api.caret.setToBlock(r, "start");
  }
  convertFirstItemToDefaultBlock() {
    const t = this.currentItem;
    if (t === null)
      return;
    const n = y3(t);
    if (n.length !== 0) {
      const l2 = n[0];
      this.unshiftItem(l2), E3(t);
    }
    const r = U3(t), i = this.api.blocks.getCurrentBlockIndex(), a2 = r === null;
    this.convertItemToDefaultBlock(i, a2);
  }
  renderItem(t, n) {
    const r = n ?? this.renderer.composeDefaultMeta();
    switch (true) {
      case this.renderer instanceof v3:
        return this.renderer.renderItem(t, r);
      case this.renderer instanceof b3:
        return this.renderer.renderItem(t, r);
      default:
        return this.renderer.renderItem(t, r);
    }
  }
  appendItems(t, n) {
    t.forEach((r) => {
      var a2;
      const i = this.renderItem(r.content, r.meta);
      if (n.appendChild(i), r.items.length) {
        const l2 = (a2 = this.renderer) == null ? undefined : a2.renderWrapper(false);
        this.appendItems(r.items, l2), i.appendChild(l2);
      }
    });
  }
}
var I2 = {
  wrapper: `${h3}-start-with-field`,
  input: `${h3}-start-with-field__input`,
  startWithElementWrapperInvalid: `${h3}-start-with-field--invalid`
};
function or2(e, { value: t, placeholder: n, attributes: r, sanitize: i }) {
  const a2 = c2.make("div", I2.wrapper), l2 = c2.make("input", I2.input, {
    placeholder: n,
    tabIndex: -1,
    value: t
  });
  for (const s in r)
    l2.setAttribute(s, r[s]);
  return a2.appendChild(l2), l2.addEventListener("input", () => {
    i !== undefined && (l2.value = i(l2.value));
    const s = l2.checkValidity();
    !s && !a2.classList.contains(I2.startWithElementWrapperInvalid) && a2.classList.add(I2.startWithElementWrapperInvalid), s && a2.classList.contains(I2.startWithElementWrapperInvalid) && a2.classList.remove(I2.startWithElementWrapperInvalid), s && e(l2.value);
  }), a2;
}
var L3 = /* @__PURE__ */ new Map([
  ["Numeric", "numeric"],
  ["Lower Roman", "lower-roman"],
  ["Upper Roman", "upper-roman"],
  ["Lower Alpha", "lower-alpha"],
  ["Upper Alpha", "upper-alpha"]
]);
var He3 = /* @__PURE__ */ new Map([
  ["numeric", St3],
  ["lower-roman", Ot3],
  ["upper-roman", kt3],
  ["lower-alpha", Et3],
  ["upper-alpha", _t3]
]);
function ur2(e) {
  return e.replace(/\D+/g, "");
}
function cr2(e) {
  return typeof e.items[0] == "string";
}
function dr2(e) {
  return !("meta" in e);
}
function fr2(e) {
  return typeof e.items[0] != "string" && "text" in e.items[0] && "checked" in e.items[0] && typeof e.items[0].text == "string" && typeof e.items[0].checked == "boolean";
}
function pr2(e) {
  const t = [];
  return cr2(e) ? (e.items.forEach((n) => {
    t.push({
      content: n,
      meta: {},
      items: []
    });
  }), {
    style: e.style,
    meta: {},
    items: t
  }) : fr2(e) ? (e.items.forEach((n) => {
    t.push({
      content: n.text,
      meta: {
        checked: n.checked
      },
      items: []
    });
  }), {
    style: "checklist",
    meta: {},
    items: t
  }) : dr2(e) ? {
    style: e.style,
    meta: {},
    items: e.items
  } : e;
}

class G3 {
  static get isReadOnlySupported() {
    return true;
  }
  static get enableLineBreaks() {
    return true;
  }
  static get toolbox() {
    return [
      {
        icon: $e2,
        title: "Unordered List",
        data: {
          style: "unordered"
        }
      },
      {
        icon: Be2,
        title: "Ordered List",
        data: {
          style: "ordered"
        }
      },
      {
        icon: Ae2,
        title: "Checklist",
        data: {
          style: "checklist"
        }
      }
    ];
  }
  static get pasteConfig() {
    return {
      tags: ["OL", "UL", "LI"]
    };
  }
  static get conversionConfig() {
    return {
      export: (t) => G3.joinRecursive(t),
      import: (t, n) => ({
        meta: {},
        items: [
          {
            content: t,
            meta: {},
            items: []
          }
        ],
        style: (n == null ? undefined : n.defaultStyle) !== undefined ? n.defaultStyle : "unordered"
      })
    };
  }
  get listStyle() {
    return this.data.style || this.defaultListStyle;
  }
  set listStyle(t) {
    var r;
    this.data.style = t, this.changeTabulatorByStyle();
    const n = this.list.render();
    (r = this.listElement) == null || r.replaceWith(n), this.listElement = n;
  }
  constructor({ data: t, config: n, api: r, readOnly: i, block: a2 }) {
    var s;
    this.api = r, this.readOnly = i, this.config = n, this.block = a2, this.defaultListStyle = ((s = this.config) == null ? undefined : s.defaultStyle) || "unordered";
    const l2 = {
      style: this.defaultListStyle,
      meta: {},
      items: []
    };
    this.data = Object.keys(t).length ? pr2(t) : l2, this.listStyle === "ordered" && this.data.meta.counterType === undefined && (this.data.meta.counterType = "numeric"), this.changeTabulatorByStyle();
  }
  static joinRecursive(t) {
    return t.items.map((n) => `${n.content} ${G3.joinRecursive(n)}`).join("");
  }
  render() {
    return this.listElement = this.list.render(), this.listElement;
  }
  save() {
    return this.data = this.list.save(), this.data;
  }
  merge(t) {
    this.list.merge(t);
  }
  renderSettings() {
    const t = [
      {
        label: this.api.i18n.t("Unordered"),
        icon: $e2,
        closeOnActivate: true,
        isActive: this.listStyle == "unordered",
        onActivate: () => {
          this.listStyle = "unordered";
        }
      },
      {
        label: this.api.i18n.t("Ordered"),
        icon: Be2,
        closeOnActivate: true,
        isActive: this.listStyle == "ordered",
        onActivate: () => {
          this.listStyle = "ordered";
        }
      },
      {
        label: this.api.i18n.t("Checklist"),
        icon: Ae2,
        closeOnActivate: true,
        isActive: this.listStyle == "checklist",
        onActivate: () => {
          this.listStyle = "checklist";
        }
      }
    ];
    if (this.listStyle === "ordered") {
      const n = or2((a2) => this.changeStartWith(Number(a2)), {
        value: String(this.data.meta.start ?? 1),
        placeholder: "",
        attributes: {
          required: "true"
        },
        sanitize: (a2) => ur2(a2)
      }), r = [
        {
          label: this.api.i18n.t("Start with"),
          icon: It3,
          children: {
            items: [
              {
                element: n,
                type: "html"
              }
            ]
          }
        }
      ], i = {
        label: this.api.i18n.t("Counter type"),
        icon: He3.get(this.data.meta.counterType),
        children: {
          items: []
        }
      };
      L3.forEach((a2, l2) => {
        i.children.items.push({
          title: this.api.i18n.t(l2),
          icon: He3.get(L3.get(l2)),
          isActive: this.data.meta.counterType === L3.get(l2),
          closeOnActivate: true,
          onActivate: () => {
            this.changeCounters(L3.get(l2));
          }
        });
      }), t.push({ type: "separator" }, ...r, i);
    }
    return t;
  }
  onPaste(t) {
    const { tagName: n } = t.detail.data;
    switch (n) {
      case "OL":
        this.listStyle = "ordered";
        break;
      case "UL":
      case "LI":
        this.listStyle = "unordered";
    }
    this.list.onPaste(t);
  }
  pasteHandler(t) {
    return this.list.pasteHandler(t);
  }
  changeCounters(t) {
    var n;
    (n = this.list) == null || n.changeCounters(t), this.data.meta.counterType = t;
  }
  changeStartWith(t) {
    var n;
    (n = this.list) == null || n.changeStartWith(t), this.data.meta.start = t;
  }
  changeTabulatorByStyle() {
    switch (this.listStyle) {
      case "ordered":
        this.list = new K3({
          data: this.data,
          readOnly: this.readOnly,
          api: this.api,
          config: this.config,
          block: this.block
        }, new v3(this.readOnly, this.config));
        break;
      case "unordered":
        this.list = new K3({
          data: this.data,
          readOnly: this.readOnly,
          api: this.api,
          config: this.config,
          block: this.block
        }, new b3(this.readOnly, this.config));
        break;
      case "checklist":
        this.list = new K3({
          data: this.data,
          readOnly: this.readOnly,
          api: this.api,
          config: this.config,
          block: this.block
        }, new f(this.readOnly, this.config));
        break;
    }
  }
}

// client/index.js
var import_editorjs_drag_drop = __toESM(require_bundle(), 1);
var import_editorjs_undo = __toESM(require_bundle2(), 1);

// node_modules/@editorjs/table/dist/table.mjs
(function() {
  var r;
  try {
    if (typeof document < "u") {
      var o3 = document.createElement("style");
      o3.nonce = (r = document.head.querySelector("meta[property=csp-nonce]")) == null ? undefined : r.content, o3.appendChild(document.createTextNode('.tc-wrap{--color-background:#f9f9fb;--color-text-secondary:#7b7e89;--color-border:#e8e8eb;--cell-size:34px;--toolbox-icon-size:18px;--toolbox-padding:6px;--toolbox-aiming-field-size:calc(var(--toolbox-icon-size) + var(--toolbox-padding)*2);border-left:0;position:relative;height:100%;width:100%;margin-top:var(--toolbox-icon-size);box-sizing:border-box;display:grid;grid-template-columns:calc(100% - var(--cell-size)) var(--cell-size)}.tc-wrap--readonly{grid-template-columns:100% var(--cell-size)}.tc-wrap svg{vertical-align:top}@media print{.tc-wrap{border-left-color:var(--color-border);border-left-style:solid;border-left-width:1px;grid-template-columns:100% var(--cell-size)}}@media print{.tc-wrap .tc-row:after{display:none}}.tc-table{position:relative;width:100%;height:100%;display:grid;font-size:14px;border-top:1px solid var(--color-border);line-height:1.4}.tc-table:after{width:calc(var(--cell-size));height:100%;left:calc(var(--cell-size)*-1);top:0}.tc-table:after,.tc-table:before{position:absolute;content:""}.tc-table:before{width:100%;height:var(--toolbox-aiming-field-size);top:calc(var(--toolbox-aiming-field-size)*-1);left:0}.tc-table--heading .tc-row:first-child{font-weight:600;border-bottom:2px solid var(--color-border)}.tc-table--heading .tc-row:first-child [contenteditable]:empty:before{content:attr(heading);color:var(--color-text-secondary)}.tc-table--heading .tc-row:first-child:after{bottom:-2px;border-bottom:2px solid var(--color-border)}.tc-add-column,.tc-add-row{display:flex;color:var(--color-text-secondary)}@media print{.tc-add{display:none}}.tc-add-column{padding:4px 0;justify-content:center;border-top:1px solid var(--color-border)}.tc-add-column--disabled{visibility:hidden}@media print{.tc-add-column{display:none}}.tc-add-row{height:var(--cell-size);align-items:center;padding-left:4px;position:relative}.tc-add-row--disabled{display:none}.tc-add-row:before{content:"";position:absolute;right:calc(var(--cell-size)*-1);width:var(--cell-size);height:100%}@media print{.tc-add-row{display:none}}.tc-add-column,.tc-add-row{transition:0s;cursor:pointer;will-change:background-color}.tc-add-column:hover,.tc-add-row:hover{transition:background-color .1s ease;background-color:var(--color-background)}.tc-add-row{margin-top:1px}.tc-add-row:hover:before{transition:.1s;background-color:var(--color-background)}.tc-row{display:grid;grid-template-columns:repeat(auto-fit,minmax(10px,1fr));position:relative;border-bottom:1px solid var(--color-border)}.tc-row:after{content:"";pointer-events:none;position:absolute;width:var(--cell-size);height:100%;bottom:-1px;right:calc(var(--cell-size)*-1);border-bottom:1px solid var(--color-border)}.tc-row--selected{background:var(--color-background)}.tc-row--selected:after{background:var(--color-background)}.tc-cell{border-right:1px solid var(--color-border);padding:6px 12px;overflow:hidden;outline:none;line-break:normal}.tc-cell--selected{background:var(--color-background)}.tc-wrap--readonly .tc-row:after{display:none}.tc-toolbox{--toolbox-padding:6px;--popover-margin:30px;--toggler-click-zone-size:30px;--toggler-dots-color:#7b7e89;--toggler-dots-color-hovered:#1d202b;position:absolute;cursor:pointer;z-index:1;opacity:0;transition:opacity .1s;will-change:left,opacity}.tc-toolbox--column{top:calc(var(--toggler-click-zone-size)*-1);transform:translate(calc(var(--toggler-click-zone-size)*-1/2));will-change:left,opacity}.tc-toolbox--row{left:calc(var(--popover-margin)*-1);transform:translateY(calc(var(--toggler-click-zone-size)*-1/2));margin-top:-1px;will-change:top,opacity}.tc-toolbox--showed{opacity:1}.tc-toolbox .tc-popover{position:absolute;top:0;left:var(--popover-margin)}.tc-toolbox__toggler{display:flex;align-items:center;justify-content:center;width:var(--toggler-click-zone-size);height:var(--toggler-click-zone-size);color:var(--toggler-dots-color);opacity:0;transition:opacity .15s ease;will-change:opacity}.tc-toolbox__toggler:hover{color:var(--toggler-dots-color-hovered)}.tc-toolbox__toggler svg{fill:currentColor}.tc-wrap:hover .tc-toolbox__toggler{opacity:1}.tc-settings .cdx-settings-button{width:50%;margin:0}.tc-popover{--color-border:#eaeaea;--color-background:#fff;--color-background-hover:rgba(232,232,235,.49);--color-background-confirm:#e24a4a;--color-background-confirm-hover:#d54040;--color-text-confirm:#fff;background:var(--color-background);border:1px solid var(--color-border);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;padding:6px;display:none;will-change:opacity,transform}.tc-popover--opened{display:block;animation:menuShowing .1s cubic-bezier(.215,.61,.355,1) forwards}.tc-popover__item{display:flex;align-items:center;padding:2px 14px 2px 2px;border-radius:5px;cursor:pointer;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;user-select:none}.tc-popover__item:hover{background:var(--color-background-hover)}.tc-popover__item:not(:last-of-type){margin-bottom:2px}.tc-popover__item-icon{display:inline-flex;width:26px;height:26px;align-items:center;justify-content:center;background:var(--color-background);border-radius:5px;border:1px solid var(--color-border);margin-right:8px}.tc-popover__item-label{line-height:22px;font-size:14px;font-weight:500}.tc-popover__item--confirm{background:var(--color-background-confirm);color:var(--color-text-confirm)}.tc-popover__item--confirm:hover{background-color:var(--color-background-confirm-hover)}.tc-popover__item--confirm .tc-popover__item-icon{background:var(--color-background-confirm);border-color:#0000001a}.tc-popover__item--confirm .tc-popover__item-icon svg{transition:transform .2s ease-in;transform:rotate(90deg) scale(1.2)}.tc-popover__item--hidden{display:none}@keyframes menuShowing{0%{opacity:0;transform:translateY(-8px) scale(.9)}70%{opacity:1;transform:translateY(2px)}to{transform:translateY(0)}}')), document.head.appendChild(o3);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
function c3(d3, t, e = {}) {
  const o3 = document.createElement(d3);
  Array.isArray(t) ? o3.classList.add(...t) : t && o3.classList.add(t);
  for (const i in e)
    Object.prototype.hasOwnProperty.call(e, i) && (o3[i] = e[i]);
  return o3;
}
function f2(d3) {
  const t = d3.getBoundingClientRect();
  return {
    y1: Math.floor(t.top + window.pageYOffset),
    x1: Math.floor(t.left + window.pageXOffset),
    x2: Math.floor(t.right + window.pageXOffset),
    y2: Math.floor(t.bottom + window.pageYOffset)
  };
}
function g3(d3, t) {
  const e = f2(d3), o3 = f2(t);
  return {
    fromTopBorder: o3.y1 - e.y1,
    fromLeftBorder: o3.x1 - e.x1,
    fromRightBorder: e.x2 - o3.x2,
    fromBottomBorder: e.y2 - o3.y2
  };
}
function k3(d3, t) {
  const e = d3.getBoundingClientRect(), { width: o3, height: i, x: n, y: r } = e, { clientX: h4, clientY: l2 } = t;
  return {
    width: o3,
    height: i,
    x: h4 - n,
    y: l2 - r
  };
}
function m3(d3, t) {
  return t.parentNode.insertBefore(d3, t);
}
function C3(d3, t = true) {
  const e = document.createRange(), o3 = window.getSelection();
  e.selectNodeContents(d3), e.collapse(t), o3.removeAllRanges(), o3.addRange(e);
}

class a2 {
  constructor({ items: t }) {
    this.items = t, this.wrapper = undefined, this.itemEls = [];
  }
  static get CSS() {
    return {
      popover: "tc-popover",
      popoverOpened: "tc-popover--opened",
      item: "tc-popover__item",
      itemHidden: "tc-popover__item--hidden",
      itemConfirmState: "tc-popover__item--confirm",
      itemIcon: "tc-popover__item-icon",
      itemLabel: "tc-popover__item-label"
    };
  }
  render() {
    return this.wrapper = c3("div", a2.CSS.popover), this.items.forEach((t, e) => {
      const o3 = c3("div", a2.CSS.item), i = c3("div", a2.CSS.itemIcon, {
        innerHTML: t.icon
      }), n = c3("div", a2.CSS.itemLabel, {
        textContent: t.label
      });
      o3.dataset.index = e, o3.appendChild(i), o3.appendChild(n), this.wrapper.appendChild(o3), this.itemEls.push(o3);
    }), this.wrapper.addEventListener("click", (t) => {
      this.popoverClicked(t);
    }), this.wrapper;
  }
  popoverClicked(t) {
    const e = t.target.closest(`.${a2.CSS.item}`);
    if (!e)
      return;
    const o3 = e.dataset.index, i = this.items[o3];
    if (i.confirmationRequired && !this.hasConfirmationState(e)) {
      this.setConfirmationState(e);
      return;
    }
    i.onClick();
  }
  setConfirmationState(t) {
    t.classList.add(a2.CSS.itemConfirmState);
  }
  clearConfirmationState(t) {
    t.classList.remove(a2.CSS.itemConfirmState);
  }
  hasConfirmationState(t) {
    return t.classList.contains(a2.CSS.itemConfirmState);
  }
  get opened() {
    return this.wrapper.classList.contains(a2.CSS.popoverOpened);
  }
  open() {
    this.items.forEach((t, e) => {
      typeof t.hideIf == "function" && this.itemEls[e].classList.toggle(a2.CSS.itemHidden, t.hideIf());
    }), this.wrapper.classList.add(a2.CSS.popoverOpened);
  }
  close() {
    this.wrapper.classList.remove(a2.CSS.popoverOpened), this.itemEls.forEach((t) => {
      this.clearConfirmationState(t);
    });
  }
}
var R4 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 9L10 12M10 12L7 15M10 12H4"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9L14 12M14 12L17 15M14 12H20"/></svg>';
var b4 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16"/></svg>';
var x3 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.8833 9.16666L18.2167 12.5M18.2167 12.5L14.8833 15.8333M18.2167 12.5H10.05C9.16594 12.5 8.31809 12.1488 7.69297 11.5237C7.06785 10.8986 6.71666 10.0507 6.71666 9.16666"/></svg>';
var S4 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.9167 14.9167L11.5833 18.25M11.5833 18.25L8.25 14.9167M11.5833 18.25L11.5833 10.0833C11.5833 9.19928 11.9345 8.35143 12.5596 7.72631C13.1848 7.10119 14.0326 6.75 14.9167 6.75"/></svg>';
var y4 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.13333 14.9167L12.4667 18.25M12.4667 18.25L15.8 14.9167M12.4667 18.25L12.4667 10.0833C12.4667 9.19928 12.1155 8.35143 11.4904 7.72631C10.8652 7.10119 10.0174 6.75 9.13333 6.75"/></svg>';
var L4 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.8833 15.8333L18.2167 12.5M18.2167 12.5L14.8833 9.16667M18.2167 12.5L10.05 12.5C9.16595 12.5 8.31811 12.8512 7.69299 13.4763C7.06787 14.1014 6.71667 14.9493 6.71667 15.8333"/></svg>';
var M3 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.41 9.66H9.4"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 9.66H14.59"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.31 14.36H9.3"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 14.36H14.59"/></svg>';
var v4 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 7V12M12 17V12M17 12H12M12 12H7"/></svg>';
var O3 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9L20 12L17 15"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 12H20"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 9L4 12L7 15"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12H10"/></svg>';
var T3 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="2" d="M5 10H19"/><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/></svg>';
var H3 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="2" d="M10 5V18.5"/><path stroke="currentColor" stroke-width="2" d="M14 5V18.5"/><path stroke="currentColor" stroke-width="2" d="M5 10H19"/><path stroke="currentColor" stroke-width="2" d="M5 14H19"/><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/></svg>';
var A4 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="2" d="M10 5V18.5"/><path stroke="currentColor" stroke-width="2" d="M5 10H19"/><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/></svg>';

class w2 {
  constructor({ api: t, items: e, onOpen: o3, onClose: i, cssModifier: n = "" }) {
    this.api = t, this.items = e, this.onOpen = o3, this.onClose = i, this.cssModifier = n, this.popover = null, this.wrapper = this.createToolbox();
  }
  static get CSS() {
    return {
      toolbox: "tc-toolbox",
      toolboxShowed: "tc-toolbox--showed",
      toggler: "tc-toolbox__toggler"
    };
  }
  get element() {
    return this.wrapper;
  }
  createToolbox() {
    const t = c3("div", [
      w2.CSS.toolbox,
      this.cssModifier ? `${w2.CSS.toolbox}--${this.cssModifier}` : ""
    ]);
    t.dataset.mutationFree = "true";
    const e = this.createPopover(), o3 = this.createToggler();
    return t.appendChild(o3), t.appendChild(e), t;
  }
  createToggler() {
    const t = c3("div", w2.CSS.toggler, {
      innerHTML: M3
    });
    return t.addEventListener("click", () => {
      this.togglerClicked();
    }), t;
  }
  createPopover() {
    return this.popover = new a2({
      items: this.items
    }), this.popover.render();
  }
  togglerClicked() {
    this.popover.opened ? (this.popover.close(), this.onClose()) : (this.popover.open(), this.onOpen());
  }
  show(t) {
    const e = t();
    Object.entries(e).forEach(([o3, i]) => {
      this.wrapper.style[o3] = i;
    }), this.wrapper.classList.add(w2.CSS.toolboxShowed);
  }
  hide() {
    this.popover.close(), this.wrapper.classList.remove(w2.CSS.toolboxShowed);
  }
}
function B3(d3, t) {
  let e = 0;
  return function(...o3) {
    const i = (/* @__PURE__ */ new Date()).getTime();
    if (!(i - e < d3))
      return e = i, t(...o3);
  };
}
var s = {
  wrapper: "tc-wrap",
  wrapperReadOnly: "tc-wrap--readonly",
  table: "tc-table",
  row: "tc-row",
  withHeadings: "tc-table--heading",
  rowSelected: "tc-row--selected",
  cell: "tc-cell",
  cellSelected: "tc-cell--selected",
  addRow: "tc-add-row",
  addRowDisabled: "tc-add-row--disabled",
  addColumn: "tc-add-column",
  addColumnDisabled: "tc-add-column--disabled"
};

class E4 {
  constructor(t, e, o3, i) {
    this.readOnly = t, this.api = e, this.data = o3, this.config = i, this.wrapper = null, this.table = null, this.toolboxColumn = this.createColumnToolbox(), this.toolboxRow = this.createRowToolbox(), this.createTableWrapper(), this.hoveredRow = 0, this.hoveredColumn = 0, this.selectedRow = 0, this.selectedColumn = 0, this.tunes = {
      withHeadings: false
    }, this.resize(), this.fill(), this.focusedCell = {
      row: 0,
      column: 0
    }, this.documentClicked = (n) => {
      const r = n.target.closest(`.${s.table}`) !== null, h4 = n.target.closest(`.${s.wrapper}`) === null;
      (r || h4) && this.hideToolboxes();
      const u2 = n.target.closest(`.${s.addRow}`), p2 = n.target.closest(`.${s.addColumn}`);
      u2 && u2.parentNode === this.wrapper ? (this.addRow(undefined, true), this.hideToolboxes()) : p2 && p2.parentNode === this.wrapper && (this.addColumn(undefined, true), this.hideToolboxes());
    }, this.readOnly || this.bindEvents();
  }
  getWrapper() {
    return this.wrapper;
  }
  bindEvents() {
    document.addEventListener("click", this.documentClicked), this.table.addEventListener("mousemove", B3(150, (t) => this.onMouseMoveInTable(t)), { passive: true }), this.table.onkeypress = (t) => this.onKeyPressListener(t), this.table.addEventListener("keydown", (t) => this.onKeyDownListener(t)), this.table.addEventListener("focusin", (t) => this.focusInTableListener(t));
  }
  createColumnToolbox() {
    return new w2({
      api: this.api,
      cssModifier: "column",
      items: [
        {
          label: this.api.i18n.t("Add column to left"),
          icon: S4,
          hideIf: () => this.numberOfColumns === this.config.maxcols,
          onClick: () => {
            this.addColumn(this.selectedColumn, true), this.hideToolboxes();
          }
        },
        {
          label: this.api.i18n.t("Add column to right"),
          icon: y4,
          hideIf: () => this.numberOfColumns === this.config.maxcols,
          onClick: () => {
            this.addColumn(this.selectedColumn + 1, true), this.hideToolboxes();
          }
        },
        {
          label: this.api.i18n.t("Delete column"),
          icon: b4,
          hideIf: () => this.numberOfColumns === 1,
          confirmationRequired: true,
          onClick: () => {
            this.deleteColumn(this.selectedColumn), this.hideToolboxes();
          }
        }
      ],
      onOpen: () => {
        this.selectColumn(this.hoveredColumn), this.hideRowToolbox();
      },
      onClose: () => {
        this.unselectColumn();
      }
    });
  }
  createRowToolbox() {
    return new w2({
      api: this.api,
      cssModifier: "row",
      items: [
        {
          label: this.api.i18n.t("Add row above"),
          icon: L4,
          hideIf: () => this.numberOfRows === this.config.maxrows,
          onClick: () => {
            this.addRow(this.selectedRow, true), this.hideToolboxes();
          }
        },
        {
          label: this.api.i18n.t("Add row below"),
          icon: x3,
          hideIf: () => this.numberOfRows === this.config.maxrows,
          onClick: () => {
            this.addRow(this.selectedRow + 1, true), this.hideToolboxes();
          }
        },
        {
          label: this.api.i18n.t("Delete row"),
          icon: b4,
          hideIf: () => this.numberOfRows === 1,
          confirmationRequired: true,
          onClick: () => {
            this.deleteRow(this.selectedRow), this.hideToolboxes();
          }
        }
      ],
      onOpen: () => {
        this.selectRow(this.hoveredRow), this.hideColumnToolbox();
      },
      onClose: () => {
        this.unselectRow();
      }
    });
  }
  moveCursorToNextRow() {
    this.focusedCell.row !== this.numberOfRows ? (this.focusedCell.row += 1, this.focusCell(this.focusedCell)) : (this.addRow(), this.focusedCell.row += 1, this.focusCell(this.focusedCell), this.updateToolboxesPosition(0, 0));
  }
  getCell(t, e) {
    return this.table.querySelectorAll(`.${s.row}:nth-child(${t}) .${s.cell}`)[e - 1];
  }
  getRow(t) {
    return this.table.querySelector(`.${s.row}:nth-child(${t})`);
  }
  getRowByCell(t) {
    return t.parentElement;
  }
  getRowFirstCell(t) {
    return t.querySelector(`.${s.cell}:first-child`);
  }
  setCellContent(t, e, o3) {
    const i = this.getCell(t, e);
    i.innerHTML = o3;
  }
  addColumn(t = -1, e = false) {
    var n;
    let o3 = this.numberOfColumns;
    if (this.config && this.config.maxcols && this.numberOfColumns >= this.config.maxcols)
      return;
    for (let r = 1;r <= this.numberOfRows; r++) {
      let h4;
      const l2 = this.createCell();
      if (t > 0 && t <= o3 ? (h4 = this.getCell(r, t), m3(l2, h4)) : h4 = this.getRow(r).appendChild(l2), r === 1) {
        const u2 = this.getCell(r, t > 0 ? t : o3 + 1);
        u2 && e && C3(u2);
      }
    }
    const i = this.wrapper.querySelector(`.${s.addColumn}`);
    (n = this.config) != null && n.maxcols && this.numberOfColumns > this.config.maxcols - 1 && i && i.classList.add(s.addColumnDisabled), this.addHeadingAttrToFirstRow();
  }
  addRow(t = -1, e = false) {
    let o3, i = c3("div", s.row);
    this.tunes.withHeadings && this.removeHeadingAttrFromFirstRow();
    let n = this.numberOfColumns;
    if (this.config && this.config.maxrows && this.numberOfRows >= this.config.maxrows && h4)
      return;
    if (t > 0 && t <= this.numberOfRows) {
      let l2 = this.getRow(t);
      o3 = m3(i, l2);
    } else
      o3 = this.table.appendChild(i);
    this.fillRow(o3, n), this.tunes.withHeadings && this.addHeadingAttrToFirstRow();
    const r = this.getRowFirstCell(o3);
    r && e && C3(r);
    const h4 = this.wrapper.querySelector(`.${s.addRow}`);
    return this.config && this.config.maxrows && this.numberOfRows >= this.config.maxrows && h4 && h4.classList.add(s.addRowDisabled), o3;
  }
  deleteColumn(t) {
    for (let o3 = 1;o3 <= this.numberOfRows; o3++) {
      const i = this.getCell(o3, t);
      if (!i)
        return;
      i.remove();
    }
    const e = this.wrapper.querySelector(`.${s.addColumn}`);
    e && e.classList.remove(s.addColumnDisabled);
  }
  deleteRow(t) {
    this.getRow(t).remove();
    const e = this.wrapper.querySelector(`.${s.addRow}`);
    e && e.classList.remove(s.addRowDisabled), this.addHeadingAttrToFirstRow();
  }
  createTableWrapper() {
    if (this.wrapper = c3("div", s.wrapper), this.table = c3("div", s.table), this.readOnly && this.wrapper.classList.add(s.wrapperReadOnly), this.wrapper.appendChild(this.toolboxRow.element), this.wrapper.appendChild(this.toolboxColumn.element), this.wrapper.appendChild(this.table), !this.readOnly) {
      const t = c3("div", s.addColumn, {
        innerHTML: v4
      }), e = c3("div", s.addRow, {
        innerHTML: v4
      });
      this.wrapper.appendChild(t), this.wrapper.appendChild(e);
    }
  }
  computeInitialSize() {
    const t = this.data && this.data.content, e = Array.isArray(t), o3 = e ? t.length : false, i = e ? t.length : undefined, n = o3 ? t[0].length : undefined, r = Number.parseInt(this.config && this.config.rows), h4 = Number.parseInt(this.config && this.config.cols), l2 = !isNaN(r) && r > 0 ? r : undefined, u2 = !isNaN(h4) && h4 > 0 ? h4 : undefined;
    return {
      rows: i || l2 || 2,
      cols: n || u2 || 2
    };
  }
  resize() {
    const { rows: t, cols: e } = this.computeInitialSize();
    for (let o3 = 0;o3 < t; o3++)
      this.addRow();
    for (let o3 = 0;o3 < e; o3++)
      this.addColumn();
  }
  fill() {
    const t = this.data;
    if (t && t.content)
      for (let e = 0;e < t.content.length; e++)
        for (let o3 = 0;o3 < t.content[e].length; o3++)
          this.setCellContent(e + 1, o3 + 1, t.content[e][o3]);
  }
  fillRow(t, e) {
    for (let o3 = 1;o3 <= e; o3++) {
      const i = this.createCell();
      t.appendChild(i);
    }
  }
  createCell() {
    return c3("div", s.cell, {
      contentEditable: !this.readOnly
    });
  }
  get numberOfRows() {
    return this.table.childElementCount;
  }
  get numberOfColumns() {
    return this.numberOfRows ? this.table.querySelectorAll(`.${s.row}:first-child .${s.cell}`).length : 0;
  }
  get isColumnMenuShowing() {
    return this.selectedColumn !== 0;
  }
  get isRowMenuShowing() {
    return this.selectedRow !== 0;
  }
  onMouseMoveInTable(t) {
    const { row: e, column: o3 } = this.getHoveredCell(t);
    this.hoveredColumn = o3, this.hoveredRow = e, this.updateToolboxesPosition();
  }
  onKeyPressListener(t) {
    if (t.key === "Enter") {
      if (t.shiftKey)
        return true;
      this.moveCursorToNextRow();
    }
    return t.key !== "Enter";
  }
  onKeyDownListener(t) {
    t.key === "Tab" && t.stopPropagation();
  }
  focusInTableListener(t) {
    const e = t.target, o3 = this.getRowByCell(e);
    this.focusedCell = {
      row: Array.from(this.table.querySelectorAll(`.${s.row}`)).indexOf(o3) + 1,
      column: Array.from(o3.querySelectorAll(`.${s.cell}`)).indexOf(e) + 1
    };
  }
  hideToolboxes() {
    this.hideRowToolbox(), this.hideColumnToolbox(), this.updateToolboxesPosition();
  }
  hideRowToolbox() {
    this.unselectRow(), this.toolboxRow.hide();
  }
  hideColumnToolbox() {
    this.unselectColumn(), this.toolboxColumn.hide();
  }
  focusCell() {
    this.focusedCellElem.focus();
  }
  get focusedCellElem() {
    const { row: t, column: e } = this.focusedCell;
    return this.getCell(t, e);
  }
  updateToolboxesPosition(t = this.hoveredRow, e = this.hoveredColumn) {
    this.isColumnMenuShowing || e > 0 && e <= this.numberOfColumns && this.toolboxColumn.show(() => ({
      left: `calc((100% - var(--cell-size)) / (${this.numberOfColumns} * 2) * (1 + (${e} - 1) * 2))`
    })), this.isRowMenuShowing || t > 0 && t <= this.numberOfRows && this.toolboxRow.show(() => {
      const o3 = this.getRow(t), { fromTopBorder: i } = g3(this.table, o3), { height: n } = o3.getBoundingClientRect();
      return {
        top: `${Math.ceil(i + n / 2)}px`
      };
    });
  }
  setHeadingsSetting(t) {
    this.tunes.withHeadings = t, t ? (this.table.classList.add(s.withHeadings), this.addHeadingAttrToFirstRow()) : (this.table.classList.remove(s.withHeadings), this.removeHeadingAttrFromFirstRow());
  }
  addHeadingAttrToFirstRow() {
    for (let t = 1;t <= this.numberOfColumns; t++) {
      let e = this.getCell(1, t);
      e && e.setAttribute("heading", this.api.i18n.t("Heading"));
    }
  }
  removeHeadingAttrFromFirstRow() {
    for (let t = 1;t <= this.numberOfColumns; t++) {
      let e = this.getCell(1, t);
      e && e.removeAttribute("heading");
    }
  }
  selectRow(t) {
    const e = this.getRow(t);
    e && (this.selectedRow = t, e.classList.add(s.rowSelected));
  }
  unselectRow() {
    if (this.selectedRow <= 0)
      return;
    const t = this.table.querySelector(`.${s.rowSelected}`);
    t && t.classList.remove(s.rowSelected), this.selectedRow = 0;
  }
  selectColumn(t) {
    for (let e = 1;e <= this.numberOfRows; e++) {
      const o3 = this.getCell(e, t);
      o3 && o3.classList.add(s.cellSelected);
    }
    this.selectedColumn = t;
  }
  unselectColumn() {
    if (this.selectedColumn <= 0)
      return;
    let t = this.table.querySelectorAll(`.${s.cellSelected}`);
    Array.from(t).forEach((e) => {
      e.classList.remove(s.cellSelected);
    }), this.selectedColumn = 0;
  }
  getHoveredCell(t) {
    let e = this.hoveredRow, o3 = this.hoveredColumn;
    const { width: i, height: n, x: r, y: h4 } = k3(this.table, t);
    return r >= 0 && (o3 = this.binSearch(this.numberOfColumns, (l2) => this.getCell(1, l2), ({ fromLeftBorder: l2 }) => r < l2, ({ fromRightBorder: l2 }) => r > i - l2)), h4 >= 0 && (e = this.binSearch(this.numberOfRows, (l2) => this.getCell(l2, 1), ({ fromTopBorder: l2 }) => h4 < l2, ({ fromBottomBorder: l2 }) => h4 > n - l2)), {
      row: e || this.hoveredRow,
      column: o3 || this.hoveredColumn
    };
  }
  binSearch(t, e, o3, i) {
    let n = 0, r = t + 1, h4 = 0, l2;
    for (;n < r - 1 && h4 < 10; ) {
      l2 = Math.ceil((n + r) / 2);
      const u2 = e(l2), p2 = g3(this.table, u2);
      if (o3(p2))
        r = l2;
      else if (i(p2))
        n = l2;
      else
        break;
      h4++;
    }
    return l2;
  }
  getData() {
    const t = [];
    for (let e = 1;e <= this.numberOfRows; e++) {
      const o3 = this.table.querySelector(`.${s.row}:nth-child(${e})`), i = Array.from(o3.querySelectorAll(`.${s.cell}`));
      i.every((r) => !r.textContent.trim()) || t.push(i.map((r) => r.innerHTML));
    }
    return t;
  }
  destroy() {
    document.removeEventListener("click", this.documentClicked);
  }
}

class F3 {
  static get isReadOnlySupported() {
    return true;
  }
  static get enableLineBreaks() {
    return true;
  }
  constructor({ data: t, config: e, api: o3, readOnly: i, block: n }) {
    this.api = o3, this.readOnly = i, this.config = e, this.data = {
      withHeadings: this.getConfig("withHeadings", false, t),
      stretched: this.getConfig("stretched", false, t),
      content: t && t.content ? t.content : []
    }, this.table = null, this.block = n;
  }
  static get toolbox() {
    return {
      icon: A4,
      title: "Table"
    };
  }
  render() {
    return this.table = new E4(this.readOnly, this.api, this.data, this.config), this.container = c3("div", this.api.styles.block), this.container.appendChild(this.table.getWrapper()), this.table.setHeadingsSetting(this.data.withHeadings), this.container;
  }
  renderSettings() {
    return [
      {
        label: this.api.i18n.t("With headings"),
        icon: T3,
        isActive: this.data.withHeadings,
        closeOnActivate: true,
        toggle: true,
        onActivate: () => {
          this.data.withHeadings = true, this.table.setHeadingsSetting(this.data.withHeadings);
        }
      },
      {
        label: this.api.i18n.t("Without headings"),
        icon: H3,
        isActive: !this.data.withHeadings,
        closeOnActivate: true,
        toggle: true,
        onActivate: () => {
          this.data.withHeadings = false, this.table.setHeadingsSetting(this.data.withHeadings);
        }
      },
      {
        label: this.data.stretched ? this.api.i18n.t("Collapse") : this.api.i18n.t("Stretch"),
        icon: this.data.stretched ? R4 : O3,
        closeOnActivate: true,
        toggle: true,
        onActivate: () => {
          this.data.stretched = !this.data.stretched, this.block.stretched = this.data.stretched;
        }
      }
    ];
  }
  save() {
    const t = this.table.getData();
    return {
      withHeadings: this.data.withHeadings,
      stretched: this.data.stretched,
      content: t
    };
  }
  destroy() {
    this.table.destroy();
  }
  getConfig(t, e = undefined, o3 = undefined) {
    const i = this.data || o3;
    return i ? i[t] ? i[t] : e : this.config && this.config[t] ? this.config[t] : e;
  }
  static get pasteConfig() {
    return { tags: ["TABLE", "TR", "TH", "TD"] };
  }
  onPaste(t) {
    const e = t.detail.data, o3 = e.querySelector(":scope > thead, tr:first-of-type th"), n = Array.from(e.querySelectorAll("tr")).map((r) => Array.from(r.querySelectorAll("th, td")).map((l2) => l2.innerHTML));
    this.data = {
      withHeadings: o3 !== null,
      content: n
    }, this.table.wrapper && this.table.wrapper.replaceWith(this.render());
  }
}

// client/index.js
var import_editorjs_paragraph_with_alignment = __toESM(require_bundle3(), 1);
var import_editorjs_latex = __toESM(require_src(), 1);
var editor = new Aa({
  holder: "editor",
  onReady: () => {
    new import_editorjs_undo.default({ editor });
    new import_editorjs_drag_drop.default(editor);
  },
  tools: {
    Math: {
      class: import_editorjs_latex.default,
      shortcut: "CMD+SHIFT+L",
      inlineToolbar: true,
      config: {
        css: ".math-input-wrapper { padding: 5px; }"
      }
    },
    table: {
      class: F3,
      inlineToolbar: true,
      config: {
        rows: 2,
        cols: 3,
        maxRows: 5,
        maxCols: 5
      }
    },
    paragraph: {
      class: import_editorjs_paragraph_with_alignment.default,
      inlineToolbar: false
    },
    header: {
      class: v,
      config: {
        placeholder: "Enter a header",
        levels: [2, 3, 4],
        defaultLevel: 3
      },
      shortcut: "CMD+SHIFT+H"
    },
    quote: {
      class: m,
      inlineToolbar: true,
      shortcut: "CMD+SHIFT+O",
      config: {
        quotePlaceholder: "Enter a quote",
        captionPlaceholder: "Quote's author"
      }
    },
    list: {
      class: G3,
      inlineToolbar: true,
      config: {
        defaultStyle: "unordered"
      }
    }
  }
});
